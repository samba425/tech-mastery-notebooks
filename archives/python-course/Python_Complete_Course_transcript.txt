 In this course, you're going to learn everything you need to get started with Python. Just be aware that I've designed this course for beginners, so if you have some programming experience, check out my other Python course for developers. You can see the link on the top right corner of this video. So Python is the world's fastest growing and most popular programming language, not just amongst software developers, but also amongst mathematicians, data analysts, scientists, accountants, network engineers, and even kids. In fact, it's the ideal programming language to learn first. But what makes Python so special? Here are six reasons. With Python, you can solve complex problems in less time with fewer lines of code than many other languages. That's why huge companies like Google, Spotify, Dropbox, and Facebook have embraced this beautiful and powerful language. Here is an example. Let's say we want to extract the first three characters of the text, Hello, Wurf. This is the code we would have to write in C-sharp. This is how we would do this in JavaScript. And here's how we would do it in Python. See how clean and simple the language is? And that's just the beginning. Python is a multipurpose language. And you can use it for a wide range of jobs such as data analysis, AI and machine learning, writing automation scripts, building web, mobile, and desktop applications, as well as software testing or even hacking. So if you want a high paying, long lasting career in any of these areas, especially AI and machine learning, Python is the language to put those opportunities at your fingertips. In fact, according to Indie.com, the average salary of a Python developer in the US was over $15,000 in March 2018. And here are four more reasons that make Python the most desirable language. Python is a high level language so you don't have to worry about complex tasks such as memory management as you do in C++. This cross-platform, which means you can build and run Python apps on Windows, Mac, and Linux. It has a huge community, so whenever you get stuck, there's someone out there to help. And it has a large ecosystem of libraries, frameworks, and tools. Whatever you want to do, it is likely that someone else has done it before because Python has been around for over 20 years. There are two versions of Python out there. Python 2, which is the legacy version of Python, and is going to be supported until year 2020. And Python 3, which is Python for the future. In this course, you're going to learn Python 3. Hi, my name is Mosh Hamidani, and I'm going to be your instructor in this course. I'm a software engineer with 18 years of experience, and I have taught way over a million people how to code or how to become top professional software engineers. To learn more about me and my courses, head over to code with Mosh.com. All right, now let's get started. All right, now we're ready to download and install Python. The first thing I want you to do is to open up your browser and head over to python.org. On this page, under the downloads, you can see the latest version of Python, currently the latest version is 3.7. Chances are in the future when you're watching this video, there is a newer version available. Don't worry all the materials in this course will continue to apply with the future versions of Python. So go ahead and download Python. And then run it. If you're on Windows, we're going to see this checkbox here. Add Python to path. This is very important. Make sure to take it. Otherwise, you're not going to be able to follow the course. So now go ahead and install it. Now let's verify that we have installed Python properly. If you're on Windows, here in this search bar, type cmd, which is short for command prompt. Now, if you're in command prompt, type python, you can see we have successfully installed Python version 3.7. Now to exit, press control Z, and then enter. Done. If you're on Mac, press command and space, this opens up the spotlight search. So here type terminal. Terminal on Mac is like command prompt on Windows. Now Mac and Linux, by default, come with an older version of Python that is version 2. So if you type Python, you can see Python 2 here. Let's talk what we want. So press control D to exit, and then run Python 3. And this verifies that we have successfully installed Python 3.7. So this environment you see here is what we call Python interpreter, which is basically a program that executes Python code. We can type our Python code in a file and give it to this interpreter, or we can type our code directly here in this interactive shell. So here we can write an expression like 2 plus 2. In programming, an expression is a piece of code that produces a value. So here when we add 2 plus 2, we get a value. That is why we refer to this piece of code as an expression. So enter, we get 4. Let's try a different kind of expression. Let's see if 2 is greater than 1. We get true, which is an example of a Boolean value. You're going to learn about these Boolean values in the next section. Now, what if we type 2 is greater than 5? Enter, we get false. So in programming, we have true and false, which are similar to yes and no in English. Now, what if we type 2 is greater than, but we don't add a second value here. Just press enter. We get a syntax error. In programming, syntax means grammar. So just like we have the concept of grammar in the languages that we speak, we have the exact same concept in programming. If we write a sentence, that is not grammatically correct, chances are some people may not understand that sentence. So in this example, we have this expression, which is incomplete. It doesn't have the right grammar or syntax. That is why Python interpreter is complaining by returning an error. So this interactive shell is a great way to quickly experiment with a bit of Python code. But that's not how we build real-world applications. To do that, we need a code editor. And that's what I'm going to show you in the next lecture. When it comes to typing Python code, you have two options. You can use a code editor or an IDE, which is short for integrated development environment. An IDE is basically a code editor with some fancy features like auto completion, which means as you type code, this feature helps you complete your code. So you don't have to type every character by hand. It's a productivity boosting feature. It also gives you additional features like debugging, which means finding and fixing bugs in your programs, testing and so on. For both code editors and IDE, there's so many options out there that most popular code editors are VS Code, Adam and Sublime. You can use the code editor that you prefer. In terms of the IDE, again, there are so many options out there, the most popular one is PyCharm. In this course, I'm going to use VS Code or Visual Studio Code, because that's my favorite code editor. Later in the course, I will show you how to install a plugin or an extension that will convert VS Code to a powerful IDE. So before going any further, head over to code.visualstudio.com and download the latest version of VS Code. Now with VS Code open, on the top, from the file menu, go to Open, and somewhere on your disk create a new folder. Let's call this folder HelloWorld. And then open it. Beautiful. Now click this icon on the top. This opens up the Explorer panel. In this panel, you can see all the files and folders in your project. So let's add a new file and call that app.py. So all our Python files should have the Py extension. Press Enter. Now let's close this and type a bit of Python code. In this lecture, we're going to use one of the built-in functions in Python called print. So in Python, we have a lot of built-in functions for performing various kinds of tasks. For example, as a metaphor, think of the remote control of your TV. On this remote control, you have a bunch of functions like turn on, turn off, change the channel, change the volume, and so on. These are the built-in functions in your TV. We have the same concept in Python and many other programming languages. So one of these built-in functions that comes with Python is print. And we can use this to print something on the screen. Now, whenever you want to use a function, you should open and close parentheses. In programming, we say we're calling the print function. Calling a function means executing it. Now let's display the hello world message on the screen. Whenever you want to work with text, you should put your text in between quotes, either double quotes or single quotes. Now I'm going to go with double quotes and add hello world. And then put a happy Persian cat here. Beautiful. Save the changes with command and s on Mac or control and s on Windows. Now to execute this code, we need to go back to command prompt on Windows or terminal on Mac. But the good news is that we don't have to switch programs. Here in VS Code, we have an integrated terminal. So press control and back tick. That is the key before number one on your keyboard. That is just below the escape button. So this is our integrated terminal. Now if you're on Windows type, Python, if you're on Mac or Linux type Python 3, and next to that, add the name of our file. That is app on Python. And here's our hello world message in the terminal. Beautiful. Now let's take this to the next level and make it a little bit more interesting. Let's close this terminal window by pressing control and back tick. And add a second line of code. So one more time print. This time let's add quotes with a star in between them. Now let's say we want to repeat this star 10 times. So here we can multiply this by 10, save the changes, open up the terminal and run our program. And you can see this star is repeated 10 times. So as you see, the instructions on our program are executed from top to bottom in order. In the next lecture, I'm going to show you how to convert this VS Code to a powerful IDE for building Python applications. And this lecture, I'm going to show you how to convert VS Code to a powerful IDE by using an extension called Python. With this extension or plugin, we get a number of features such as Linting, which basically means analyzing our code for potential errors. We also get debugging, which involves finding and fixing errors. We'll look at this later in the course. We also get auto completion, which basically helps us write code faster. So we don't have to type every character. We get code formatting, which is all about making our code clean and readable, just like how we format our articles, newspapers, books to make them clean and readable. We get unit testing, which involves writing a bunch of tests for our code. We can run these tests in an automated fashion to make sure our code is behaving correctly. And finally, we get code snippets, which are reusable code blocks that we can quickly generate. So we don't have to type them all by hand. Now, don't worry about memorizing any of these. As we go through the course, you're going to learn about these features. Now, here in VS Code, on the left side, click this icon. This opens the extensions tab. So these are the extensions that we can install in VS Code to bring in additional functionality. Here under the recommended tab, you can see the Python extension. If you don't see this, simply type Python here on the top. And here's the extension. So go ahead and install this. And then you will have to reload VS Code. Now, here on the bottom right corner, you can see this message, Linter, Pylint is not installed. So as I told you before, Linting is about finding potential errors in our code. Linter is a program or a tool that analyzes our code and finds these potential problems. Now, for Python, there are several Linter's out there. Pylint is one of the most popular ones that this Python extension uses by default. So we need to go ahead and install Pylint as well. Now, to do this, first, we need to change our Python environment. So if you look here on the bottom left corner, you can see the current Python that is used in VS Code. That is Python 2.6.9 on my machine. Chances are you see a different version here. So click here. And in this list, make sure to select Python 3.7. So these changes are Python environment to Python 3.7. And then we can install Pylint by clicking this button. Okay, Pylint is installed. Beautiful. In the next lecture, I will show you how Linting works. In this lecture, I'm going to show you Linting and Action. So let's start by writing some invalid code like this. Print, space with no parentheses, and then hello world. Earlier, I told you that print is a built-in function. And whenever you want to use or call a function, you should always use parentheses. Now, to be more precise, this is actually valid Python 2 code. But because we're using Python 3 here, this is invalid code from Python 3's point of view. So now, when I save the changes, you can see this red underlying here. Let's hover our mouse over this underlying. You can see this tooltip. It's coming from Pylint. And here's the error message missing parentheses in call to print. Did you mean print with parentheses? So this is the benefit of Linting. As you're writing code, you can see potential problems in your code. You don't have to wait to run your program to see these errors. So now, if we put parentheses here and save the changes, you can see that red underlying is gone. Let's look at another error. Let's type 2 plus and then save the changes. Earlier, we ran this code in Python Interpreters Interactive Shell. There, we got a syntax or grammar error. So if you hover your mouse here one more time, you can see Pylint is telling us that this is invalid syntax or invalid grammar. It's like an incomplete sentence. So this is Linting in action. Now, let me show you a couple useful shortcuts here. On the top, look at the View menu. Here we have this Problems menu. Look at the shortcut. On Mac, it's Shift, Command and M. On Windows, it's probably Shift Control M. So as you're working with VS Code, try to memorize these shortcuts because they really help you write code faster. Now, let's take a look at this Problems panel. So this Problems panel lists all the issues in your code in one place. So if you have an application with multiple files, this is really useful because some of those files may not currently be open. So this Linter Pylint will analyze all your files. And if it finds any issues, it will list them here in the Problems panel. Now you can also put this on the right side of the screen. So let's put it here. So as you write code, these problems will appear here. Now let's fix this issue. So I'm going to add three here. Save the changes and you can see the problem disappear. And one last thing before we finish this lecture. Once again on the top, let's go to the View menu. The first item is Command Palette. This is a very important feature in VS Code. Once again, look at the shortcut that is Shift, Command and P on Mac, or Shift Control P on Windows. With this Command Palette, you can execute various commands in VS Code. If you type Lint here, you can see all commands related to Linting. As you can see, all these commands are prefixed with Python, because these commands come with a Python extension that we installed earlier. So these are additional features available to us in VS Code. The first command here is Select Linter. In this list, you can see various Linters available for Pilate. So as you're reading tutorials or talking to other people, you will hear about Linters, such as Flake 8, My Pie, Pep 8, and so on. Different developers prefer different Linters. I personally prefer Pilate. That is the most popular one. And that is the default Linter set in the Python extension of VS Code. If you're adventurous, you can try using other Linters on your own. The difference between these Linters is in how they find and report errors. Some error messages are more meaningful or more friendly. The others are more ambiguous. So that's all about Linting. In the next lecture, we'll talk about Formatting Code. In Python community, we have a bunch of documents called Python, Enhancement Proposals, or PEPs. Here on Google, if you search for Python peps, you can see the list of all these PEPs under Python.org, slash dev slash PEPs. Let's have a quick look here. So here are the PEPs. You can see each PEP has a number and a title. The one that is very popular amongst Python developers is PEP 8, which is a style guide for Python code. A style guide is basically a document that defines a bunch of rules for formatting and styling our code. If you follow these conventions, the code that you write will end up being consistent with other people's code. Now, if you have time, you can go ahead and read this PEP 8 documentation, but if not, don't worry, because throughout the scores, I'm going to explain the key things in PEP 8. In this lecture, I'm going to show you a tool that helps you automatically format your code according to PEP 8. So back in VS code, let's write some Python code. X equals one. Here, I'm declaring a variable and setting it to one. If you're not familiar with variables, don't worry, in the next section, you're going to learn about them. So according to PEP 8, this code is considered ugly, because by convention, we should add a space around this equal sign or the assignment operator. Now, since you're starting out with Python, you probably don't know these rules. So let me show you a tool that helps you automatically format your code. Let's revert this back to its original state. Now, we need to go back to the command palette. Remember, so it's right here under view, and the shortcut is shift, command, and P. Here, if you search for format, you can see this command, format document. The first time you execute this command, you're going to see this message here. Formatter autoPEP 8 is not in stock. So there are a bunch of tools for formatting Python code. The most popular one is autoPEP 8, and this is the tool that this Python extension we installed uses to format our code. So let's go ahead and install this. Good. Now, one more time, let's open up the command palette and execute format document. See, this tool automatically formats our code. Beautiful. Let's take a look at another example. I'm going to declare another variable, Y and set it to two, and a variable with a long name, like unit, underline price, I'm set this to three. Now, some developers have this habit of formatting their variable declarations like this. So they put all these equal signs in the same column. According to PEP 8, this is considered ugly. So once again, let's format our code. That is better, beautiful. Now, let me show you a trick. Opening up this command palette and searching for format document every time is a little bit time consuming. So I'm going to show you how to have your file automatically formatted as soon as you save the changes. On the top, let's go to the code menu, preferences, and settings. Here in the search box, search for format on save. So we have this option editor format on save. Take this. Now back to app.py. I'm going to change the formatting of these lines, make them really ugly. Now, as soon as I save the changes, you can see my code is reformatted. Beautiful. So you have learned that in order to run this Python program, we'll have to open up the terminal window and run Python on windows or Python 3 on Mac and then app.py. This is a little bit tedious. So let me show you a shortcut. Once again, let's go to the extensions panel. Here, search for code runner. There are multiple code runners out there. The one that I'm talking about is this one with the yellow icon. So go ahead and install this. And then reload VS code. Now, instead of opening up the terminal and manually typing Python after.py, all you have to do is to press control, alt, and in. You can see the output here. Beautiful. Just be aware that if you make any changes, you will have to save the changes before using this shortcut. Otherwise, you're going to see the old result. Now, there is a tiny problem here. So you can see this is the command that is executed to run this Python program. So by default, this command is using Python, dash U, and here is the name of our file. If you're on windows, that's perfect to find. But if you're on Mac, you know that Python refers to Python 2. Here, we want to change this to Python 3. This is very easy. Once again, on the top, under the code menu, let's go to preferences, settings, and then here, under this dot dot dot, go to open settings.json. Now, here in the search bar, type code dash runner dot executor map. So these are the default settings used by this code runner extension. You can see this extension supports executing code in a lot of languages like JavaScript, Java, and so on. Now, if you scroll down, here we can see Python, and in front of that, you can see the command that is used to execute Python code. We need to change this. However, we cannot change the default settings, we should change the user settings. So on the right side, after the last setting, type a comma, and then encodes type code dash runner dot executor map, and then press enter. This will automatically copy all the settings on the left side to the right side. Now we can easily change one of these. So here's Python. Let's change the command to Python 3. You only have to do this if you're on Mac. And by the way, sorry, if we have mentioned Windows and Mac, a few times throughout this course, that's pretty much it. We are not going to differentiate between Windows and Mac in the future. So save the changes, and we're done. Let me talk about Python. We mean two separate things that are closely related. Python language and a particular implementation. Python as language is just a specification that defines a sort of rules and grammar for writing Python code. A Python implementation is basically a program that understands those rules and can execute Python code. Earlier in the course, we downloaded Python from Python. Earlier in the course, we downloaded Python from Python.org. This is the default implementation of Python called C Python. It's a program written in C. That's why it's called C Python. So here in terminal, when we run Python, we get this C Python. This is the default implementation of Python. There are a few other implementations after such as Jython, written in Java, iron Python, written in C sharp, and PyPy written in a subset of Python itself. As new features are added to the Python language, they are first supported by C Python because that's the default implementation. And then they will gradually come to the other implementations. In theory, if we give some Python code to any of these implementations, we should get the same result. But in practice, that's not always the case. Certain features may be available in one implementation, but not another. Or they may just behave a little bit differently in a particular implementation. I'll invite ask, what is the point of this? Why do we have several implementations of Python? Wouldn't C Python be enough? Well, it's for the same reason that we have multiple operating systems, or multiple browsers, or multiple programming languages. After all these years, we programmers haven't agreed on a single programming language. And that's the same story with Python implementations. However, there is one technical reason behind these implementations that you should be aware of. Since json is implemented in Java, it allows you to reuse some existing Java code in a Python program. So if you're a Java developer and you want to import some Java code into a Python program, you should use json instead of C Python. Similarly, iron Python is written in C sharp, so if you're a C sharp developer and want to bring some C sharp code into a Python program, you'll have to use iron Python. Next, we'll look at how exactly C Python executes Python code. The programming languages we use, like C, C sharp, Java, Python, these are all simple text-based languages that we humans understand. Computers don't understand them. They only understand machine code. So if we have some code written in C, we should convert it to machine code. And that's the job of a C compiler. So a C compiler is a program that knows how to convert or compile C code into machine code. However, this machine code is specific to the type of CPU of a computer. So if we compile a C program on a Windows machine, we can't execute it on a Mac. Because Windows and Mac have different machine code, just like how people from different countries speak different languages. Java came to solve this problem. Java compiler doesn't compile Java code into machine code. Instead, it compiles it into a portable language called Java bytecode, which is not specific to a hardware platform like Windows or Mac. Now, we still need to convert Java bytecode to machine code. So Java also comes with a program called Java Virtual Machine or JVM for doing this. When we run a Java program, JVM kicks in, it loads our Java bytecode, and then at runtime, it will convert each instruction to machine code. With this model, we can run Java bytecode on any platforms that have a JVM. We have JVM implementations for Windows, Mac, and so on. So the JVM implementation on Windows knows how to convert Java bytecode into machine code that a Windows machine can understand. C sharp and Python have also taken the same route, so there are platform independent. When we run a Python program using C Python, first it will compile our Python code into Python bytecode, then it will pass that bytecode to Python Virtual Machine, which will in turn convert it into machine code and execute it. This is how C Python works. In the last lecture we talked about various Python implementations. I told you that if you want to reuse some Java code in a Python program, you should use Jython. Now, let's see how Jython makes this possible. When you use Jython to run a Python program, instead of compiling your Python code into Python bytecode, it will compile it to Java bytecode. So you can take this Java bytecode and run it using Java Virtual Machine. And that's why you can import some Java code into a Python program when using Jython, because the end result is Java bytecode, which will eventually be executed by Java Virtual Machine. So I've got a few questions for you because I want to see if you have been really paying attention to this video or not. You better have. So here's the first question. For each question, I want you to pause the video, think about the answer for a few seconds when you're ready, continue watching. So here's the first question. What is an expression? An expression is a piece of code that produces a value. Here's an example of an expression. What do you think is the value of this expression? Well, here we have this string. We're multiplying this by three. So the result will be a string of three asterisk, like this. Here's another question. What is a syntax error? A syntax error is a kind of error that is due to bad syntax or bad grammar in the code. And finally, the last question. What does a Linter do? A Linter is a tool that checks our code for potential errors, mostly in the category of syntaxical errors. So if you have grammatical issues in our code, the Linter will tell us before running our program. Okay, that's it for now. If you like more quizzes and programming exercises, look at the link below this video. And if you have enjoyed this video, I hope you have. Please support me by giving a thumbs up. Please like this video and share it with others. In the next section, we're going to look at the fundamentals of Python. Let's start this section by a discussion of variables, which are one of the core concepts in programming. We use variables to store data in computer's memory. Here are a few examples. I'm going to define a variable called students on the line count and setting it to a thousand. When we run this program, Python interpreter will allocate some memory and store this number thousand in that memory space. Then it will have this variable reference that memory location. So this variable is just like a label for that memory location. We can use this variable or this label anywhere in our program to get access to that memory location and the data stored there. So now if we print students count and run our program, we will get the number thousand. So this is the basic of variables. Now, what kind of data can we store in computer's memory? Well, we have several different kinds of data. In this section, we're going to look at the built-in primitive types in Python. Primitive types can be numbers, Booleans and Strings. Let me show you. So here we have a whole number we refer to this as an integer in programming. We can also have numbers with a decimal point. Let's take a look. So rating, we set this to 4.99. This is what we call a float or a floating point number. And this terminology is not specific to Python. In the future, when you learn a new programming language, we're going to hear these terms again. Now let's take a look at an example of a Boolean. It is published. We set this to true or false. These are examples of Boolean values in programming. So Boolean values can either be true or false. And these are exactly like yes and no in English. Later in the course, you will learn that we'll use these Boolean values to make decisions in our programs. For example, if the user is an admin user, perhaps we want to give them extra permissions. So these are the Boolean values. Now take into account that Python is a case sensitive language, which means lowercase and uppercase characters have different meanings. So Boolean values should always start with a capital letter, like what you see here. If we type false or false, these are not accepted Boolean values in Python. Only what you see here is a valid Boolean value. So false or true. And finally, let's take a look at an example of a string. So of course, on the line name, we set this to a string, like Python programming. So string, as I told you before, is like text. Whenever you want to work with text in your programs, you need to surround your text with quotes. So these are the basics of variables. So these are the variables from the last lecture. Now I've got a question for you. There are four things that I've consistently used in this program. Can you spot them? If you want, you can pause the video, think about this for a few seconds and then continue watching. So here are those four things. The first thing is that all my variable names are descriptive and meaningful. So students count represents the number of students for a course. Or course name, clearly explains that this variable holds the name of a course. One of the issues that I see a lot amongst beginner programmers is that they use mystical names for their variables. Something like this, CN, as in short for course name. When someone else reads this code, they have no idea what CN stands for. Or they use variable names like C1. When I look at that code, I wonder where is C2? And what is the difference between C1 and C2? So these variable names are very mystical. That's a bad practice. Make sure your variable names are always descriptive and meaningful, because this makes your code more maintainable. Now, there are times that you can use short variable names like x, y, z. If you're dealing with things like coordinates, so that's an exception. Now, the second thing that I have consistently used in this code is that I have used lowercase letters to name my variables. So here we don't have course name, all in capital, or in title case, all letters are lowercase. Let's delete this. The third thing that I've consistently used here is that I have used an underscore to separate multiple words. And I've done this to make my variable names more readable. Because in Python, we cannot have a space in variable names, so we cannot have course name. And if you put these two words together, it's a little bit hard to read. That's why we use an underscore. And the fourth thing that I have used consistently here is that I have put a space around this equals sign. Again, that's one of the issues I see a lot amongst beginners. They write code like this. This is a little bit ugly. This is what we call dirty code, dirty, stinky, smelly. You should write code that is clean and beautiful. So other people can read it like a story, like a newspaper article. You should be formatted properly. And that's why we have pep8 in Python. Now, the good thing is if you forget these rules when you save the changes, auto pep8 kicks in, I didn't automatically reformat your code. But that aside, you should always give yourself the habits of writing clean code without relying too much on the tooling. So these are all the best practices about naming your variables. Next, we're going to look at strings in more detail. So here we have this course variable set to Python programming. I also told you before, whenever you work with text, you should surround your text with quotes. You can either use double quotes or single quotes. That's more of a personal preference. But quite often we use double quotes. We also have triple quotes and we use them to format a long string. For example, if you have, let's say, a variable message, that is the message we want to include in the body of an email, you can use triple quotes to format it like this. Hi, John. This is Marsh from code with marsh.com blah, blah, blah. So that's when we use triple quotes. Now, we don't need this and this lecture. So delete. Let me show you a few useful things you can do with strings. First of all, we have this built-in function in Python for getting the length of strings. What is a function? A function is basically a reusable piece of code that carries out a task. As a metaphor, think of the remote control of your TV. On this remote control, you have buttons for different functions like turn on, turn off, change the channel and so on. These are the built-in functions in your TV. In Python and many other programming languages, we have the exact same concept. So we have functions that are built into the language on the platform. You can reuse these functions to perform various tasks. So here we can use the built-in length function to get the length of a string, which means the number of characters in that string. Now, whenever you want to use a function, you should use parentheses. Now we say we're calling this function, which basically means we're using this function. Now, some functions take additional data, which we refer to as arguments. These arguments are inputs for this function. So this length function takes an input and argument. Here we pass our course variable and this will return the number of characters in this string. So let's print that and see what we get. Run the program. We get 18 because we have 18 characters here. Let's look at another example. If you want to get access to a specific character in this string, you use the square bracket notation. So here we add course, square brackets to get the first character. You use the index zero. So in Python, like many other languages, strings are zero index, which means the index of the first character or the first element is zero. So now when we print this, we'll get P. Okay. Now you can also use a negative index, like minus one. What does that mean? Well, if zero represents the first character here, what do you think negative one represents? That takes us back to the end of the string. So that returns the first character from the end of the string. Let's run this program. You will see we'll get G. There you go. Using a similar syntax, you can slice strings. Let me show you. So I'm going to duplicate this line and remove negative one. Now let's say we want to extract the first three characters in this string. So here we need two indexes. The start index, colon, the end index. So this will return a new string that contains the first three characters in this course variable. That will be PY and T. So the index of these characters are zero, one and two. So that means the character at the end index is not included. Okay. Let's run the program and make sure we get the right result. There you go. PYT. Now what if we don't include the end index? What do you think we're going to get? It's common sense. We start from index zero and go all the way to the end of the string. So this will return a new string that is exactly the same as the original string. Let's take a look. So we get Python programming. Now what if we don't include the start index, but include the end index? What do you think we're going to get? Once again, it's common sense. So by default Python will put zero here. So it will start from the beginning of the string. So when I run this program, we should get PYT one more time. There you go. And finally, as the last example, if we don't include the start and the end index, this will return a copy of the original string. Let's look at this. So we get Python programming. Now you don't have to memorize any of these. Just remember, we use the length function to get the length of a string. We use bracket notation to get access to a specific element or a specific character. And we use this notation to a slice a string. So we have this string here, Python programming. Now let's say we want to put a double code in the middle of this string. There is a problem here. Python interpreter sees this second string as the end of the string. So the rest of the code is meaningless and invalid. How do we solve this problem? Well, there are two ways. One way is to use single quotes for our string. And then we can use a double code in the middle of the string. But what if for whatever reason, perhaps for being consistent in our code, we decided to use double quotes. How can we add another double code in the middle of this string? Well, we can prefix this with a backslash. Backslash in Python strings is a special character. We have a jargon for that called escape character. We use it to escape the character after. Let me show you what I mean. So let's print this course and run this program. What's going on here? We don't have the backslash because we use that to escape this double code and basically displayed here. So backslash is an escape character and backslash double code is an escape sequence. In Python strings, we have a few other escape sequences that you should be aware of. Let me show you. So in Python, we use a hash sign to indicate a comment. A comment is like additional note that we add to our program. It's not executed by Python interpreter. Okay. So here are the escape sequences. You have seen backslash double code. We also have backslash single code. So we can use that to add a single code here. Let's run the program. Here it is. Beautiful. We also have double backslash. So if you want to include a backslash in your strings, you should prefix it with another backslash. Let me show you. So when we run this, we get Python one backslash programming. And finally, we have backslash n, which is short for new line. So now if I add a backslash n here, see what we get. We get a new line after Python. So programming will end up on the second line. So these are the escape sequences in Python. Here we have two variables first and last. Let's say we want to print my full name on the console. So we can define another variable full, set it to first, then concatenate it with a space. And one more time concatenate it with last. Now when we print full, we get my full name on the console. Beautiful. Now this approach, I'm using concatenation to build a string is okay, but there is a better and newer approach. We can use formatted strings. So here we can set full to this string and prefix it with an f which can be lowercase or uppercase. This formatted string doesn't have a constant value like these two strings here. It's actually an expression that will be evaluated at runtime. So here we want to add our first name. We use curly braces to print the value of the first variable. After that, we add a space and then we add curly braces one more time to print the last name. So at runtime, this expression will be evaluated. What we have in between curly braces will be replaced at runtime. Now let's run this program one more time. We get the exact same result. Just be aware that you can put any valid expressions in between curly braces. So earlier you learned about the built-in LAN function. We can call LAN here to get the length of this string. Let's run this program one more time. So we get four. We can also replace last with an expression like this two plus two. Let's run this program we get four and four. So when using formatted strings, you can put any valid expressions in between curly braces. In this lecture, we're going to look at a few useful functions available to work with strings. So earlier you learned about this built-in LAN function. This function is general purpose, so it's not limited to strings. Later, I will show you how to use this function with other kind of objects. But in Python, we have quite a few functions that are specific to strings. Let me show you. So here if we type course dot see all these are functions available on strings. Now in precise terms, we refer to these functions as methods. This is a term in object-oriented programming that you will learn about later in the course. For now, what I want you to take away is that everything in Python is an object and objects have functions we call methods that we can access using the dot notation. So here course is an object. We use the dot notation to access its functions or more accurately methods. Let's take a look at a few of these methods. We have upper to convert a string to uppercase. Now let's print this and run the program. Here is what we get. Beautiful. Now note that the methods that you call here return a new string. So the original string is not affected. Let me show you. So print course, run the program one more time. Look, this is our original string, right? So course dot upper returns a new string, a new value. We can store it in a variable like course on the line capital like this. Now to keep this demo simple and consistent, I'm going to revert this back and use a print statement. We also have the lower method to convert a string to lowercase. We also have title, which will capitalize the first letter of every word. So if our string was like this, when we call the title method, we get Python programming as you see here. Okay. Another useful method is strip and we use it to trim any white space at the beginning or end of a string. This is particularly useful when we receive input from the user. Let me show you. So let's imagine the user entered a couple of white spaces at the beginning of the string. When we call course dot strip, those white spaces will be removed. Take a look. So note that in the first three examples, we have those white spaces, but in the last one, it is removed. So a strip removed the white space from both the beginning and end of a string. We also have L strip, which is short for left strip and R strip, which is short for right strip. So it will remove the white space from the end of a string. If you want to get the index of a character or a sequence of characters in your string, you should use the find method. And let me show you. So course that find. So as an argument here, we pass another string. We can pass a character or a series of characters. Let's find the index of pro. Run the program. So the index of pro is nine. So if you start from zero here, all the way to nine, this is the index of pro. Okay. Now, as I told you before, Python is a case sensitive language. So if I pass a capital P here, obviously, we don't have these exact characters in our string. So let's see what we get. We get negative one. That means this string was not found in the original string. Another useful method is replace. So we call replace. With this, we can replace a character or a sequence of characters with something else. So let's say we want to replace all lowercase P's with J. With this, we get jython jurogramming. Whatever that means. And finally, if you want to check for the existence of a character or a sequence of characters in your string, you can use the in operator. Let me show you. So print, rewrite an expression like this pro in course. So this is an expression, as I told you before, an expression is a piece of code that produces a value. So this expression checks to see if we have pro in course. The difference between this expression and calling the fine method is that the fine method returns the index of these characters in our string. But as this expression returns a Boolean. So it's a true or false. Let me show you. So run the program. We get the Boolean true. And finally, we have the not operator. And we use that to see if our string does not contain a character or a sequence of characters. So let's change this to Swift, not in course. When this expression is evaluated, what do you think we're going to get? Well, we don't have Swift in this string. So not in will return true. Let's take a look. There you go. So these are the useful string methods. Next, we'll look at numbers. In Python, we have three types of numbers. Two of these you have already seen before. They are integers and floats. We also have complex numbers. So complex numbers in math are in the form A plus B i, where i is the imaginary number. If you're not familiar with this concept, don't worry. This is something that I use a lot in mathematics and electrical engineering. If you want to use Python to build web applications, you're never going to use complex numbers. But let me quickly show you the syntax for representing complex numbers. Instead of i, we use j. So here is an example. One plus two j. So x now is a complex number. And by the way, as I told you before, this is just a comment or an additional note in our program. When we run this program, anything after this hash sign will be ignored. So these are the three types of numbers we have in Python. For all these types of numbers, we have the standard arithmetic operations that we have in math. Let me show you so we have addition, subtraction, multiplication, division. But we actually have two different types of divisions. Let me show you. First, let's run this program. So with this division operator, which is a slash, we get a floating point number. If you want an integer, you use double slashes. Let me show you. So double slash, run the program, we get three. Okay. We also have modules, which is the remainder of a division. And finally, exponent, which is left to the power of right. So 10 to the power of three will be 1000. These are the standard arithmetic operators. Now for all these operators, we have a special operator called augmented assignment operator. Let me show you. So let's imagine we have x set to 10. We want to increment x by let's say three. We can write an expression like this x equals x plus three. Or we can use an augmented assignment operator. That is a little bit shorter. So we write x plus equal three. These two statements are exactly the same. Now here I'm using addition as an example. You can use any of these operators here. Next, I'm going to show you some useful functions to work with numbers. In this lecture, we're going to look at a few useful functions to work with numbers. So we have this built-in function round for rounding a number. So if you pass 2.9 here and print the result, we'll get three. We have another useful built-in function called aps, which returns the absolute value of a number. So if you pass negative 2.9 here, we'll get positive 2.9. That technically we have only a handful of built-in functions to work with numbers. If you want to write a program that involves complex mathematical calculations, you need to use the math module. And module is like a separate file with some Python code. So in Python, we have this math module, which includes lots of mathematical functions for working with numbers. But we need to import this module so we can use it. On the top, we type import math. Now math in this program is an object so we can use the dot notation to see all the functions or more accurately all the methods available in this object. As an example, we have math.seal for getting the ceiling of a number. So if you pass 2.2 here and run this program, we get three. Now in this math module, we have lots of functions. Let me show you how to find the complete list. Here on Google, search for Python 3, make sure to add the version number, math module. On this page, you can see all the functions in the math module. So in this lecture, we looked at math.seal. We also have math.copy sign, fabs, and so on. As an exercise, I encourage you to play with a couple of functions in this module. All right, now let's take a look at another useful built-in function in Python. We use the input function to get input from the user. As an argument we pass a string, this will be a label that will be displayed in the terminal. You will see that in a second. So let's add x colon. Now this function returns a string. So we can store it in this variable. Now let's imagine that why should be x plus one? Save the changes. Now don't run this program using the code runner extension because code runner by default runs your program in the output window, which is read only. So you won't be able to enter a value. So open up the terminal using control and backspace. Once again, if you're on Windows type Python, if you're on Mac or Linux, type Python 3, and then app.py. So here's our label. Let's enter a value like one. We got an error. Type error. What is going on here? Well, when we receive input from the user, this input always comes as a string. So this expression at runtime will look like this. String one plus one. Note that the number one is different from string one because these are two different types. Now when Python sees this expression, it doesn't know what to do. Because two objects can be concatenated if they are of the same type. So here we need to convert this string one to a number. In Python, we have a few built-in functions for type conversion. We have int for converting a number to an integer. We have float, we have bull, and stir or string. Now in this case, we don't need to convert X to a string because X is already a string. If you don't believe me, let me show you. So I'm going to comment out these few lines. Now, let's print type of X. So type is another built-in function. We pass an object as an argument, and it returns its type. Also, I'm going to comment out this line because that's the bad boy. We don't want to execute this. Save the changes. Back into terminal. Let's run this program one more time. Enter one. Look. This is what the type function returns. Now don't worry about the class. We'll talk about classes later in the course. So the type of X is a stir or a string. So let's delete this line. To fix this problem, we need to convert X to an integer. And then we can print both X and Y using a formatted string. Remember, so we add an F, quotes, now here we add a label like X, then we'll add a field. So here we want to print the value of X variable. After that, we add some more text. And finally, we want to print the value of Y. Let's run this program one more time. So here in the terminal, let's enter one. And here is the result. X is one and Y is two. Beautiful. Now all these built-in functions are self-explanatory. The only tricky one is bull. Because in Python, we have this concept of truthy and falsy values. These are values that are not exactly a Boolean true or false, but they can be interpreted as a Boolean true or false. So here are the falsy values in Python. M2 strings are considered falsy. So they're interpreted as a Boolean false. Number zero is also falsy. We have an object called non, which represents the absence of a value. We'll look at this later in the course. So whenever we use these values in a Boolean context, we'll get false. Anything else will be true. Let me show you a few examples. So in this interactive shell in Python, let's convert number zero to bull. That's falsy. So we get false. What about Boolean? We get true. If we pass a negative number, we'll also get true. If we pass a number larger than one, like five, we still get true. So we only get false when we try to convert zero to a Boolean. Now with strings, I told you that an M2 string is falsy. So here we'll get false. Anything else is true. So even if I have a string that is false, we'll get true. Because this is not an M2 string. It's a string with a few characters. That's why it's evaluated as true. All right, once again, it's time for another quiz. Let's see if you have been really paying attention to this tutorial. So here is the first question. What are the built-in primitive types in Python? We have strings, numbers, and Boolean. Numbers can be integers, floats, or complex numbers. Here's the second question. We have this variable fruit set to apple. What do you think we will see on the terminal when we print fruit of one? Well, using square brackets, we can access individual characters. The index of the first character is zero. So this expression returns the second character, which is P. What if we add a colon and negative one here? Well, using the syntax we can slice a string, our start index is one, and our end index is negative one, which refers to the first character from the end of the string. Now when slicing a string, the character at the end index or negative one is not included. So with this expression, we'll get all the characters starting from the second character, which is P, all the way until we get to E. So the result of this expression is PPL. Here's another question. What is the result of this expression? Well, this is what we call the modulus operator, and it returns the remainder of a division, which is in this case one. And finally, the last question. What do you think we will see when we print bull of false? Well, earlier I told you about falsy values in Python. So number zero and empty string and the non-object, these are all falsy values. Anything that is not falsy is considered trussy. Here we have a string that has five characters. It doesn't matter what those characters are. This is not an empty string. So it's not falsy, it's trussy. So when we convert it using the bull function, we'll get the Boolean true. And this brings us to the end of this section. In the next section, you're going to learn the fundamentals of computer programming. I hope you have enjoyed this section. And thank you for watching. We're going to start this section by exploring comparison operators. We use comparison operators to compare values. Here are a few examples. So 10 is greater than 3. We get true. So what we have here is a Boolean expression. Because when this expression is evaluated, we'll get a Boolean value that is true or false. Here is another example. 10 is greater than or equal to 3. Once again, we get true. We also have less than. So 10 is less than 20. We have less than or equal to. Here is the equality operator. So 10 is equal to 10. What about this expression? What do you think we're going to get? We get false. Because these values have different types and they're stored differently in the computer's memory. And finally, we have the not equal operator. So now with this expression, we should get true. Beautiful. We can also use these comparison operators with strings. Let me show you. So we can check to see if bag is greater than apple. We get true. Because when we sort these two words, bag comes after. So it's considered greater. Now what about this one? Bag equals capital bag. We get false. Here is the reason. Every character you see here has a numeric representation in programming. Let me show you. So we have this built-in function called ORD. Don't worry about memorizing this because you're probably never going to use this in the future. But let me show you the numeric representation of the letter B. So that is 98. In contrast, capital B is represented as 66. That is the reason these two strings are not equal. So these are the comparison operators and Python. Next, we'll look at conditional statements. In almost every program, there are times you need to make decisions. And that's when you use an if statement. Here is an example. Let's say we have a variable called temperature, we studied to 35. Now if temperature is greater than 30, perhaps we want to display a message to the user. So we use an if statement. If after if we add a condition, which is basically a Boolean expression, an expression that produces a Boolean value. So if temperature is greater than 30, here we have a Boolean expression. If this expression evaluates to true, the following statements will be executed. Let me show you. Now here's the important part that a lot of beginners miss. When you use an if statement, you should always terminate your statement with a colon. Now let's see what happens when I press enter. Our cursor is indented. So here we have two white spaces. This is very important because using these indentations, Python interpreter will know what statements should be executed if this condition is true. Here we want to print a message like it's warm. We can print another message as well, drink water. So we can have as many statements as we want here, as long as they are indented, they belong to this if block. Now when we finish here, we should remove indentation to indicate the end of this if block. So here we can add a print statement with a message like done. This statement will always be executed whether this condition is true or not. Now note that when I save the changes, this indentation you see here is going to be doubled up. Take a look, save, there you go. So when we save the changes, auto pep8 reformats our code and uses four white spaces for indentation. So 1, 2, 3, 4. It uses four white spaces because that's what pep8 recommends. All right, now let's run this program. So because temperature is greater than 13, we see the first two messages and we see the done message regardless. So if I change the temperature to let's say 15 and run the program one more time, look, this done message is executed, whether our condition is true or not. So pay great attention to these indentations. That's one of the issues I see in beginner's code. Let's say they want both these print statements to be executed if the condition is true. Accidentally, they remove the indentation on the fourth line. And that's why their program doesn't work as they expect. So be careful about this. Now, what if we want to have multiple conditions? We use an LIF statement. So L if that is short for L's if here we can add another condition, another expression. So temperature is greater than 20. Once again, colon enter. Now by default here, VS code is using two white spaces. So don't worry about this as soon as you save the changes, those two white spaces will be converted to four white spaces. So let's print a different message. It's nice. Save the changes. Now look, all these lines are indented consistently. You can have as many LIF statements as you want. And optionally, you can also have an L statement. So if none of the previous conditions are true, then what you have in the else block will be executed. Once again, we add the colon, indentation, print. Here we can add a message like it's called. Save the changes. In this case, temperature is 15. So none of these two conditions will be true and we will see it's called. Let's run the program. There you go. In this lecture, I'm going to show you a technique for writing cleaner code. So let's say we're building an application for university. And we want to check to see if the person who's applying for this university program is eligible or not. So we start by defining a variable called age, set it to 22. Now, if age is greater than or equal to 18, colon, print, eligible, remove the indentation, else, colon, print, not eligible. Let's run the program. Make sure it works. Beautiful. Now, there is nothing wrong in this piece of code, but I want to show you a cleaner way to achieve the same result. Instead of having a print statement here, we can define a variable like message and set it to this string. That is the first step. So message equals this string. And then we will print this message. Now, when you have an if L statement with this structure, where you're basically assigning a value to a variable, you can rewrite this in a simpler way. So this is how it works. All we want to do over these few lines is to assign a value to this message variable. So we start with message. We set it to eligible if age is greater than or equal to 18, else, we set it to not eligible. This statement is almost like plain English. So what we have on line seven is exactly equivalent to these four lines of code. Delete, save the changes, run the program. You can see this person is eligible. If I change the age to 12 and run the program, we get not eligible. So what we have here is called turnery operator. In Python, we have three logical operators and we use these operators to model more complex conditions. So these operators are and or and not. Let's see a real word example of using this operators. So imagine we're building an application for processing loans. So we need two variables. High income, we can set this to true and good underlying credit. We set it to true. Now here's the condition we want to implement. If the applicant has high income and good credit score, then they are eligible for the loan. So if high income and good credit, we add the colon and print eligible. Now note that here I have not compared the value of this variable with true. That is one of the issues I see in a lot of beginners code. This is redundant and unprofessional because high income is a Boolean. So it's either true or false. We don't need to compare true with true. So if this condition is true and this second condition is true, then we will print eligible in the terminal. So save the changes and run the program. Obviously this person is eligible. However, if one of these conditions is false, we will not see eligible in the terminal. So let's add an L statement here and print not eligible. Run the program. We see not eligible. So this is how the AND operator works. With AND operator, if both conditions are true, the result will be true. In contrast with the OR operator, as long as at least one of the conditions is true, the result will be true. So if I replace AND with OR here, we should see eligible and terminal. Let's run it one more time. There you go. So these are the AND and OR operators. Now let's take a look at an example of the NOT operator. So I'm going to define another variable, student, set it to true. Temporarily, I'm going to remove this expression and simplify it. We'll come back to this later. So let's say if the person is eligible, if they are not a student, the NOT operator basically inverses the value of a Boolean. So in this case, student is true. When we apply the NOT operator, the result will be false. So in this case, our condition will be false and that's why this print statement will not be executed. Let me show you. So save, run the program, they are not eligible. If student was false, when we apply the NOT operator will get true, so our condition will be true and we'll see it eligible. Let's run it one more time. There you go. With these operators, we can model even more complex conditions. Here is an example. A person can be eligible if they have either high income or good credit and they should not be a student. Let me show you how to implement this condition. So if high income or good credit, we won't at least one of these conditions to be true. So we put these in parentheses. We want to separate these from the other condition, which is NOT a student. Now, the result of this should be true, which means at least one of these conditions should be true. After that, we'll add and NOT student. And finally, call. So with these operators, you can model all kinds of real word scenarios. So here is the example from the last lecture. A person is eligible for a loan, if they have high income and good credit and they are NOT a student. Now, one thing you need to know about these Boolean operators is that they are short circuit. What do I mean by that? Well, when Python interpreter wants to evaluate this expression, it starts from the first argument. If this is true, it continues the evaluation to see if the second argument is also true. So it continues the evaluation all the way to the end of this expression. However, as soon as one of these arguments is false, the evaluation stops. Let me show you what I mean. So if I change high income to false, when Python interpreter sees this expression, it starts here, it knows that high income is false. So it doesn't matter what comes after the result of this entire expression will always be false, because at least one of the arguments or one of the operands is false. This is what we call short circuiting, just like the short circuit concept we have in electronics. So the evaluation stops, as soon as one of these arguments evaluates to false. We have the same concept with the or operator. So if I change these and operators to or, let's see what happens. With the or operator, we know that at least one of the arguments should be true. So the evaluation stops as soon as we find an argument that evaluates to true. In this case, when Python interpreter evaluates this expression, it sees that high income is false, so it continues the evaluation, hoping that the next argument will be true. Here, good credit is true. So evaluation stops and the result of this entire expression will be true. So in Python, logical operators are short circuit. And this lecture, I'm going to show you how to chain comparison operators. This is a very powerful technique for writing clean code. Here is an example. Let's say we want to implement a rule that says age should be between 18 and 65. Here's how we can implement it. So we define a variable like age set it to 22. Now, if age is greater than or equal to 18 and age is less than 65, then we print eligible. Now, here's a question for you. How do we write this rule in math? We can write it like this. Well, more accurately, we should have an equal sign here. So age should be between 18 and 65. This is how we write this rule in math. Now, I've got some good news for you. We can write the exact same expression in Python. So I'm going to move this up, put an if statement here, line four and line three are exactly equivalent. But as you can see, line four is cleaner and easier to read. So let's get rid of line three. This is what we call chaining comparison operators. All right. Here is a little quiz for you. I want you to pause the video and think about this quiz for 10 to 20 seconds. What do you think we'll see on the terminal when we run this program? So pause the video, figure out the answer when you're ready, come back, continue watching. All right. Let's see what happens when we run this program. First, we get this if statement. In this case, we're comparing two different objects for equality. And these objects have different types. We have a number compared with a string. So number 10 and string 10 are not equal. That is why A will not be printed on the terminal. So the control moves to the L if part. Here we have two Boolean expressions. Here's the first one. Here's the second one. And they are combined using the logical end. So if both these expressions are evaluated to true, then this entire expression will be true and we will see beyond the terminal. Let's see if both these expressions are evaluated to true. Here's the first part. Back is greater than apple. That is true because when we sort these words, bag comes after apple. But look at the second part. This expression is evaluated to false because bag is not greater than cat. So when we apply the logical end between true and false, the result will be false. That is why this statement will not be executed. So to control moves to the else part. And when we run this program, the letter C will be printed on the terminal. There are times that we may want to repeat a task a number of times. For example, let's say we send a message to a user. If the message cannot be delivered, perhaps we want to retry three times. Now for simplicity, let's imagine this print statement is equivalent to sending a message. In a real word program, to send a message to a user, we have to write 5 to 10 lines of code. Now, if you want to retry three times, we don't want to repeat all that code. That is ugly. That's when we use a loop. We use loops to create repetition. So here is how it works. We start with four, number, in. We have a built-in function called range. Now how many times we want to repeat this task? Let's say three times. So we call range and pass three as an argument. Now, similar to our if statements, we need to terminate this line with a colon. Enter, we get indentation. So in this block, we can write all the statements that should be repeated three times. Let's do a print, a message like attempt. Save the changes, run the program. So we have attempt, printed three times. Beautiful. Now what is this number? Let's take a look. It's a variable of type integer. So let's pass it as the second argument to the print function, number, run the program. This is what we get. Zero, one, two. So here we have a four loop. This four loop is executed three times. In each iteration, number will have a different value. Initially, it will be zero. In the second iteration, it will be one. And finally, in the last iteration, it will be two. Now here we can do something fun. We can add one to this, run the program. And now the messages that the print are kind of more meaningful or more user friendly, like attempting number one, attempting number two, and so on. We can take this to the next level. So we can pass another argument. Here, I'm going to add an expression, one more time, number plus one. So we'll get one, two, three. Now I want to put this expression in parentheses. So let's select this, put it in parentheses, and then multiply it by a dot. So here we have a string that is multiplied by a number. The result will be that string repeated that number of times. Let's take a look. So run the program. See, that's pretty cool, isn't it? Now let me show you one more thing before we finish this lecture. As you saw, this range function generates numbers, starting from zero all the way up to this number here, but it doesn't include this number. Here we can pass another argument, say start from one, and finish before four. With this change, we don't need to add one to number every time. Because in the first iteration, this number variable will be set to one. So we can simplify our code and make it cleaner. Let's run it one more time. We get the exact same result. We can also pass a third argument as a step. So I'm going to change the second argument to 10 and pass to as a step. Look at the result. These are the numbers we get, one, three, five, and so on. So pretty useful. You're going to use this function a lot in real work applications. Continuing with the example from the last lecture, let's imagine the scenario where after the first attempt, we can successfully send the message. In that case, we want to jump out of this loop. We don't want to repeat this task of sending a message three times. Let me show you how to implement this. So in this demo, I'm going to simulate the scenario where we can successfully send a message. So we define a variable successful and set it to true. Now here, after this print statement will have an if statement, if successful, colon, then perhaps we can print successful. Now here, we want to jump out of this loop. For that, we use the break statement. Let's run this program and see what happens. So there you go. After the first attempt, we are successful and there are no more attempts. So once again, I want you to pay great attention to the indentation here because that's one of the common issues amongst beginners. So here's our for loop. These two lines are indented with four spaces and they belong to our for loop. In every iteration, these two lines will be executed. Now, when we get to line four, if this condition is true, then these two lines will be executed because both these lines are indented below this if statement. Now let's take this program to the next level. What if we attempt three times and we still cannot send an email? Perhaps we want to display a different message to the user. We say, hey, we tried three times but it didn't work. So I'm going to change successful to false. Now at the end, here we can add an L statement. This is what we call a for L statement. What we put under this L statement will only be executed if this loop completes without an early termination. So if we never break out of this loop, then the L statement will be executed. So here we can print a message like attempted three times and failed. So run the program. See what we get? Three attempts followed by this message attempted three times and failed. In contrast, if we change successful to true, because we terminate this loop using this break statement, what we have in the L's block will not be executed. Take a look. Run the program. We have one attempt successful done. In programming, we have this concept called nested loops. So we can put one loop inside of another loop and with this we can get some interesting results. Let me show you. So I'm going to start with this loop for X in range five. Colon. Now inside of this loop, I'm going to add another loop. So for Y in range three, colon. And then in our second loop, I'm going to add a print statement. Here we can use four mattered strings to display coordinates. Remember four mattered strings. So we have F followed by quotes. Now here we add parentheses for our coordinates. First we want to display X and then comma followed by Y. Let's run this program and see what happens. There you go. Pretty cool, isn't it? So we get zero and zero zero and one zero and two. Then we get one and zero one and one one and two and so on. Now let me explain how exactly Python interpreter executes this code. So here we have two loops. This is what we call the outer loop and this is the inner loop. So the execution of our program starts here. In the first iteration of this loop, X is zero. Now we get to this statement, which is a child of this four statement because it's indented four times. This statement itself is a loop. So what we have inside of this loop will be executed three times. In the first iteration, X is zero because we are still in the first iteration of the outer loop. And Y is also zero because we are in the first iteration of the inner loop. That is why we get zero and zero. Now we go to the second iteration of this inner loop. In this iteration, Y will be one whereas X is still zero. That is why we get zero and one. And similar to in the third iteration of our inner loop will get zero and two in the terminal. Now we're done with the execution of the inner loop. So the control moves back to our outer loop. Here will be in the second iteration. So X will be one and then we start here again. So we have to execute this inner loop three times. In the first iteration, Y will be zero and X is one. So here we have one and zero. Then we'll get one and one and one and two. You got the point. So this is all about nested loops. So you have learned how to use four loops to repeat one or more statements in your programs. Now let's dive deeper and see what this range function returns. So earlier you learn about the built-in type function. With this function, we can get the type of an object. So if I pass five here and run this program, this is what we get. So the type of this number or this object is int or integer. Now let's look at the type of the value that we get from the range function. So as an argument, we pass range of a number. Let's run this program. So this range function returns an object of type range. So in Python, we have primitive types like numbers, strings, and boolean. But we also have complex types. Range is an example of one of those complex types. Throughout this course, you're going to learn about a lot of other complex types. Now what is interesting about this range object is that it's iterable, which means we can iterate over it or use it in a for loop. That is why we can write code like this. So this range function returns a range object, which is iterable, which means we can iterate over it. In each iteration, X will have a different value. Now, range objects are not the only iterable objects in Python. Strings are also iterable. So here we can add a string like Python. Now in each iteration, X will hold one character in this string. Let me show you some print, X, and I'm going to delete these two lines here. Let's run this program. So in each iteration, we'll get one character and print it. We have another complex type called list, which we use to store a list of objects. So we add square brackets. This indicates a list. Now we can add a list of numbers or a list of strings like a list of names. You will learn about lists later in the course. So let's run this one more time. As we can see, we can iterate over lists. In each iteration, we'll get one object in this list. Now later in the course, I will show you how to create your own custom objects that are iterable. For example, you will learn how to write code like this for item in shopping, cart, print item. So shopping cart is going to be a custom object that you will create. It's not going to be an integer or a string or Boolean. It's a custom object. It has a different structure. And we'll make it iterable. So we can use it in a for loop. And in each iteration, we can get one item in the shopping cart and print it on a terminal. So you have learned that we use for loops to iterate over iterable objects. In Python, we have another kind of loop that is a while loop. And we use that to repeat something as long as a condition is true. Here is an example. So let's define a variable number and set it to 100. Now we use while. And here we add a condition. As long as number is greater than zero, we add a colon. Once again, we have indentation. So we can repeat one or more statements. We can print this number. And then we can divide it by half. So number equals number. Use the integer division to divide it by two. Or we can use the augmented assignment operator to shorten this code like this. Now let's run this program. So here is what we get. Initially, our number is 100. We divide it by half. We get 50, then 25 and so on. So as you can see, in this example, we are not iterating over an iterable, like a range object or a string or a list. We are evaluating a condition and repeating a task. Let me show you a real word example of a while loop. In this interactive shell, Python is waiting for an input. We can type something like two plus two. It will evaluate it and ask for the next input. We can add another expression like 10 is greater than two. So these steps will continue until we press control D. So behind the scene, we have a while loop that continuous execution until we press control D. That is the condition that causes the while loop to terminate. Let me show you how to build something like this in Python. So let's define a variable. Command and set it to an empty string. Now here we need a while loop. We want this while loop to execute as long as command does not equal to quit. So command does not equal to quit. Calling in this loop, we want to continuously get input from the user. So we use the built-in input function. We add a label like this, get the result and store it and the command variable. Now at this point, Python interactive shell will evaluate this command. We are not going to do that in this lecture because that's way too complex. For simplicity, we can just echo back what the user entered. So print, echo, and as the second argument, we pass this command. So this is our while loop. It will execute until we type quit. Now as I told you before, don't run this program using the code runner extension because by default, it will run your program in the output window, which is read only. So open up the terminal using control and back tick and run Python or Python 3, add that pie. So here's our command prompt. Let's type 2 plus 2. It echoes back. Let's type 3 times 2. There you go. If it type quit, our program terminates. Now let's try it one more time. What if we type quit in upper case? The program doesn't terminate because as you learned before, lowercase and uppercase characters have different numeric representations. So quit in lowercase is different from quit in uppercase. Now to solve this problem, an amateur programmer may do something like this. And command does not equal to capital quit. So while command does not equal quit in lowercase and quit in uppercase, continue getting input from the user. Let's run this program in terminal and see what happens. So one more time, Python after pie. We type quit. Beautiful. It works. We type quit in uppercase. That would work too. But what if I type quit with an uppercase queue and lowercase UIT? Our program doesn't terminate. So this is a poor way of checking for the quit command. What is a better way? Let me show you. So we don't need this and operator here. Instead, because command is a string, we can call the lower method. So whatever the user types in, first will convert it to lowercase and then compare it with quit in lowercase. With this change, it doesn't matter how the user types the word quit will always terminate the program. Now the last thing I want to discuss in this section is the concept of infinite loops. An infinite loop is a loop that runs forever. So if I change this condition to true, because true is always true, this while loop will run forever. So to jump out of this, we need a break statement. So after we get the input from the user, we can get the command converted to lowercase and see if it equals to quit. If that's the case, we want to break. Now with this change, we no longer need to initialize command to an empty string. Previously, we needed this because we had a wild statement like this while command does not equal quit. So we had to define this command variable and that's why we have set it to an empty string. Without this line, when Python interpreter tries to execute this code, it doesn't know what command is. So now that we have an infinite loop, we no longer need to define command and set it to an empty string. So in terms of functionality, this program is exactly the same as the program we wrote in the last lecture. Just be aware of these infinite loops because they run forever. You should always have a way to jump out of them. Otherwise, your program will run forever. And this can sometimes cause issues because if you're executing operations that consume memory, at some point, your program may run out of memory and crash. All right, time for an exercise. I want you to write a program to display the even numbers between 1 to 10. So when you run this program, you should see 2, 4, 6 and 8. And after these, I want you to print this message. We have four even numbers. Now here's a quick hint before you get started. You should call the range function with 1 and 10. Do not use the third argument, which is called step. So basically, I want you to iterate over all the numbers between 1 to 10. Check if each number is an even number and then printed on the terminal. So pause the video, spend two minutes on this exercise when you're done. Come back, continue watching. So it started with a for loop for number in range, 1 to 10, colon. We check to see if the remainder of division of this number by 2 equals 0. So if number module is 2 equals 0, then reprint this number. Now let's run this program. So we get 2, 4, 6, 8. Beautiful. Now to count the even numbers, we need a separate variable. So let's call that count. Initially, we set it to 0. Now in this if block, every time we find an even number, we need to increment count. So we set count plus equals 1. And finally, after our for loop, we can print a formatted string. We have count even numbers. Let's run the program. And here's the result. So that brings us to the end of this section. In the next section, you're going to learn how to create your own functions. I hope you enjoyed this section and thank you for watching. So far you have learned how to use some of the built-in functions in Python, such as print, round, and so on. In this section, you're going to learn how to write your own functions. Now you might ask, but why do we even need to write our own functions? Well, when you build a real program, that program is going to consist hundreds or thousands of lines of code. You shouldn't write all that code in one file like we have done so far. You should break that code into smaller, more maintainable, and potentially more reusable chunks. You're referred to these chunks as functions. So let me show you how to create your own custom functions. We start with a dev keyword, which is short for define. Next, we need to give our function a name. So let's call this greet. All the best practices you learn about naming your variables also apply to naming your functions. So make sure your function names are meaningful, descriptive, use lowercase letters to name your functions, and an underscore to separate multiple words. Now after the name, we need to add parentheses. You will see why shortly, and then we'll add a colon. Now what is going to happen? You know it. We're going to get indentation, which means the following statements will belong to this function. So here I'm going to add two statements. Hi there, and welcome aboard. Both designs belong to this function because they're indented. Now we're done with this function. We need to call it. So we remove the indentation, and we add two line breaks after this function. This is what pep8 recommends to keep our code clean and maintainable. Now if you forget to add two line breaks, don't worry. As soon as you save the changes, auto pep8 will automatically add these line breaks for you. Let me show you. So I'm going to remove these line breaks and call this function great with parentheses, just like how we call the built-in functions. Now save the changes, there you go. So we get two line breaks after our function. Now let's run this program. So we get these two messages on the terminal. Now here is a question for you. What is the difference between the grid and print functions? The difference is that this print function takes an input, whereas our grid function doesn't take any inputs. So let me show you how to pass inputs like first name and last name to this function. When defining a function, in between parentheses, we list our parameters. So here we add two parameters, like first underline name and last underline name. Now when calling this function, we need to supply two values for those parameters. We refer to them as arguments. So, Mosh, Hamidani, these are the arguments to the grid function. That's one of the terms that a lot of developers out there don't know. They don't know the difference between parameters and arguments. A parameter is the input that you define for your function, whereas an argument is the actual value for a given parameter. Okay, now let's change line two and instead of staying high there, we can greet a person by their full name. So we can convert this to a formatted string and pass two fields here, first name as well as last name. Save the changes, run the program and this is what we get in terminal. Now this function is more useful. We can reuse it and call it with different arguments. So let's greet John Smith as well, run the program. So we get high Mosh Hamidani and high John Smith. Now note that by default all the parameters that you define for a function are required. So here our grid function takes two parameters. If I exclude one of these arguments and save the changes, we can see we have this red underline. So Pylant is complaining and saying there is no value for argument last name. Also, if we run the program, we get this type error, greet missing one required positional argument. So let's put this back. Now later I will show you how to define optional parameters. So this is the simplified version of this grid function we created earlier. Now in programming we have two types of functions. Functions that perform a task and functions that calculate and return a value. Here are some examples. Both the print and grid functions are examples of type one. The performing a task which is printing something on the terminal. In contrast, the brown function is an example of a function that calculates and returns a value. So the functions that you create fall into these two categories. Now let me show you how to rewrite this grid function but in the second form. So instead of printing this string on the terminal, we simply return it. Let me show you. So I'm going to delete all this code, define a new function, but call it get underlying greeting. We add the name parameter and simply return this form at a string high name. That's all we have to do. So we use the return statement to return a value from this function. Now we can call this function get underlying greeting pass a name like marsh because it returns a value. We can store that value and separate variable like message. Now you would be curious which form of this greeting functions is better. Well, with this first implementation, we are locked to printing something in the terminal. In the future, if you want to write that message in a file or send it in an email, we have to create another function. So we cannot reuse this grid function in other scenarios. In contrast, this second form is not tied to printing something on the terminal. It simply returns a value. Now we get this value and we can do whatever we want with it. We can print it on the terminal or we can use the built-in open function to write this message to a file. So we can create a file like content.txt, open it for writing. This returns a file object and then we can call file.write message. Now don't worry about these two lines. Later in the course, I'm going to talk about working with files. But what I want you to take away here is that we have this message variable and we can do whatever we want with it. We can print it on the terminal, write it to a file, send it in an email and so on. And one more thing before we finish this lecture. So here is our grid function and as you can see, we're simply printing a string. Now, if we call grid, give it a name, run the program, we get this message, highmosh. But what if we put this inside of a call to the print function? Let's see what we get. We get highmosh followed by none. What is this? None is the return value of the grid function. So in Python, all functions by default return the non-value. None is an object that represents the absence of a value. Later in the course, you're going to learn more about none. What matters now is that all functions return none by default unless you specifically return a value. So here if we return some string, none will no longer be returned. Now, I just want to clarify something. Earlier, I told you that we have two types of functions in programming functions that carry out a task or functions that calculate and return a value. So back to the code we previously had. So even though this function returns none by default, it is still classified as a function that carries out a task. Let's create another function. We call it increment. We want to use this function to increment a number by a given value. So here we simply return number plus by. Now we can call this function like this increment two and one. This returns a value so we can store it in a variable like result and then print it on the terminal. Let's run the program. We get three beautiful. Now we can simplify this code. We have used this result variable only in a single place. That is line six. So we don't really need it. So online six, we can replace result with a call to increment function. Like this. So when Python interpreter executes this code, first it will call the increment function. It will get the result and temporary storage in a variable for us. We don't see that variable and then it will pass that variable as an argument to the print function. Now, if we run this program, we get the exact same result. Beautiful. Now we can make this code more readable. If someone else looks at line five, they may not know exactly what these arguments are for. We can use a keyword argument to make this code more readable. So this one here is the value of this by parameter. We can prefix it with the name of the parameter like this. Now we can read this code almost like plain English increment two by one. So if you're calling a function with multiple arguments and it's not quite clear what these arguments are for, you can make your code more readable by using keyword arguments. So here by equals one is a keyword argument. Earlier, I told you that all the parameters that you define for a function are required by default. In this lecture, I'm going to show you how to make the by parameter optional. So let's say we don't want to explicitly pass by equals one every time we want to call this increment function. We want to use this function to increment a value by one. So we remove the second argument. Now we need to give this parameter a default value. So we set it to one. Now if we call this function and don't supply the second argument, this default value will be used. Otherwise, the value that we specify here will be used. Let me show you. So we run this program. The result is three. But if we pass the second argument here will increment two by five. So we will get seven. So you can see it's pretty easy to make a parameter optional. Just be aware that all these optional parameters should come after the required parameters. In other words, I cannot add another required parameter here. Let's call that another. I cannot add that here. If I save the changes, you can see we get a red underlying here. So all the optional parameters should come after the required parameters. Now, obviously, in this case, we don't need the second parameter. So let's delete it. There are times that you may want to create a function that takes a variable number of arguments. Here is an example. Let's define this function, multiply. That takes two parameters, x and y, and simply returns x times y. Now we can call this function like this. So far, it's so good. But what if you want to pass one or two more arguments here? That doesn't work because our multiply function takes only two parameters. To solve this problem, we need to replace these two parameters with a single parameter. We use a plural name here to indicate that this is a collection of arguments. And then we prefix it with an asterisk. This is the magical part. Let me show you what happens when you use an asterisk here. So temporarily, let's delete this line and simply print numbers. Let's see what we get here. So run the program. We can see all our arguments and they're packed in parentheses. What is this? Well, earlier, you learned about lists. I briefly mentioned that you can use square brackets to create a list of objects like two, three, four, five. Now later in the course, we have a comprehensive section about lists. So don't worry about the details of lists and how they work. But what I want you to note here is that the only difference between this list and what we have here is in the notation. So use square brackets to create lists and parentheses to create topples. Some people call it two pulls or two pulls. So a topple is similar to a list and that is a collection of objects. The difference is that we cannot modify this collection. We cannot add a new object to this topple. Once again, later in the course, we're going to have a comprehensive section about lists, topples, and other data structures. What matters now is that these topples just like lists are each variable. So we can iterate over them, which means we can use them in loops. Let me show you. So let's write for number in numbers, colon. Let's just print one number at a time. Actually, we don't need this line. So delete and run the program. So we iterate over this topple and in each iteration, we get one number and print it on the terminal. So now with a simple change, we can calculate the product of all these numbers. All we have to do is to define a variable like total. Initially, we set it to one. And then in each iteration, we get total and multiplied by the current number. Or we can rewrite this statement using an augmented assignment operator. So total times equal number line five and four are exactly identical. So I'm going to use line five because it's shorter and cleaner, delete. And finally, we'll return the total. Now, one of the issues I see often in beginners code is that they don't use this indentation properly. So they put the return statement here. And then they wonder why their function doesn't work properly. If you put the return statement here, it will be part of the for loop. So it will be executed in each iteration. In this case, after the first iteration, because of this return statement, we'll return from this multiply function. So the total will not be calculated properly. We need to put this at the same level of indentation as other statements in this function. So here we have our four statement. We loop over all the numbers, we calculate the total and then finally return it. So with this implementation, we can get the result and printed on the terminal. Let's run the program and you can see the product of these numbers is 120. So in the last lecture, you learned the syntax to pass a variable number of arguments to a function. We have a variation of this syntax with double asterisk. And that's what I'm going to show you in this lecture. So for this demo, let's rename this function to save underline user and rename the argument to user. So let's imagine we're going to use this function to save information about a user. Now in this function, let's just print this user argument. We're done with our function. Let's call it save underline user. Now, instead of passing arbitrary arguments here, we can pass arbitrary keyword arguments. Remember keyword arguments. So we have name equals value. So here we can add multiple keyword arguments like ID equals one name equals John, age equals 22 and so on. So we are passing three keyword arguments to this function. Now let's run this program. This is what we get. Look at the syntax. We have this curly braces. And in between them, we have multiple key value pairs. So key, colon value, comma, here's another key value pair. And here is the last one. This object you see here is called a dictionary. It's another complex type or a data structure in Python. And I'm going to talk about that in detail later in the course. For now, all I want you to take away is that when we use double asterisk here, we can pass multiple key value pairs or multiple keyword arguments to a function. And Python will automatically package them into a dictionary. So this user object here is a dictionary. Now using the bracket notation, we can get the value of various keys in this dictionary. So we can print user, square brackets, you pass a string. And this is the name of our key like ID. Let's run the program. We get one or we can access the value of name key. Run the program. So name is John. So this is how dictionaries work. In programming, we have a very important concept called scope, which refers to the region of the code where a variable is defined. So in this example, we have this message variable, the scope of this variable is the grid function. It only exists inside of this function. So if we go outside of this function and try to print message, see what happens. As soon as I save the changes, we get this red underline undefined variable message. And if we run our program, we get this name error name message is not defined. The same rule applies to the parameters of our functions. So if we add a name parameter here and then try to print it outside of the grid function, we get the same error. So the scope of the name and message variables are the grid function. And we refer to these variables as local variables in this function. They're local in this function, which means they don't exist anywhere else. And that means we can have another function. Let's say send email with a parameter with the same name. Here we can have a message variable. But this message variable is completely different from the message variable we have in the grid function. And of course, the same rule applies to the name parameters in these functions. They are completely separate. These local variables have a short lifetime. So when we call, let's say the grid function and pass the name, Python interpreter will allocate some memory and have the name and message variables reference those memory locations. When we finish executing the grid function, because these variables are not referenced or used anywhere else, eventually they get garbage collected, which means Python interpreter will release the memory that allocated for these variables. So these are the local variables in contrast to local variables. We have global variables. So if we move this message variable outside of the grid function, now it's a global variable, which means it's accessible anywhere in this file. So the scope of this variable is this file. We can use it anywhere in this file in any functions or outside of a function. Now for this reason, global variables stay in memory for a longer period of time until they are garbage collected and you should not use them that often. In fact, global variables are really evil. So as a best practice, create functions with parameters and local variables. Now, what if here in the grid function, we set message to let's say B. Now, let's delete this second function. We don't really need it for now. So we call the grid function. In this function, we assign a new value to the message variable. Now let's print this message and see what we get. What do you think we're going to get? Well, let's take a look. We get a, but did we change the value of message variable to B? Not really, because by default, Python interpreter treats this message variable as a local variable and the grid function, even though it has the same name as the global variable that we have online one. So these two variables are separate. I have seen some tutorials or even books teaching you bad practices. For example, they show you how to modify the value of this global message variable inside of a function. Let me show you how to do that. But remember, this is a bad practice and you should avoid it at all times. I will explain the reason in a second. So these tutorials or books teach you to use the global keyword here and reference the message variable. When Python interpreter sees this line, it will realize that in this function, we want to use the global message variable. So it will not define a local variable in this function. Now with this change, if we run our program, you can see we get B on the terminal, because in this function, we are modifying the value of the global message variable. Why is this bad? Because it is possible that you might have multiple functions that rely on the value of this global variable. If you accidentally or deliberately change the value of this global variable in one function, this might have a side effect in other functions. Those functions may not behave properly. And this way, we can create a bug in our program. So global variables have always been bad. This is not a Python thing. This is a discussion that's been going on for decades. Avoid them as much as you can. Or if there are situations that you really need to define a variable globally in a file, that's okay, but do not modify it in a function as you see here. This is a really bad practice. So that's all about local and global variables. In this lecture, I'm going to show you how to find and fix bugs in your programs. So here's the multiply function we wrote earlier. Let's add a couple of statements after this function. So print, start, and then we'll call the multiply function, give it three arguments, one, two, and three. So the result should be six. And here we print the result on the terminal. Now to create a bug in this program, I'm going to deliberately indent this return statement. So now when we run this program, instead of six, we get one. So we're going to use a technique called debugging to find and fix this bug. All right, first we need to open the debugging panel. The first time we want to use debugging in a Python project, you need to click this icon. This will generate a new file called launch the JSON. In this file, we have a bunch of debugging configuration. You'll never have to touch any of this. So don't worry about it. Close it. You can see this file is placed inside of this VS code folder. It's right here, launch the JSON. Now when we have this file, we can go to the debugging panel. And from this list, we can select a debugging configuration. Some of these configurations are useful for more complex applications. For example, we use Python Django to debug a web application built with Python. For this course, we're going to use Python current file with integrated terminal. So select this. Now to start debugging, first, we need to add a breakpoint on one of these statements. So I'm going to put the cursor on line eight and insert a breakpoint by pressing F nine. So this is a breakpoint. We can press F nine one more time to remove it. If you're on a Mac keyboard, you should press the function key, which is on the bottom left corner of your keyboard and then press F nine. So here we have a breakpoint. Now we can press F five to run the application up to this point. So F five. So this automatically opens the integrated terminal here. Don't worry about this. I'm going to close it. So you can see our program is running up to this point. This line is highlighted. Now we can execute this program line by line and see exactly what happens at runtime. So to execute one statement at a time, press F 10. Okay, we are done. Now we are online nine. However, online nine, we're calling the multiply function. If we press F 10 again, the execution stops. So we couldn't figure out why we got one as the result of multiplying these numbers. So let's start debugging one more time. We press F five. So once again, we are online eight. Let's step over this line with F 10. Now this time, we want to step into this multiply function. So we see exactly what is going on here. So instead of F 10, press F 11. Now we are online two. So if you're calling a function that you have defined, you can step into that function using F 11. Now here we are in the multiply function. On the left side, inside the variables panel, you can see all the variables that are meaningful in this function. So under locals, we have numbers. So this is our numbers argument. We can see this is set to a topple with three numbers. One, two, three. Right? Now our total variable is not in this list because it's not defined yet. The moment we step over this line with F 10, total comes to existence and you can see initially it's set to one. Now we are at the beginning of our for loop. Let's press F 10 one more time. Here we are. We're going to multiply total by number. So let's step over this line as well. Now at this point, we have a new variable called number that is our loop variable. Initially, it's set to one. Now here we are online five. If you press F 10, we can see we jump out of this function. So our loop did not execute to completion. And that is the reason our program has a bug. So to fix this, I'm going to stop the debugger with shift and F five. Now back here, let's remove the indentation, save the changes, run the program in debug mode one more time. So we press F five. Here we are. Let's step over this with F 10. Now step into this with F 11 and step over these lines with F 10 a few more times. F 10 one more time. Total is set. Now we are in the second iteration. Let's press F 10 one more time. In this iteration, you can see number is set to two. Our total is still one. So let's step over this line as well. Now total is updated to two. Here we are at the beginning of the third iteration. Let's step over this line. In this iteration, number is three. So after we execute this line, because total is currently two, when we multiply it by three, we'll get six. So F 10 one more time. Now we only have three iterations in this loop. So if we press F 10 one more time, our loop completes. Now we are ready to return total, which is currently six. So F 10, we are online nine and we're done. Now one more tip. In this demo, I put the break point on the first none of the program. You don't always have to do this. For example, here we know that our multiply function has a bug. So instead of putting the break point on line eight, we could put it on line two. So when we start the program in debug mode with F five, we immediately start in the multiply function. And one more tip before we finish this lecture. If you step into a function and you know that that function works properly, we can immediately step out of that function with shift and F 11. So you don't have to execute the entire function line by line. You can press shift and F 11 to step out of that function. All right, let's finish off this section by looking at a few very useful shortcuts for writing code fast. First, I'm going to show you the shortcuts for Windows users. And in the next lecture, we'll look at the shortcuts for Mac. So if you're a Mac user, feel free to skip this lecture. So here we are on line nine and my cursor is right at the beginning of the line. Let's say we want to move the cursor to the end of the line. Instead of pressing the right arrow to go all the way to the end, we can simply press the end key and here's the cursor. Or if you want to move the cursor to the beginning of the line, simply press the home key. There you go. Similarly, if you want to move the cursor to the beginning of the file, press control and home. Here it is or control and end to go to the end of the file. Now let's say we want to move this line up. Instead of cutting it from here and then copying it somewhere else, we can simply move it up by pressing alt and the up or down arrows. Or if you want to move these two lines up and down, simply select them, then hold alt and then up or down. Very easy. Now if you want to duplicate a line or multiple lines, simply select them. Now hold down shift alt and then press down key. You can duplicate it as many times as you want. There you go. Here's another useful shortcut. If you want to convert this line or maybe these two lines into a comment, simply hold down control and press slash. Using the same shortcut, you can remove the comment so you can toggle it. Very easy. And finally, if you want to type the name of a variable or a function like multiply, you don't have to type all characters. Here are a few ways to type this quickly. We can just type the first few characters and here in the IntelliSense, you can see that. So if you press enter, this is what we call auto completion. Here is another way. So instead of writing the first few letters, we can just pick any letters in sequence and type them. So I can type MTY or I can just type MTY or NY. There you go. Here it is. So I hope you enjoyed this shortcut and thank you for watching. All right. Now let's take a look at the shortcuts for a Mac keyboard. So here we are on line 9 and my cursor is right at the beginning of the line. If you want to move the cursor to the end of the line, instead of using the right arrow to go all the way, simply hold down the function key and press right. Here it is or you can press function and left to jump to the beginning of the line. Similarly, you can press function and up to go to the top of the file or function and down to jump to the end of the file. Pretty useful. Now let's say you want to move this line up instead of cutting it from here and then copying it somewhere else, you can simply move it up by holding down alt or option and then pressing the up arrow or down. Very easy. Or we can select these two lines, hold down the alt or option key, move it up or down. Here is another useful shortcut. We can convert these two lines into a comment by pressing command and slash and then we can remove the comment using the same shortcut. So we can toggle it. And finally, if you want to type the name of a variable or a function like multiply, you don't have to type all the letters like multiply, that is very slow. You can type the first few letters like malt and here in the IntelliSense you can see it's selected so press enter or you can pick any characters in sequence and type them like MTY here it is or we can type MPY or MTP so you can abbreviate it anyway you want. I hope you enjoyed these shortcuts and thank you for watching. One of the questions that often comes in programming interviews is the Fisbus algorithm. You might be surprised that there are a lot of developers out there with even years of experience but they don't know how to solve this simple programming problem. That's why I decided to include this in my course. So let's see how this algorithm works and then you can spend 10 to 15 minutes on this exercise on your own. So here we have a function, Fisbus that takes on input and depending on the input we give it it returns different results. Here are the rules. If the input that we give it is divisible by 3 it will return the string Fisbus. Let me show you so we run this program we get Fisbus. If the input is divisible by 5 it will return buzz. Take a look here's buzz. Now the third rule. If the input is divisible by both 3 and 5 it will return Fisbus. So let's pass 15 here we'll get Fisbus. For any other numbers it will return the same input. So if I pass 7 it's not divisible by 3 or 5 it will return 7 itself. So spend 10 to 15 minutes on this exercise you will see my solution next. All right let's see how we can solve this problem. So we get the input and check to see if input is divisible by 3 then we can set a variable like result to Fis. Now let me temporarily simplify these rules because I want to show you a really cool technique. So let's imagine if the input is divisible by 3 will return Fisbus otherwise will return buzz. So else calling we set the result to buzz and finally will return this result variable. This is one way to implement these rules but it's not the best way there is a better and cleaner way. Let me show you so instead of defining this result variable and then returning it we can simply return this string here and also here and then we can get rid of line 6. So we remove one unnecessary line of code. This was one technique. The other technique I want to show you is when you have an if statement and in your if block you have returning a value you don't really need an else clause because if this condition is evaluated to false the control moves to the else clause and all we are doing here is returning a different value. So this is the only possible outcome. So here we can remove this else clause and simply return buzz. So with this technique I removed an unnecessary indentation as well. I've made our code more linear okay. Now let's go back to our original algorithm. So if the input is divisible by 3 will return Fizz. Now we check to see if the input is divisible by 5 will return buzz. So here we don't really need an L if because if this condition is false we'll get here anyway so we can check if input is divisible by 5 will return buzz. Once again if this condition is false the control moves here. Now we check to see if the input is divisible by 3 and it is also divisible by 5 then we will return Fizz buzz. Now this expression is a little bit long. I would prefer to make it more readable by putting parentheses around the first and second parts like this. That is cleaner. Now if this condition is also false the control moves here that means our number is not divisible by 3 or 5 so we should simply return the same input. Once again we don't need an L's or another if we simply return the input. Now let's run this program and see if it's working properly or not. So we call our function with 3 and we get Fizz beautiful. Let's call it with 5 we get buzz perfect what if we call it with 15 we should get Fizz buzz however we get Fizz what is going on here the reason this happened was because when we pass 15 here line 2 is executed obviously 15 is divisible by 3 so that is why we immediately return Fizz. To solve this problem we need to move this condition which is more specific to the top. So I've selected these two lines using alt and up. I move these lines up beautiful. All right now let's run the program one more time. So we get Fizz buzz once again let's test it with 3 now we get Fizz let's test it with 5 when writing functions don't assume that your function is working make sure to test it with all different kinds of values. Let's test it with 5 we get buzz beautiful what if we pass 7 which is not divisible by 3 or 5 we get 7 beautiful. So what you see here is the simplest and most elegant implementation of the Fizz buzz algorithm and that brings us to the end of this section. In the next lecture we're going to explore data structures in Python you're going to learn about lists, topples, sets and dictionaries. I hope you enjoyed this section and thank you for watching. In this section we're going to look at the built-in data structures in Python which are extremely important when building real applications. First we're going to look at lists and then we'll look at topples, sets and dictionaries. So earlier you have seen that we can use square brackets to define a list or a sequence of objects. In between these brackets we can have objects of any type so we can have a list of strings like this and then assign it to a variable like letters. We can also have a list of numbers, Booleans or even a list of lists let me show you. So here we have a list. Each item in this list will be a list itself. So here's the first item which is a list of two items. Now let's add another item to our main or parent list. This item is also a list with two items. So now we have a matrix which is a two-dimensional list. Now let me show you some cool tricks. Let's say you want to have a list of 100 zeros. You don't want to manually create that like this. That's very ugly. Let me show you a better way. So we define a list of one item on zero and then we can multiply it by 100 and the result will be this. Let me show you. Print zeros, here it is. There you go. So using a star or an asterisk we can repeat the items in a list. Now similarly we can use a plus to concatenate multiple lists. Let me show you. So first I'm going to change this to five. Now let's define a variable combined which is our zeros list plus letters. Let's see what happens. Print, Combined, you know it. So we have five zeros followed by A, B, C. As you can see in Python every object in a list can be of a different type. So they don't have to be exactly the same type. We can combine a list of numbers with strings and Boolean's or even lists. Now let's say you want to have a list of numbers like zero one two three all the way up to 20. You don't want to type all of these by hand. There is a better way. So we have this list function. As you can see this function takes an iterable. So we can pass any iterable here and convert it to a list. Earlier you learned about the range function. This function returns a range object which is iterable which means we can iterate or loop over it. So here we can call this function and pass 20 and with this we can create a list of numbers from zero to 20. Let me show you. So let's store it in numbers and then print it on the terminal. There you go. So zero up to 20 but note that 20 itself is not included. As another example let's call the list function and pass a string. Earlier I told you that strings are also iterable. We can loop over them so we can pass them to the list function and see what we get. Let's print charts on the terminal. So you can see each character in our original string is an item in this list. So these are a few different ways to create a list in Python. Now that we have a list we can get the number of items in that list using the LAN function. So here we can print the LAN or length of charts. Let's take a look. So we have 11 items in this list. Over the next few lectures we'll look at various operations around lists. So here we have a list of four items. We can use square brackets to access individual items in this list. So let's print letters of zero. This will return the first item in this list. So when we run this program we'll get a. Now similar to strings if we pass a negative index here like negative one this will return the first item from the end of the list. So when you run this we'll get D using square brackets we can also modify items in the list. So let's change the first item to a capital A and then print the entire list. There you go. So this is the basic of accessing individual elements in the list. The earlier in the course you learned that we can use two indexes to slice a string. We have the exact same concept here. So we add square brackets, first index, colon, second index, and this will return a new list with the first three items in our original list. So if we print our original list you can see that it's not changed. Now just like strings if you don't specify the first argument zero will be assumed by default. So as we can see these two expressions produce the exact same result. Similarly if you don't include the ending index by default the lengths of the list will be used here. So this expression will return a new list with all the items in the original list. And similarly we can also exclude the start index here and with this syntax we can get a copy of our original list. There you go. Now when slicing a string we can also pass a step and this is useful in situations where you want to return every second or every third element in the original list. So now when we run this code we'll get a and c. So b will be a skip. Let me show you using a better example. So I'm going to delete everything here. Create a new list called numbers. Here we're going to use the list function and pass range of 20. Let's print our list. So we get numbers 0 to 19. Okay. Now let's see what happens when we add square brackets here with two call ends and two. This will return every other element in the original list. Take a look. So we get all the even numbers 0, 2, 4 and so on. That's pretty cool isn't it? Here is another cool thing you can do here. Let's change the step to negative 1. As you can see this will return all the items in the original list but in reverse order. So these are some useful things you can do with lists. Next we'll look at unpacking lists. There are times that you may want to get individual items in the list and assign them to different variables. Here is an example. We can define a variable like first and set it to numbers of 0. Similarly we can define second, set it to numbers of 1 and third, set it to numbers of 2. Perhaps you're going to use these variables in a few complex expressions in your code. Now there is a cleaner and more elegant way to achieve the same result and that is what we call list unpacking. So we can unpack this list into multiple variables. Let me show you how that works. So we define our variables like first, second and third and then set them to our list. What we have online too is exactly identical to what we have online 426. This is what we call list unpacking. Now what is important here is that the number of variables that we have on the left side of the assignment operator should be equal to the number of items we have in the list. So if we exclude third here and run this program we will get an error value error, too many values to unpack. So there are too many items in this list and we cannot unpack it into enough variables. Now what if in this list we have so many items but we only care about the first two. We don't want to define so many variables on the left side of the assignment operator. Well we can get the first and second and then pack the rest inside of a separate list called other. With this syntax we'll get the first and second items and everything else will be stored in a separate list called other. Let me show you. So let's print first and let's also print other. Now we don't need these few lines here. Let's run this code. So first is one and other is a list of all the items after the second item. That is the list I'm talking about. So in this example we have both unpacking and packing. First we try to unpack this numbers list into the variables on the left side of the assignment operator and then because we have used an asterisk here we're basically packing all the other items into a separate list. Now to refresh your memory earlier we used this syntax when defining a function with a variable number of arguments. Remember we had a function like this multiply with a parameter called asterisk numbers and then we could call this multiply with arbitrary number of arguments. So when we prefix a parameter with an asterisk Python we get all this arbitrary argument and pack them into a list. This is exactly what is happening online too. Now let me delete this other stuff. Now let's change this example a little bit. What if we care only about the first and the last item? Well we can put other in between. So we get the first other and then the last item. So let's change the last item to nine and then print first, last and other. This is what we get. So first is one, last is nine and the rest is here. So this is all about list unpacking. In this lecture I'm going to show you how to loop over lists. So here we have a list of three items. We can use our four loops to loop over this list. So four letter in letters colon and then we print each letter. Save the changes and run the code we get a bc. Now what if we want to get the index of each item as well? Well we have a built-in function called enumerate. We call it and this will return an enumerate object which is iterable. In each iteration this enumerate object will give us a topple. Let me show you. So now when we run this code look in each iteration we're getting a topple. So a topple as I told you before is like a list but it's read only we cannot add new items to it. So in each iteration we're getting a topple of two items. The first item in this topple is the index and the second item is the item at that index. So now to get the index we can use square brackets to access the first item in this topple. So if we print letter of zero we will get the indexes and right next to that we can add letter of one. So we will see the item at a given index but this syntax is a little bit ugly. In the last lecture you'll learn about list unpacking. So if we have a list with two items zero and a we can unpack it into two variables like this index comma letter equals items. So here we are unpacking the items list. Now what if we change square brackets to parentheses. Now we have a topple and we can still unpack this topple. So you saw that this enumerate function returns an enumerate object which is iterable. In each iteration this enumerate object will return a topple that looks like this. So we can unpack it right here. So we add another variable index. Now with this we no longer have to use square brackets and we can simply print index and letter. Let's run this code there you go. So now we don't need this anymore. So to recap you can use four loops to iterate over lists. If you also need the index you should call the enumerate function this will return an enumerate object which is iterable. In each iteration it will return a topple and you can unpack that topple right here. In this lecture I'm going to show you how to add new items to a list or remove existing items. So for adding items you have two options depending on where you want to add this new item. If you want to add an item at the end of the list you should use the append method. So earlier you learned that everything in Python is an object so you can use the dot notation to access individual functions or more accurately methods in that object. So when a function is part of an object we refer to that function as a method. So here are all the methods available on list objects. We use the append method to add something at the end of this list. Let's print our letters and we will get a bcd beautiful. Now if you want to add an item at a specific position you should use the insert method. So letters that insert we can add something at the beginning of the list. So index zero let's add a hyphen and then print the result so this is what we get. Now for removing objects again you have a few different options. If you want to remove the item at the end of the list you should use the pop method. So here we call letters dot pop this will remove the letter d at the end of our list. So now let's print our letters. As you can see d is gone. We can also pass an index here to remove the item at the given index. So if you pass zero instead of d this hyphen will be removed. Let's take a look. We run this. So the hyphen is gone and we get a bcd beautiful. Now there are times that you want to remove an object but you don't know it's index. If that's the case we can use the remove method. So letters that remove here we can remove b and this will remove the first occurrence of the letter b. So if we have multiple b's only the first one will be removed. If you want to remove all b's in this list you'll have to loop over this list and remove each b individually. Now let's run this code more more time. So you can see b is gone. We have another way to remove an item from a list and that is using the del or delayed statement. So here we can delete an item by its index. We can also delete a range of items. So this is the difference between the delayed statement and the pop method. The pop method will remove only one item by index whereas with the delayed statement we can remove a range of items. And finally if you want to remove all the objects in the list you should use the clear method. Next we'll look at finding objects in a list. There are times that you want to find the index of a given object in a list. So let's say we want to find the index of letter a in our letters list. We call letters that index and pass a. Let's print the result. So this will return 0. What if you try to get the index of an object that doesn't exist here like d? We get a value error d is not in the list. This behavior is different from a lot of programming languages out there. C-based languages return negative 1. If you try to get the index of an object that doesn't exist in the list but in Python we get an error. So to prevent this error from happening first you should check to see if the given object exists in the list. And for that we use the in operator. So if d is in letters then we will print its index. So now we run the program and we don't get any errors. We also have another method that you might find useful in certain situations and that is count. So letters that count this will return the number of occurrences of the given item in this list. So when we print the result will get 0. Next we're going to look at sorting lists. Here we have this list with a bunch of numbers that are not in any particular order. To sort this list we call numbers.sort. Now let's print it and you can see our numbers are sorted in ascending order. What if you want to sort these items in descending order? Well this sort method takes two parameters. Key which we'll look at later and reverse which we can use to change the sort order. So here we can use a keyword argument to set a value for the reverse parameter. We set this to true and with this you can see our numbers are sorted in descending order. So this is the basic of sorting lists. However in addition to the sort method we have a built-in function called sorted. As you can see this function takes an iterable so we can pass any iterables here and it will sort it for us. So we can pass our numbers list and this will return a new list that is sorted. So unlike the sort method this will not modify the original list. It will return a new sorted list. So let me comment out this line and print the result of calling this function. Now let's run this program. You can see here is our new list that is sorted and below that we have our original list that is not sorted. Also similar to the sort method if you want to change the sort order you can simply set the reverse argument to true. Let's run it one more time and here's the result. Beautiful. So sorting numbers and strings is pretty easy but what if we're dealing with a list of complex or objects? For example what if we have a list of topples? Let me show you. So I'm going to delete let's imagine we are building an application for processing orders and we have this list of order items. Every item in this list is a topple with two items. The product name followed by the price. So here's the first item. Now let's add another item with a different price and finally the third item. What happens if we try to sort this list? Let's take a look. So items.sort and then we print the items. So nothing is changed here because Python doesn't know how to sort this list. In situations like this we need to define a function that Python will use for sorting lists. Let me show you. So here I'm going to define a function. Let's call it sort underline item. This function should take an item like this topple. There you go. And it should return a value that will be used for sorting. In this example let's imagine we want to sort these items based under price. So if each item is a topple we can get the price using square brackets of one. So we'll return item of one. So all this function does is that it takes an item and it returns its price. Now Python is dealing with a list of numbers and it can easily sort that list. Now finally we need to pass this function when sorting our list of items. So once again look at this sort method. The first parameter is key. And this is where we need to pass our sorting function. So we pass sort underline item. But note that I'm not calling this function. I'm simply passing a reference to this function when Python attempts to sort this list the list of items it gets each item and it will pass each item to our sort function. Okay. So let's run this program and see what happens. We get a type error sort takes no positional arguments which basically means here we can only use keyword arguments. So we need to specify our argument that is key. We set it to sort item. Now let's run this program one more time. Okay. Look our list of items is sorted by the price of each item. However the way we have implemented this sort function is a little bit ugly. There is a better way and that's what I'm going to show you next. If you have any experience with other program languages you've probably heard of the term lambda expression or lambda function. It's basically a simple one line anonymous function that we can pass to other functions. So here on line 12 we're passing a reference to our sort underline item function. We can improve this code and make it cleaner by using a lambda expression or an anonymous function. So we don't have to define this function first and then pass it here. So we remove this and add lambda with this pretending Python that we're defining a lambda or anonymous function. The syntax for writing a lambda function is like this. We add parameters colon expression. So using this syntax we can rewrite this function. How many parameters do we have here? Only one. So we add that here item. Then after the colon we should add an expression. What are we returning in our sort under an item function? We have returning item of one. So we simply add that here item of one. Now we can see with this syntax we don't need to use def for defining a function. We don't need to give our function a name. We don't need these parentheses here and we don't need the return statement. So this is a shorter and cleaner way to define a function that we're going to use only once as an argument to another function. Now let's delete these two lines. Run our program again. We'll get the exact same result. Our items are sorted by their price. Over the next two lectures I'm going to show you more examples of using lambdas in your programs. So here we have this list of items. Let's imagine we want to transform this list into a different shape. So currently each item in this list is a topple of two items. Let's say we're only interested in the price of these items. So we want to transform this list into a list of numbers. That is the list of prices. Here is a basic way to do this. We can define an empty list. Then iterate over our list of items. So for item in items we call prices.apend item of one which returns the price of each item. Now let's print the prices. So we get a list of numbers. With this code we have transformed or mapped our original list into a different list. There is a better and more elegant way to achieve the same result. Instead of this loop we can use the map function. So we call the built-in map function. As we can see this function takes two parameters. A function and one or more intervals. So as the first argument we can pass a lambda function and as the second argument we can pass our list of items. This map function will apply our lambda function on each item in this list. Let me show you what I mean. So we pass a lambda. This lambda is a function that will transform each item in our original list. So the parameter to this function is item and here we simply want to return the price of that item. So item of one. Now as the second argument to the map function we need to pass our items list. So this map function will iterate over this iterable and it will call this lambda function on each item of this iterable. Now let's see what this function returns. So temporarily I'm going to assign this to a variable called x. Let's print x and also we don't need these three lines because we can achieve the same result using the map function. So delete. Now let's run this program. So this map function returns a map object which is another iterable. So we can easily iterate over it for item in x will print item. There you go. So we get the prices. Alternatively we can convert this map object into a list object. So we can use our list function earlier you learned that you can pass any iterables to this list function to create a new list. So we passed that here and now we can rename x to prices and simply print prices. We don't need this loop here. Let's run the program. So we get a list of three numbers. So this is how the map function works. It takes a lambda function and applies it on every item of this iterable. Here is another scenario for using a lambda function. So we have our list of items. Let's say we want to filter this list and only get the items with price greater than or equal to $10. Again one basic way is to define an empty list like filtered. Then we iterate over our list of items. For each item we get the price if it matches our criteria will add it to this list. But that's pretty basic. A better approach is to use the built-in filter function. Look at the parameters. This function just like the map function takes two parameters. A function and an iterable. So it will apply this function on each item of this iterable. If the item matches some criteria it will return it. So let's see how we can use this function. As the first argument we're going to pass a lambda function. This function takes an item and returns a Boolean value that determines if this item matches a criteria or not. In this case we want to get the price of each item and see if it's greater than or equal to $10. So the result of this expression is a Boolean value. If it's true this item will be returned. Now as a second argument to the filter function we pass our items list. Let's temporarily store the result in a variable called x and print it. So we get a filter object. A filter object just like a map object is iterable so we can loop over it and we can also convert it to a list right away. So let's call list. Now we get a filtered list that we can print on the terminal. So as you can see we only have product one and three because their prices are greater than $10. So here's the usage of map and filter functions that you just learn about. These two functions are pretty useful in Python and they're often used by developers who come from a functional programming background. So the concept of mapping and filtering lists is very natural to them. But in Python we have another feature for achieving the same result and as far as I know we don't have this feature in other programming languages. That is called comprehension. So let me show you how that works. Here's the basic syntax. We add our square brackets for defining a list and here we'll write a comprehension expression like this. Expression for item in items. Well this part is very familiar to you right? It's like a for loop. So we are iterating over and iterable and then applying this expression on each item. In this example if you want to get the price of each item we can write an expression like this item of one. So this is what we call a list comprehension and it produces the exact same result as what we have on line seven. So let's store the result in prices. As you can see this code is shorter and cleaner. We don't have all these parentheses and colon. In my opinion what we have on line seven is a little bit ugly and noisy. Now some developers might disagree with me but generally speaking in the Python community the preferred way to map and filter lists is to use list comprehension. But I wanted to include the map and filter functions in this course because as you look at the code written by others will probably come across instances of using the map and filter functions. So I wanted to make sure that you really understand how they work. But as a best practice my recommendation to you is to use list comprehension because they are cleaner and also more performant. So this is how we can use a list comprehension to map a list into a different kind of list. Now as part of this mapping we can also filter items. So if I want to rewrite what we have on line 10 using a list comprehension that would look like this. Filtered we set it to square brackets so we're defining a new list no need to call the list function in between the brackets will write an expression. So here is a syntax expression for item in items. Now what is the expression here? Well in this case we don't want to map the list of items to list of prices. So our expression is simply the item itself. So basically we'll iterate over the list of items we'll get each item and simply return it. However you want to filter them so we'll add an if statement if item of 1 is greater than or equal to 10. Once again I personally find what we have on line 11 more readable and cleaner than what we have on line 10 but if you want to use the map or filter functions that's perfectly fine. Here we have two lists. Let's say we want to combine these two lists into a single list of topples like this. So we have a list where each item is a topple and in the first topple we're going to have the first element of each list. So 1 and 10. Similarly in the second topple we're going to have the second element of each list and finally the third topple. How can we combine these two lists into a single list like this? But in this case we can use the map function or a list comprehension because both these work with a single list but here we're combining multiple lists. To achieve this we use the built-in zip function. So zip look this function takes multiple iterables and it will combine them the way I showed you. So we pass list 1 and list 2. Let's print the result on the terminal. So look it returns a zip object which is also iterable. So we can iterate over it or simply pass it to the built-in list function to convert it to a list. Now let me show you something cool. As you saw this zip function takes one or more iterables. So we don't have to pass a list here. I can also pass a string like ABC and look at the result. So now our string ABC is a spread across multiple topples in this list. That's pretty powerful. If you want to achieve the same thing in other programming languages you have to write several lines of code. But in Python you can do it in a single line. In programming we have a common data structure called stack which resembles a stack of items in the real world. Imagine you have a stack of books. The last book that you put on top of this stack is the first book that you can remove. You refer to this behavior as LIFO which is short for last in first out. So this is a stack data structure and it's very common in real world applications. A good example of that is your browser. Whenever you navigate to a new website your browser keeps your browsing session in a stack. So when you click the back button it takes you to the previous website. Let me show you how it works. So we start with an empty stack. Now let's say we navigate to website number one. Now here for simplicity I'm using a number. If you're building a browser instead of a number we'll use a string which is the address of the current website. Now let's say we navigate to a couple more websites and then click the back button. At this point the browser removes the item on top of this stack and then it will redirect us to the previous website. Now let's say we press the back button a couple more times so we'll end up with an empty stack. At this point the browser will disable the back button. This is how a stack works. Last in first out. Now let me show you how to use a stack in Python. Basically we can use a list object as a stack. So here I'm going to define a variable like browsing session and set it to an empty list. Now let's say the user navigates to website number one. So we call browsing session.apand method and add the address of the current website. Now let's say the user navigates to website number two and then three. Let's have a look at what we have in our stack. So we print it and as you see we have a list of three items. Now when the user presses the back button we should remove the last item in this list. How do we do it? We use the pop method. So we call browsing session.ap. This will remove the last item from the stack and return it. So we can get it here. But in this case we're not going to use this value. Let me just print it on the terminal. So you can see that so three is removed from the stack. Now if we print our stack one more time, print browsing session, you can see three is removed and we have only two items in our stack. So we need to take the user to the previous website which is the item on top of the stack and we can get that using a negative one index. Very easy. So back here browsing session of negative one. This returns the last item. So we print it and I would like to add just a label for clarity redirect. Let's look at the result. So when the user presses the back button we redirect them to the previous website which is website number two. Now here we need to check if the stack is empty or not. If it becomes empty we need to disable the back button. So that is very easy. Earlier in the course I told you about the false values. So number zero and empty string and empty list. These are all false values. So if you apply the not operator to an empty list we'll get the Boolean true. So to see if our stack is empty we can simply write code like this. If not browsing session then at this point we will disable the back button. So let me recap. We use the append method to add an item on top of the stack. We use pop to remove the item on top of the stack. We use index negative one to get the item on top of the stack and of course before doing that we need to check to see if our stack is empty or not because if it's empty when we run this code we'll get an error. So if not browsing session then we'll get the item on top of the stack. These are the operations that you can perform on stacks. In the last lecture you learned about stacks. You learned that stacks have the life of behavior. Last in first out. We have another very useful data structure called Q which has the FIFO behavior. First in first out and it resembles a Q in the real world. Let's say a Q of people to get into a restaurant. The first person in the Q is the first person who would get in. Now technically you can use a list to implement a Q in Python. So let's say we have a Q of three items. If you want to remove an item from this Q we should remove the one at the beginning as opposed to the one at the end. So we remove one and then two and then three. However if you're dealing with a large list or a large Q you might see some adverse effects on the performance because let's say we have a large number of items in this list. Every time we remove an item from the beginning of this list all the other items need to be shifted to the left. So if you have a list with a thousand and one items when you remove one item a thousand items need to be moved in memory. In situations like that it's more efficient to use a DQ object. Let me show you how to do that. So first we need to import DQ from the collections module. I'm going to talk about modules later in the course. For now let's imagine a module is a bucket with a bunch of reusable code. So from collections that's the name of our module. We should import DQ which is a class. Again I'm going to talk about classes later in the course. So we import a DQ class here. Now instead of defining a variable and setting it to an empty list we should wrap this list with a DQ object. So we call DQ and pass our empty list as an argument. This DQ object has similar methods that we have in the list object. So we can call Q dot app and let's app and a few items here one two three. Now to remove an item from the beginning of the Q we call Q dot pop left. We don't have this method in list objects. So after we remove one item let's look at our Q. There you go. You can see one is removed and now we only have two and three. Also similar to lists we can easily check to see if a Q is empty using the not operator. So if not Q that means we have an empty Q then we can print something like empty. So this is all about Qs. Throughout the course I've mentioned topples a few times. In this lecture we're going to take a closer look at them. A topple is basically a read only list. We can use it to contain a sequence of objects but we cannot modify this sequence. We cannot add a new object to it. We cannot remove an existing object and we cannot modify an existing object. So let's start by defining a topple called point. Instead of square brackets we use parenthesis to define a topple. So here we add a couple of numbers here, a point with x and y values. We can also exclude parenthesis and Python will see this as a topple. Let me show you. So let's print type of point and run this program so you can see it's a class of topple. Now if you have one item you should add a trailing comma otherwise Python things you're defining an integer. So if you run this code you can see point is an integer but if we add a trailing comma here Python treats this as a topple. Also if you want to define an empty topple you should use empty parenthesis. So let's run this one more time. You can see point is still a topple. Now similar to lists we can concatenate two topples. So here we have one topple we can concatenate it with another topple. Let's print the result. So now we have this topple with numbers 1 to 4. We can also use the multiplication operator to repeat a topple. So now when we run this code we have a topple with 1, 2, 1, 2 and 1, these are different ways to create a topple. We can also convert a list to a topple. So let's say we have a list of two numbers to convert this list to a topple we call the topple function. As you can see this function takes an iterable so we can pass any iterables here and this function will return a topple. So here's one example let's print point. Now we have a topple of two numbers or we can pass a string like hello world and because strings are iterable now we get a topple of 11 strings. Now let me revert this back to a simple topple. Similar to lists we can access individual items using an index. So we can get the first item which is one or we can get a range of items like items from index 0 to index 2. This returns another topple with only those objects. We can also unpack these topples so we can define three variables like x, y and z and set it to point. Similar to lists we can use the in operator to check for the existence of an item. So if 10 is in point then we print exists. But as I told you these topples are immutable. We cannot mutate them. We cannot change them. So if I try to modify point of 0 and set it to a new number look we immediately get this red underline and if you run the code we get this type error. Topple object does not support item assignment. For this very reason on leg lists we don't have methods to add a new object or remove an existing object. So you might ask where in the real world we use topples. Here's a basic rule of thumb. Let's say you're dealing with a sequence of objects and you want to make sure that you don't accidentally modify this sequence you don't accidentally add a new object to it or remove an existing object. So instead of a list you can use a topple to prevent these accidental errors. Now let me show you something really cool. I'm going to define two variables x and y. A basic exercise we give to people who starting programming is to write code to swap two variables. Do you know how to do this? If you don't pause the video and think about it for a minute. But here is the solution. To swap two variables we need a third variable. So I'm going to define a third variable like z and set it to x. So basically we're copying the value of x into a separate variable as a backup. Now we can overwrite x with y. So we set x to y we copy the value of y to x. Now we have the old value of x stored in z. So we can use that to overwrite y. We set y to z. With these three lines we can swap the value of these two variables. So if we print x as well as y we will see that x is changed to 11 and y is 10. Now I've got a good news for you. In Python we can swap the value of two variables using only one line of code and without a third variable. Let me show you. So instead of writing these three lines we can simply write x, y equals y, x. Now if we run this code we get the exact same result but let me explain what exactly happens under the hood. Here on line four on the right side of the assignment operator we're defining a topple because in the last lecture I told you that when defining a topple you can use parentheses or you can exclude the parentheses. So this code is exactly equivalent to this. We have a topple what is y it's 11 what is x it's 10. Now what do we have on line five? We have a topple that we are unpacking. So we are setting x to 11 and y to 10 and that is why with this line of code we can easily swap two variables. For this very reason we can define multiple variables on the same line. So we can define a and b and set them to 1 and 2. Once again we're defining a topple and then unpacking it on the left side. So a will be 1 and b will be 2. So you have learned a lot about lists in Python. These lists are very useful but if you're dealing with a large sequence of numbers we have a more efficient data type in Python called array. These arrays take less memory and perform a little bit faster but note that you will see the difference only if you're dealing with a large list of numbers let's say 10,000 or more. So for 90% of the cases you will use lists but if you run your program and you see some performance problems then you can see if you can solve the problem by replacing a list with an array. If you don't have any performance problems don't try to optimize. In other words don't solve a problem that doesn't exist. So let me show you how to use arrays in Python. To use an array we need to import it from the array module. So on the top from array import array. So we have a module called array and in this module we have a class called array. It has the same name as the module itself. Now we call array. Look at the first parameter. This is called a type code which is a string that determines the type of objects in your array. So here in Google search for Python 3 type code. Then click the first link and this table you can see all the type codes in Python. So it's a string of one character that determines the type of objects in your list. So if you're dealing with signed integers you should use a lowercase i. So here let's add i and then as a second argument we pass a list of integers. So we move this list here. Now we get an array. We can call it numbers. In this object similar to lists we have methods for adding new objects or removing existing ones. So we can call numbers that are meant to append a number to the end of the list or we can use insert to add a number at a specific index. We also have pop and remove exactly like lists and we can also access items by their index. So we can get the first item in this array. However unlike lists the objects in this array are typed. So here every object should be an integer. If we try to put a floating point number here or any other kind of objects we'll get an error. Let me show you. So I'm going to change the first item to 1.0. Now let's run the program. We get this type error integer argument expected. Got float. So every object in this array should be of the same type which is determined at the time of creating the array using the type code. So to recap use arrays only if you're dealing with the large sequence of numbers and you encounter performance problems. For other cases use lists and topples by default. In Python we have another very useful data structure called a set which is basically a collection with no duplicates. So let's say we have a list of numbers with a bunch of duplicate items like this. If you want to remove the duplicates you can convert this list to a set. So I'm going to define a variable Unix. We call the set function and pass the numbers list. Now when we print this take a look we only have unique items. So one is not repeated. Also note that we use curly braces to define sets. So here we can define a second set using curly braces with two items 1 and 4. Now similar to lists we can add new items to a set or remove an existing one. So here we can call second dot add. We can append a new number here. We can also call remove. And we can use the length function to get the number of items in a set. So these are the basics. But where sets shine are in the powerful mathematical operations that are supported by them. Let me show you. So I'm going to delete these three lines. These are pretty basic and rename Unix to first. So we have two sets first and second. Now we can get a union of two sets using the vertical bar. So this expression will return a new set that includes all the items that are either in the first or in the second set. Let me show you. So print. Actually I'm going to change this four to five. So now when we run this code you can see the union of these two sets is another set that includes all the items that are either in the first set or the second set. We can also get the intersection of two sets. So print, first and second. This will return a new set that includes all the items that are in both first and second sets. Take a look. So the only number that exists in both these sets is one. We can also get the difference between two sets. So print, first, minus second. When we run this code we get two, three, four. So the first set has these additional numbers that we don't have in the second set. And finally we have symmetric difference. So print, first, carrot, second. This will return the items that are either in the first or second sets but not both. So let's run this. We get two, three, four, five. Now one thing you need to know about sets is that unlike lists are unordered collection, which means the items that we have in a set are not in sequence. So we cannot access them using an index. In other words, if we try to print, first of zero, we will get a runtime error set object does not support indexing. So if you need to access items when index, you need to use a list. With sets quite often we use one of these operations here or we can check for the existence of an item in a set. So we can check to see if one is in the first set, then we can print. Yes. There you go. So to recap, set is an unordered collection of unique items. We cannot have duplicates and these objects are unordered. They're not in sequence. So we cannot access them using an index. In Python, we have a very powerful data structure called dictionary that is basically a collection of key value pairs. We use it to map a key to a value. A real word example of this is a phone book. In a phone book, we map a person's name to their contact details. So we use a person's name as the key and their contact information as the value. So a phone book is a dictionary. It's a collection of key value pairs. Now let me show you how to work with dictionaries in Python. So I'm going to define a variable point. We can set it to an empty dictionary or we can add one or more key value pairs here. Here is an example. We set x to 1 and y to 2. So in this example, I'm using a string for the key and an integer for the value. In Python, we can only use immutable types for the keys. So quite often we use strings and numbers. But the value can be of any type. There are no limitations. So here's one way to define a dictionary. We can also use the dict function just like we have the list, topple and set functions. We also have the dict functions that we can use to create a dictionary. So let me redefine point by calling the dict function. So when we call this function, we pass one or more keyword arguments. Remember keyword arguments. So x equals one. This is a keyword argument. We can also set y to 2. Now I personally prefer the second approach because we don't have to deal with this quote. I find this syntax a little bit cleaner and shorter. So now we have a dictionary. We can get the value associated with a key using an index. So point of x, note that our index is the name of a key. So because dictionaries are collections of key value pairs, we cannot access an item using a numeric index as we do with lists. So here we're getting the value associated with the key x. Let's print it on the terminal. So we get one. Similarly, we can change the value of x to a new value. Now let's print our dictionary. So x is 10. Y is 2. Beautiful. We can add a new key. So let's set z to 20 and then print the point. So now we have three key value pairs. Now when reading a value, if we use an invalid key, we'll get an error. So let's look up the value of the item with the key a and then print this around the program. We get this error key error. There are two workarounds here. One solution is to check for the existence of a key. So if a in point, then we'll get the value of the item with key a and print it. Now you don't get the error anymore. The other solution is to use the get method. So instead of using brackets and the name of the key, we call the get method. Here we pass the name of the key. Let's print it. So if the key doesn't exist, by default, it returns none. Or we can pass at default value as a second argument. So we say, hey, if you don't have an item with the key a, return zero by default. Let's take a look. Now we get zero. Beautiful. To delete an item, we use the del or delete statement. So delete point of x. Now let's print point and look at the result. So x is gone. We only have y and z. So these are the basic operations around dictionaries. We can easily add new items, remove existing ones and look up items by their key. Finally, let me show you how to loop over dictionaries. So if we write a simple four statement for x and point, let's see what we get. We get y and z. So in each iteration, our loop variable will hold the key of an item. So it's better to rename this to key. Now we can print the key, as well as the value associated with the key. So we write point of key. As you can see, y is two and z is 20. There is another way to iterate over a dictionary. So here we can call point dot items. Now let me rename key to x and just print x. Let's see what we get. So in each iteration, we get a topple. In this topple, we have the key and the value. So we can unpack it right here. We can extract key and value and simply print them here like this. When we run the program, we get the same result. All right, look at this piece of code here. On the top, we're defining an empty list. Then we are iterating over this range object. In each iteration, we get x, multiplied by two, and added to our list. As I told you before, whenever you have this pattern in your code, you can either use the map function or preferably a list comprehension. So let's review the syntax for a list comprehension. We have square brackets to define a list. And here's our comprehension expression. We have expression for item in items. So we iterate over an iterable. In each iteration, we get this item and then do something with it. So what is our iterable in this example? Is this range object that is returned from the range function? So range of five here. What is our loop variable that is x? And what is our expression? We're multiplying x by two. So we can store the result in values. This line of code is exactly identical to these three lines. So let's delete this. Now, these comprehensions are not limited to lists. We can also use them with sets and dictionaries. So now, if we replace these square brackets with curly braces, we get a set. Let's print values. So we get a set of even numbers. Right? Now, what is the syntaxical difference between a set and a dictionary? Well, for both these data structures, we use curly braces. In sets, we just have values, but in dictionaries, we have key value pairs that are separated using a colon. So here we can map one to a character, two to another character, and so on. So we can easily use comprehension expressions to create dictionary objects. So here in this expression, all we need to do is to change this expression such that we have a key value pair. So here we can use x as the key and x times two as the value. Now, let's delete these two lines, save the changes and run the code. We have this dictionary with these key value pairs. Okay? So instead of defining an empty dictionary, then looping over an iterable, and then in each iteration adding something to this dictionary like values of x equals x times two, whenever you have this pattern in your code, you can use a dictionary comprehension. So to recap, we can use comprehension with lists, sets, and dictionaries. But what about topples? Let's take a look. So let's remove this key value pair and only use x times two, and also change the curly braces to parentheses. Let's also delete these few lines. Run the program. We don't get a topple. What's going on here? We get a generator object. And that's the topic for the next lecture. Here we're creating a list using a list comprehension expression. Then we iterate over all the numbers in this list and print them. When we run this program, we get the even numbers from 0 to 18. This is perfectly fine, but there are situations that you might be working with a really large data set or perhaps an infinite stream of data. In those situations, you should restore all those values in the memory because that's very memory inefficient. For example, what if instead of range of 10 here, we had the range of let's say a billion. We don't want to store a billion objects in memory that takes too much memory. In situations like this, it's more efficient to use a generator object. Generator objects are iterable. So just like lists, we can iterate over them. And in each iteration, they generate or spit out a new value. So unlike lists, they don't store all the values in memory. They generate a new value in each iteration. Let me show you how that works. So here, I'm going to replace these square brackets with parentheses. Save the changes, run the program. We get the exact same result. However, values is no longer a list. It's a generator object. Let me show you. So print values. Run the program. We get a generator object. So as you can see, generator objects are iterable. We can iterate over them. In each iteration, they spit out a new value. But what is interesting is the size of generator objects. Let me show you how you can get the size of an object. So on the top, from the sys module, we should import a function called get size of. So here we have a generator object. Let's change range to 1000. Now let's print the size of this object. So I'm going to delete everything here. Call get size of function, pass our generator object, and then print the result. Let's also add a label here. So generator. Run the program. So our generator object takes 120 bytes of memory. What if we change the range to 100,000? Let's run the program. The size of this generator object remains consistent. In contrast, if we used a list comprehension expression here, we would end up with a list of 100,000 items. Let me show you. So I'm going to copy this line and duplicate it and change parentheses to square brackets. So now we have a list. Let's copy this line as well, change the label, and see the size of this list. Run the program. So our list is taking over 800,000 bytes of memory compared to our generator object that takes only 120 bytes. So in situations where you're dealing with a really large data set or potentially an infinite stream of data, use a generator expression to create a generator object. So when we use parentheses around a comprehension expression, just be aware that because generator objects don't store all the items in memory, you won't be able to get the total number of items you're working with. For example, here, let's just keep the generator object and then print the length of values. Let me run this code will get an error. Let's take a look. Object of type generator has no length because we can only access these items, these values when we iterate over a generator object. So we won't know ahead of time how many objects or how many items this generator is going to produce. So in this section, you have learned a lot about data structures in Python, one operator that comes handy when working with these data structures is the unpacking operator. Let me show you how that works. So let's say we have a list of numbers, 1, 2, 3. If we print this list, we get a list on the terminal. But what if you want to print the individual numbers? In other words, what if we want to get an output like this? Let's run this program. So here we don't have square brackets and we don't have comma. We're printing out individual numbers, individual items in our list. To achieve this, we can use the unpacking operator. So all we have to do is prefix this variable with the unpacking operator. In JavaScript, we have an operator called spread operator, which is three dots. This is exactly the same. So here we unpack a container, take out its individual elements and pass them as arbitrary arguments to the print function. Now, if we run this program, we get the exact same output. Another useful application of this is when creating lists. So let's say we want to have the list of numbers from 0 to 5. You know that this range function returns a range object. So we need to convert it to a list and then store the result in this variable. Now let's print this. We get 0 to 4. Beautiful. In this case, instead of calling the list function, we can use the unpacking operator. So we call range of 5. This returns an iterable. The good thing about this unpacking operator is that we can unpack any iterables. It doesn't have to be a list. So we unpack this iterable, which basically means we take individual values, then we put them in a list and finally store the result here. By the same token, we can unpack a string. So we unpack a string like hello. Now let's take a look at the result. So we have the numbers 0 to 4. Now because we are unpacking this hello is string, we're getting individual characters and put them in our list. So these are some cool tricks that we can do in Python that as far as I know, we don't have in other popular languages. Let's look at another example. Using this operator, we can combine multiple lists. So here we can have one list and another list. Now to combine these lists, we can unpack the first one and then the second one. We can also put something in the middle or unpack a string at the end. Hello. So it's very powerful. Now we can also unpack dictionaries, but we need to use two ask the risks. Let me show you. So I'm going to define one dictionary. Let's add a key value pair here. So X, now let's define the second dictionary. I'm going to repeat X here, but with a different value and also add Y. Now to combine these dictionaries, we can use the unpacking operator. So we create an empty dictionary with unpack the first dictionary. This will take out all the key value pairs in our first dictionary and then we'll unpack the second dictionary. We can additionally add another key value pair. Now let's print the result. Note that the value of X is 10. So if you have multiple items with the same key, the last value will be used. So to recap, we can use the unpacking operator to take out individual values in any iterable. All right, time for an exercise. This exercise I'm going to give you is one of my favorites because it's a common interview question that big companies like Microsoft, Amazon, and Google use a lot. So let's say we have some text. I want you to write a program to find the most repeated character in this text. So pause the video, work on this exercise for five to ten minutes, when you're done, come back and continue watching. All right, how do we solve this problem? Well, first we need to know how many times each character is repeated. Once we have that information, then we can find the most repeated character. What kind of data structure is useful for storing this information? Addictionary because addictionery is a collection of key value pairs. So here we can use the characters as the keys and the repetition as the value. So I'm going to start by defining an empty dictionary. Let's call it char or character frequency. We set it to an empty dictionary. Now we need to iterate over this string, get each character and update its frequency in this dictionary. So we need a for loop for char in sentence. Now first we need to see if we have this character in our dictionary. If we don't have it, we need to set its frequency to one. Otherwise, we need to increment the frequency. So if char in char frequency, if we do have it, then we simply get the value and incremented by one. Otherwise, we need to add it to our dictionary. So char frequency of char we set it to one. So let's print this dictionary and see what we get. Char frequency. There you go. Run the program. So capital T is repeated once, H is repeated once, I is repeated five times and so on. Now this output is a little bit unreadable. So I'm going to show you a trick to make it more readable. We have a module called pretty printing. So on the top, from P print module, we need to import P print function. With this function, we have more control over printing stuff on the terminal. So here, instead of the regular print function, we use P print, and as the second argument, we pass a keyword argument called width that determines the number of characters on each line. If this output doesn't fit, this function will add a line break. Let's set this to one and see what happens. We run the program. So this is a better way of printing a dictionary. So now we have all the information to solve this problem. The next step is to sort this dictionary by the frequency of characters. However, as I told you before, dictionaries, like sets, are unordered collections. We cannot sort them. We can only sort lists. So we need to pull out the items in this dictionary and put them in a list for sorting. So basically, we need to take out each key value pair, convert it to a top all and then put it in a list. We'll end up with a list of top holes that we can easily sort. So how do we do this? Pay close attention to what I'm going to do. I'm going to call the sorted function. Earlier, you learned that this function takes an iterable and sorts it. As the iterable, I'm going to pass charfrequency.items. Earlier, you learned that this method returns all the key value pairs as topples. So at this point, if we print this result, let's see what we get. We get a list of topples. In each topple, we have two items. The first is the character and the second is the repetition or frequency. But as we can see, this list is not sorted. Because by default, this sorted function doesn't know how to sort this topples. So earlier, I told you that we can pass a second argument here, key. We set this to a lambda, which is an anonymous function. This function takes the key value pair and returns the value. So that is key value of one. That is the frequency of each character. We're going to use that for sorting. So let's run the program one more time. Now, as you can see, this list is sorted. So T is the least repeated character and space and I are the most repeated characters. Now we need to reverse the sorting. So back to our sorted function. As the third argument, we're going to pass a keyword argument, reverse equals true. Save the changes, run the program one more time. Now all these items are sorted in descending order. Beautiful. So instead of printing the result, let's store it and a list like char frequency on the line sorted. Finally, the first item in this list is the solution to our problem. So we simply print char frequency sorted of zero. Save the changes, run the program one more time. So I is the most repeated character with five repetitions. Now one final improvement. You can see the code online 12 is kind of outside the screen. Partly, this is because I've zoomed in so you can see properly. But PEP8 recommends a maximum of 80 characters on one line. So if you have a line that is too long, it's better to break it down into multiple lines. This makes your code more readable. So here, I'm going to list each argument on a new line like this. That is better. And that brings us to the end of this section. In the next section, you're going to learn about errors and exceptions. I hope you enjoyed this section and thank you for watching. When writing programs, many things can go wrong. Our programs may encounter an error and terminate. Usually, these errors happen because of programmers mistakes or bad data that we get from the user or resources not being available. For example, you might need to open a file, but if that file doesn't exist, our program is going to crash. It's your job as a programmer to prevent your application from crashing in these kind of situations. Instead, we want to display a proper error message to the user like, hey, this file doesn't exist. So let's take a look at a few examples. I'm going to define a list of numbers with two items and then print the third item. When we run this program, we get this error index error. This happened in this file after pie online to and here's the statement that generated this error. In programming, we refer to this kind of error as an exception. An exception is a kind of error that terminates the execution of a program. More specifically, we say this line, this statement, through an exception. And this is an example of an exception that was thrown because of the programmers mistake. Here's another example. Earlier, you learned about the input function to get input from the user. Let's say we ask for the user's age, you know that this function returns a string. So we need to convert it to an integer and then store it here. Now, instead of running this using the code runner, let's go to the terminal and run Python or Python 3 app.py. The reason I didn't run this using code runner is that by default code runner runs our programs in the output window, which is read only. So we cannot enter data. So here in the terminal, let's run this program. If we enter a non numeric value like a, our program crashes. In this example, we got an exception of type value error. So as I told you before, it's your job as a programmer to handle these exceptions and prevent your application from crashing. And that's what I'm going to show you next. In this lecture, I'm going to show you how to handle exceptions in your programs. So, containing with the code from the last lecture, to handle the value error exception here, we need to put the statement in a try block. So we add try colon, we indent it, and then after try, we need to add an accept clause. What is the type of the exception that we get if the user enters a non numeric value? That's a value error exception. You saw it in the last lecture, right? So we add the accept clause and then we'll print a friendly error message like you didn't enter a valid H. So this is how this works. When Python sees a try block, it will execute every statement in this block. If any of these statements throws an exception, the code in the accept clause will be executed. If we don't have any exceptions, this code will not be executed. Let me show you. So save the changes. Back in the terminal, let's run the program. I'm going to enter a valid age. So our program completed successfully. No error message is beautiful. I'm going to run the program one more time. This time, I'm going to enter a for the age. So we got a friendly error message and our application didn't crash. This is the important thing about handling exceptions. If you don't handle exceptions properly, your program will crash. So in other words, if you add another statement here, let's print execution continues. In this example, because we are handling this exception properly, this statement will be executed. Let me show you. So back in the terminal, let's run the program one more time. Enter a, we got our friendly error message and also, you can see the execution of our program continued. In contrast, in the last lecture, where we didn't have the try block, if we put this print statement after getting users age, this line would not be executed. Okay. We also have an optional else clause here. So else colon. And what we put inside this block will be executed if no exception is thrown in the code that we add in the try block. So let's print a message like no exceptions were thrown. Save the changes. Back in the terminal, let's run this one more time. I enter a valid age. You can see this message, no exceptions were thrown. So what we have in the else clause will only be executed if we don't have any exceptions. This is very similar to our four else loops. Remember four else earlier when I talked about four else loops, I told you that the else clause is executed. If we don't break out of the four loop, in other words, if the four loop completes, then the else clause is executed. So here's a basic structure for handling exceptions. Now one more thing before we finish this lecture. Here when handling the exception, we can optionally define a variable that will include the details about the exception. Mostly the error message and sometimes additional arguments. So here we add as and then define a variable like error or x for exception. So after this error message, let's just print x. I'm also going to print type of x. Now let's run the program one more time. Enter a. So here's our friendly error message. Below that we have the actual error message that is included in the exception invalid literal for end with base 10. Now this is very technical to show to an end user. So we're not going to print it on the terminal. This is just for demonstration. And below that you can see the type of this exception. It's an object of type value error. All right, I've simplified the code from the last lecture. Now let's extend this example. Let's make up a magic formula like x factor equals 10 divided by h. Save the changes back in the terminal. Let's run this program one more time. I'm going to enter 0 as the h. What happened? Our program crashed again. We got a different kind of exception. That is a 0 division error because in programming, we cannot divide a number by 0. So the statement online 3 through an exception, but we don't have a matching accept clause for that kind of exception. In other words, in this code, we're only handling value error exceptions. And that is why our program crashed. So to solve this problem, we can come back here and add a second accept clause, accept, and specify a different kind of exception. In this case, 0 division error. Now below that, we can print a message like age cannot be 0. Back in the terminal, let's run the program one more time and enter 0. Okay, beautiful. Our program didn't crash. Now let's take this to the next level. Let's imagine if the user enters 0 for the age, we want to print the exact same error message. So I'm going to copy this and paste it here. Now our code looks a little bit repetitive. We have repeated this message. And that means if in the future, we want to change this message, we have to change it in two places. There is a better way to handle this situation. In front of this accept clause, we can specify multiple types of exception. So if the exception that is thrown, matches any of those exceptions, then the code that we have in the accept block will be executed. So here, we need to add parentheses to specify multiple types of exceptions separated by comma. So comma, 0 division error and close parentheses save the changes. Now with this change, technically we don't need these two lines. We can delete them. But temporarily, I'm going to keep them to show you something interesting. So back in the terminal, let's run this one more time and enter 0. Note that we get a single error on the terminal. In other words, the code that we have in this accept block was not executed. Otherwise, we would see this message twice. So here's the lesson. When Python executes the code that we have in the tribe block, if any of the statements throws an exception that matches one of the accept clauses, that accept clause is executed and the other accept clauses are ignored. So to clean up this code, we can delete these two lines. That is better. There are times that we need to work with external resources like files, network connections, databases, and so on. Whenever we use these resources, after we're done, we need to release them. For example, when we open a file, we should always close it after we're done. Otherwise, another process or another program may not be able to open that file. So let's take this example to the next level. Here in our tribe block, first I'm going to open a file. So we call the open function and let's open app that pi here. This returns a file object. So let's get that here. Now when we're done, we should close this file object. So this file object has a method called close. Now the problem with this code is that this statement will not be executed in case of an exception. In other words, if one of these two lines, line three or line four throws an exception, the control will be moved to our accept clause. So what we have on line five will not be executed. One solution is to move this down here. But again, the problem is that this will only be executed if we have an exception. If we don't have an exception, the control will be moved here. So our file will not be closed. So another solution is to duplicate this here and duplication is a bad practice in programming. You should not repeat yourself in your code. So what is the solution? The solution is to use the finally clause. Let me show you. So I'm going to delete this line here and add a final clause at the end. This finally clause is always executed whether we have an exception and we use it to release external resources. So this is the perfect place to close files, database connections, network connections and so on. In the last lecture, you learned that we use the finally clause to release external resources. Now we have a shorter and cleaner way to achieve the same thing but without the finally clause. But it doesn't always work. It works with certain kinds of objects. Let me explain. So online to I'm going to make a couple of slight changes. Instead of getting the return value of the open function, we prefix this with the width statement and then we'll get access to the return value of this function by typing as file. So this is the file object that the open function returns. After that, we add a colon. So obviously here, we're going to have a block. In this block of code, we can work with this file object. For example, we can read something from this file or write to it and so on. So for now, let's just print file opened. Now whenever we open a file using the width statement, Python will automatically call file.close whether we have a final clause or not. In other words, the width statement is used to automatically release external resources. So now we can delete these two lines from here. That's better. But let's dive deeper and see how this exactly works under the hood. So look at this file object file dot. These are the members of the file object. We have methods that start with two underlines and we refer to them as magic methods. In the next section where I talk about classes and objects, you're going to learn about these in detail. But here we have two magic methods that you should be aware of. We have enter and exit. When an object has these two methods, we say that object supports context management protocol. Again, in the next section, I'm going to talk about this in more detail. So if an object supports the context management protocol or in other words, if an object has these two methods, enter and exit, we can use that object with the width statement. Python will automatically call the exit method and there it will release external resources. That is the reason we don't need a final class here. Now to take this to the next level, there are times that you might be working with multiple external resources. Let's say we want to read some data from one file and write it to another file. So how do we do that? Well, here before the colon, we can add a comma and open another external resource, like another file. So open, let's say another file.txt as we give it a variable name, like target, with this Python will automatically release both these external resources. I'm going to delete the second one here because we don't have a file called another.txt. So when we run this program, we'll get an exception and our program will crash. So delete. So this is all about the width statement. So far you have learned how to handle exceptions, but you can also raise or throw exceptions in your own code. Let me show you an example. So I'm going to define a function. Let's call it calculate x factor. This function takes age and simply returns 10 divided by age. Now, in this example, age cannot be zero or less. So we can have an if statement here. If age is less than or equal to zero, we can raise an exception. So we use the raised statement and then specify the type of our exception. So far, you have seen a few types, like value error, zero division error, and so on. In Python, we have various kinds of built-in exceptions. If you go to Google and search for Python 3 built-in exceptions, on this page, you can see all the built-in exceptions in Python and what they're used for. Down the bottom of this page, you can see the completeness of these exceptions. So as you can see here, we have a hierarchy, like a parent child kind of relationship. At the very top, we have base exception below that we have a future run, one of them is exception, below exception, we have arithmetic error and below that we have zero division error. So these are the built-in exceptions in Python and they're sufficient for most cases, but you can also define your own exception types. It's not something that you do that often, but it is something that you can do for sure. In order to do that, you have to learn about classes and that's the topic for the next section. Back to our code. In this case, we want to raise a value error exception. In parenthesis, we can specify an error message, like age, cannot be zero or less. So we have this function that raises or throws an exception if we give it an invalid argument. Somewhere else in our program, we're going to use this function. So we call calculate x factor and pass, let's say negative one. Now when we run this program, we can see our program crashed with a value error exception and here's the message age cannot be zero or less. Obviously this happened because we didn't handle exceptions here properly, so we didn't have a tri-block. To fix this issue, let's add a tri-block with an accept clause of type value error. Let's give this exception object a name, like error. And here we can simply print this error. Now let's run the program one more time. So here's our error message and our program didn't crash. Beautiful. So this is how you can raise exceptions in your code, but this is not something that I advise you to do. I only explained it here because you will see this in other people's code. As I will show you in the next lecture, raising exceptions is costly. So in this example, instead of raising an exception here and then handling it below this function, you could take a different approach that would result in better performance. That's what I'm going to show you in the next lecture. As I explained in the last lecture, when writing your own functions, prefer not to raise exceptions because these exceptions come with a cost. And that's what I'm going to show you in this lecture. So from the time it module, I'm going to import a function called time it. With this function, we can calculate the execution time of some Python code. So this is how it works. Imagine we want to calculate the execution time of this piece of code. We define a variable. Let's call it code one and say to a string, this string should include our Python code. So I'm going to use triple codes because our Python code is spread across multiple lines. And we terminate it here. So this is one piece of code. Now after that, we call time it as the first argument we pass our Python code. That is our code one variable. Now here we have a keyword argument number. We set this to the number of times we want to execute this piece of code. So let's set it to 10,000. So we can see the difference. Now this function returns the execution time of this piece of code after 10,000 repetitions. Now this function will execute our Python code 10,000 times. It will calculate the execution time and return it. So we can simply print it on a terminal. I would like to add a label as well. Let's say first code. Now open up a terminal window. You can't run this using code runner. So type Python app that pie. We can see our program was executed 10,000 times. And we got 10,000 messages here. And here's the execution time. Now to clean this off, let's go back to our accept clause. I don't want to print this error message. So let's use the pass statement. This pass statement is a statement that doesn't do anything. And we need to use that here because we cannot have an empty except block. Okay. So save the changes. Back in the terminal. Let's run this one more time. So here's the total execution time. Now let's try a different approach. Back in our calculate X factor function. Instead of raising an exception, if age is zero or less, we can return a value like none. So I'm going to select this entire code, copy it, then paste it. Let's change this variable's name to code two in this implementation. Instead of raising an exception, we want to return none. So none is an object that represents the absence of a value. In this new implementation, we don't need a tri block. So we can simplify our code. Let's delete that as well as the accept clause on the past statement. We simply get the X factor. We can store it in a variable. So instead of handling an exception, we can compare this X factor with none. So if X factor equals none, then let's just pass. So immediately you can see this code is simpler than the previous implementation. And as you will see in a second, this will be executed almost four times faster. Let me show you. So down the bottom, I'm going to duplicate this line, change the label to second code and replace code one with code two. Save the changes back in the terminal, let's run the program. So here's the execution time of the first implementation. As you can see, our second implementation was almost four times faster. Now there is a caveat here. We see this difference when we execute this piece of code 10,000 times. So if you run the code once, you're not going to see any differences. In other words, if you're building a simple application for a few users, raising exceptions in your functions is not going to have the bad impact on the performance of your application. But if you're building an application where performance and scalability is important, then it's better to raise exceptions when you really have to. As a general rule of thumb, when you want to raise exceptions in your functions, think twice. See if you can handle the situation with a simple if statement, whether there is a performance difference or not, your code will end up being a little bit cleaner. So raise exceptions if you really have to. In this section, we're going to look at classes which are extremely important in Python programming or in programming in general. So let's start with an example. I'm going to define a list of numbers like this. Now, you have learned that when we use the doc notation, we get access to all these functions or more accurately methods in list objects. So every list object in Python has these methods. Now, wouldn't that be nice if we could create an object like shopping cart, and this object would have methods like add, remove, get total like this. Or as another example, wouldn't that be nice if we could have a point object with methods like draw, move, or get distance to get the distance between this point and another point. That's when classes come to the rescue. So a class is a blueprint for creating new objects. Throughout the course, you have heard the term class. For example, let's define a variable and set it to an integer, and then print its type. When we run this program, what do you see here? A class of int. So in Python, we have a class called int for creating integers. Similarly, we have classes for creating Booleans, lists, dictionaries, and so on. So every object that we have in Python is created using a class, which is a blueprint for creating objects of that type. In this section, you're going to learn how to create custom classes like customer, shopping cart, point, and so on. Now, before we get started, let's define a few terms. Once again, a class is a blueprint for creating new objects. An object is an instance of a class. As an example, we could have a class called human, and this class would define all the attributes of humans. Then we could create objects like John, Mary, Jack, and so on. So this is a difference between classes and objects. Now, a lot of people use these terms interchangeably, but technically a class and an object are different. So now you know what classes are and how they're useful. In the next lecture, I'm going to show you how to create a custom class in Python. All right. Now, let's see how we can create a point class in Python. So we start with a class keyword. Then we give our class a name like point. Note that here I'm using Pascal naming convention, which is different from the naming convention that we use for naming our variables and functions. To name our variables and functions, we use all lowercase letters and we separate multiple words using an underscore. But to name our classes, we use a different convention, which is called Pascal naming convention. And basically it says that the first letter of every word should be uppercase, and we shouldn't use an underscore to separate multiple words. Here is an example. We can call this class my point. You can see that the first letter of every word is uppercase and there is no underscore here. Okay. So let's change this back to point. After this, we add a colon to indicate a block. In this block, we'll define all the functions related to points. For example, we can define functions for drawing a point, for moving this point to a new location or getting the distance from this point and another point. Here's an example. We define a function called draw parentheses. Now all functions in our classes should have at least one parameter. And by convention, we call it parameter self. You will see what this is in a minute. So bear with me. Now we add our colon and let's just print the word draw on the terminal. So now we have a class or a blueprint for creating point objects. Every point object that we create will have this draw method. Let's take a look. So to create a point object, we call this class like a function. There you go. Now this returns a point object that we can assign to a variable like point. So if we use the dot operator, you can see we have the draw method as well as a bunch of other methods that we didn't define, but our point object got these methods from another object in Python through a mechanism called inheritance. We'll look at that later in this section. Now if we print type of point, now let's run this and see what we get. We get a class of main.point. This menu here is the name of our module and we're going to look at that later in this section. So this is the type function that you have seen before. We have another useful function called is instance. Sometimes we have an object and we want to know if this object is an instance of a given class. So let's see if this point object is an instance of the point class. Now let's print the result on the terminal and run our program. So obviously this point object is an instance of our point class. However, if we change this to int, obviously our point object is not an instance of the int class. So when we run this program, we get false. So this is how we create custom classes in Python. So far so good. But our point objects need some initial values like x and y. To set these values, we need a constructor and that's the topic for the next lecture. So here when we create a point object, we want to supply initial values for x and y coordinates like this one and two. To achieve this, we need a constructor, which is a special method that is called when we create a new point object. Let me show you how to create a constructor. So in our point class, we define a new function. The name of this function should be double underline in it double underline. This is a special method that we call a magic method. In Python classes, we have several magic methods and you're going to learn more about them throughout this section. So this magic method is called a constructor and is executed when we create a new point object. Now earlier, I told you that all the methods that we define in the class should have at least one parameter, which we call self by convention. You will see what this is shortly. So we add self and then optionally we add any additional parameters for initializing a point object like x and y. Now what is this self? Self is a reference to the current point object. For example, here on line nine, when we call the point class, Python will internally create a point object in memory and set self to reference that point object. Now this point object has a bunch of methods that you have seen before. For example, when we use the dot operator, you can see all the methods in this point object, but an object can also have attributes, which are basically variables that include data about that object. For example, we can have attributes like x and y that we can easily print on the terminal. In other words, a class or an object on those data and functions related to that data into one unit. Once again, as a metaphor, think of a human. A human can have attributes like eye color, height, weight, and so on, as well as functions like walk, talk, and so on. Okay. So back to our constructor, you learn that self is a reference to the current object. So we can use that to set the x and y attributes like this self.x. We can set it to some default value like zero or this x argument that we receive in this method. Similarly, let's set self.y to y. Now with this code, when we use the dot operator, look, we have the draw method as well as the two new attributes x and y. So we can simply print point.x on terminal. Let's take a look. Run this code as you can see x is one. Now back to our draw method. Here again, we have this self parameter. So using this, we have a reference to the current point object. And with that, we can read the x and y values and print them on the terminal. So here, I'm going to change this implementation and pass a formatted string like this point parentheses. Here, I want to pass self.x, then comma, and then self.y. So using self, we can read attributes of the current object or we can also call other methods in this object. Now let's change line 11 and simply call point.draw. Save the changes, run the program, and this is what we get. Now what is interesting here is that when calling the draw method, we didn't have to supply a value for the self parameter because Python does that by default. Now, technically, we could come back here and pass this point object as a reference to the current object. But this is really unnecessary and it makes our code busy or noisy. So here's what you need to take away. The methods that we define in the class should have at least one parameter, which by convention is called self. And this references the current point object that we're working with. When calling methods of an object, we never have to supply a value for this parameter. Python interpreter does that for us. So in the last lecture, we defined two attributes for our point objects in the constructor of the point class. So now whenever we create a new point object, this point object will have these attributes by default. We can also define an attribute after we create a point object. So here we can set point dot z to 10 because objects in Python are dynamic similar to JavaScript. So we don't have to define all the attributes in a constructor. We can define them later whenever we need them. Now here's what is important for you to understand. All these attributes we have defined so far, x, y, and z. These are instance attributes. In other words, these are attributes that belong to point instances or point objects. So every point object can have different values for this attribute. Here's an example. We have one point object with these values. We can create another point object with different set of values and then draw that on a terminal. When we run this, you can see we have two point objects and these are completely independent of each other. Each point has its own attributes just like John and Mary can have different eye colors. So these are instance attributes. But we can also define class attributes and these are attributes that we define at the class level and they are the same across all instances of a class. As a metaphor, we can say all humans have two eyes and two ears. So these are the attributes that we define at the class level and they are shared by all instances. So, back to our point example. Here we can define a class level attribute in the body of this class like this. Default color. Now for simplicity, I'm using a string here because we don't want to worry about using color objects. That's a different story. So now we have a class level attribute and we can read these via a class reference or an object reference. Let me show you what I mean. So here, on line 12, we have a point object. We can use this object reference to get access to the default color attribute and then print it. But we can also use the point class to get access to this attribute. Let's print both of them and run our program. So we get red and red. Now as I told you before, class attributes are shared across all instances of a class. So here, before we print the default color, if I change point the default color to let's say yellow. Note that here on line 11, I'm using a class reference so I'm not working with any point objects. I'm working with the point class. Now when we run this program, you can see that the default color of this point object is changed to yellow. Similarly, here we have another point object. If we print another dot default color, the value of this attribute is also changed. So class level attributes are shared across all instances of a class. If we change their value, the change is visible to all objects of that type. Now in practical terms, you will be using instance attributes most of the time, but there are times that you may want to define a class level attribute that is shared across all objects of a given type. In the last lecture you learn about instance versus class attributes. We have the same concept around the methods that we defined in a class. So we have instance method as well as class methods. In this example, both these methods that we have defined in the point class are instance methods. So we can call them using an instance of the point class using an object. Generally speaking, you use these instance methods whenever we need an object reference. For example, when drawing a point, we really need to work with a specific point object. That is why this draw method is defined as an instance method. But there are times that we don't really need an existing object and that's when we use a class method. For example, let's say in our program, there are a lot of cases where we want to create a point with these initial values, 0 and 0. This is one way to create a point object and that's perfectly fine, but we can come up with a different way to create a point object with these values, like this. Point, so note that I'm using a class reference, then dot 0. In this case, 0 is a method that is defined at the class level and when we call it, it will return a point object initialized with these values. So we can get this point object and assign it to this point variable. Now, in this example, we refer to this 0 method as a factory method because it's like a factory. It creates a new object. Now, this example is pretty basic creating a 0 point with this initial values is not a big deal, but there are times that initializing an object can be pretty complex. So every time you want to create an object of a given type, you might have to pass some magical values here and you might have to repeat these in several places in your program. In that case, instead of passing all these magical values to create an object, you can define the factory method that will return an object with these values and this way you can move this complexity of creating this object into that factory method. Okay, so let's delete what we have online 10 and see how we can define a method at the class level. So back to our point class, we define a method, call it 0 and call it's first parameter CLS, which is short for class. Again, this is purely convention. We can call this anything, but by convention, whenever we define a class method, we call it's first parameter CLS. And as you can guess, this is a reference to the class itself. So here we're not working with a point object or a point instance. Now, to make this method a class method, we need to decorate it with something like this. At sign class method. This is what we call a decorator and it's a way to extend the behavior of a method or a function. We'll look at decorators on how they work internally later in this section. So this is all you have to do to create a class method in Python. Now in this class method, we have a reference to our class. So with that, we can create a point object with initial values. So we call CLS and give it these initial values. This is exactly like calling point of 0 and 0. The difference is that if you use CLS, at runtime, when we call the zero method, Python interpreter will automatically pass a reference to the point class to the zero method. Okay? So we create a point object and then return it. Save the changes. Now when we run the program, we get a point with these initial values. Thread the scores I've mentioned magic methods a few times. These are the methods that have two underscores at the beginning and end of their name. And they're called automatically by Python interpreter, depending on how we use our objects and classes. For example, here we have this init magic method. You don't directly call it. It's called automatically by Python interpreter when we create a new point object. Now we have quite a few magic methods in Python. Over the next few lectures, you're going to learn about the key ones. But if you want to see the complete list, simply search for Python three magic methods. Look at this first page here. A guide to Python's magic methods. I really like this documentation. It's actually better than Python's documentation itself. On this page, we can see various magic methods in different categories with examples. For example, look at the category of representing your classes. These are the magic methods that we have in this category. The first one, stir, is a really useful one. And this is called when we try to convert an object to a string. Let me show you how it works. So back to our code, we have this point object. If we print this on the terminal, see what we get. We get the name of our module, followed by the class name and the address of this point object in memory. This is the default implementation of the stir magic method in our point object. So if we type point dot, we can see all magic methods that are available in our point object. We didn't explicitly create these methods are point object inherited them from another object. This is what we call inheritance. And you're going to learn about that soon. Now in this list, we can see we have this stir method. So by default, this returns the name of the class of this object followed by its memory address. Now let's re-implement this method to get a better result. So delete, back to our class. Let's define this stir method. So 200 scores stir 200 score. Now just like before, the first parameter should be self. But here we should simply return a string representation of this point object. So I'm going to return a formatted string. In this string, I'm going to add parenthesis. First, we add self.x. Then comma self.y. Save the changes. Now when we print this point object, this is what we get. This is very useful. We get the same result if you also try to convert a point object to a string using the stir function. So look, we get the same result. So in it and stir our examples of two useful magic methods in Python. Over the next few lectures, you're going to learn about other useful magic methods. There are times that we need to compare two objects. For example, here we have this point object. If I define another point object with the exact same values, then compare them. And print the result. What do you think we're going to get? Let's take a look. We get false. Let's go on here. The reason we get false is that by default, this equality operator compares the references or addresses of these two objects in memory. In this case, these two variables are referencing two different objects in memory. And that's why they're not equal. To solve this problem, we need a magic method. That magic method is called when we compare two objects. So back to this page. Here we have comparison magic methods. Let's take a look. So these are all the magic methods we have for comparing two objects. For example, we have EQ for testing equality. We also have NE, which is short for not equal. We have LT, which is short for less than, greater than and so on. So back to our point class. We need to define EQ magic method. On that page, we can see that this method requires two parameters, self and other. Now in this method, we need to return true if these two objects are equal otherwise false. So we can write an expression like this. Self.x equals other.x and self.y equals other.y. So if this expression is evaluated to true, these two objects are considered equal. Now let's save the changes, run our program one more time and we get true. Beautiful. Now, what if we want to compare these two point objects like this? If point is greater than other, we run the program, we get a type error because the greater than operator is not supported between instances of the point class. So to solve this problem, we need to define another magic method. So define GT, which is short for greater than. Once again, we add two parameters, self and other and write some code like this. Return. Self.x is greater than other.x and self.y is greater than other.y. Save the changes. Now let's modify this value. So I'm going to change the x and y of the first point to 10 and 20. So the first point is greater than the second point. Let's run the program, we get true. Beautiful. What if we change this to less than? Run the program, we get false. So as you see, you don't have to explicitly implement each of these operators. When you implement the greater than magic method, Python would automatically figure out what to do if you use the less than operator. We also have magic methods for performing arithmetic operations between two objects. For example, what if you want to add these two points together? When you run this program, obviously, we're going to get an error. So back in the list of magic methods, here we have numeric magic methods. In this category, if you scroll down, you can see normal arithmetic operators. So we have add, subtract, multiply, and so on. So in order to add two points together, we need to implement the add method. So define add with two parameters, self and other, we simply return a new point object with these values, self.x plus other.x. That's our first argument and then self.y plus other.y. Pretty simple, right? So let's save the changes, run the program. We get this new point object at this address. So we don't see the actual x and y values of this point object. Because in this example, I removed the stir magic method. However, if you store the result of this arithmetic operation in another object, like combine, and then print combine.x, you can see we get 11, which proves that we successfully added two points together. Earlier in the course, you learned about the common data structures in Python, you learn about lists, sets, dictionaries, and so on. These data structures or container types are pretty useful and sufficient for most cases. But there are times that you want to create your own custom container types. For example, here we have this class tag cloud. We're going to implement this from scratch together. With this class, we can keep track of the number of various tags on a block. For example, how many articles do we have that are tagged with Python or JavaScript and so on? So because this class represents a container, it supports various operations around containers. Here are a few examples. Let me create an object. Okay. Now, because this is a container, we can get the number of items in this container. We can also get an item by its key. For example, we can get the number of articles tagged with Python. We can also set that. And finally, we can iterate over this container. So for tag in cloud, we can print each tag and count. These are the operations that are supported by this custom container type. So let me show you how to implement a class like this. We create a class called a tag cloud. Now, internally, we're going to use one or more of the built-in data structures, like lists, dictionaries and so on. In this case, I'm going to use a dictionary because it allows us to quickly get the number of given tags. So first, we define a constructor, self. And in this constructor, we initialize tags attribute to an empty dictionary. Now, we can optionally add a method like add that takes a tag. Now, here we should check to see if we have this tag in our dictionary. If we don't have it, we're going to set its value to one. Otherwise, we're going to increment it by one. Here's one way to implement this logic. So self tags, we use the get method to get an item by this key and supply a default value if we don't have that. Now, we get the count incremented by one. And finally, we set the value for this key. So self, the tags of tag, we set it to this new value. Okay. Let's test our program up to this point. So, I'm going to create a cloud object and then call the add method a few times. Let's add Python three times and then print cloud tags save the changes, run the program. So in our dictionary, we have one key value pair Python set to three beautiful. Now, you might be wondering why I created a custom class instead of using a plain old dictionary. The reason for this is because I want to make this a little bit smarter than a typical dictionary. What if we add a Python tag with the capital P? Technically, this is the same tag as the lowercase Python. So when we run this program, we should see one Python tag repeated three times. Let's run the program. That's not what we get. We get two separate items. This is how a typical dictionary behaves. So in this class, I'm going to take care of case sensitivity. Whatever tag we receive here, we're going to convert it to lowercase when setting it as well as when reading it. Now, save the changes, run the program one more time. The problem is gone. Beautiful. So with this class, we're encapsulating the complexity around the case sensitivity of tags. When using this class, we no longer have to worry about lowercase or uppercase characters. So our code looks cleaner and simpler. All that complexity is encapsulated in the tag cloud class. It's not visible to the rest of our program. Okay? Now, let's take this to the next level. I want to be able to read the count of a tag like this. Using square brackets. To do this, we need to implement a magic method called getItem. So define getItem. It should take self as well as a key. In this case tag. In this method, we're going to return self the tags that get this tag. And if we don't have it, we want to return zero by default. And once again, we should convert this to lowercase. As we can see, with this implementation, we can easily get the number of a given tag. We can't do this with a typical dictionary. If we don't have the Python tag, our dictionary will throw an error. Now, let's take this to the next level. With the current implementation, we can only read the number of a given tag. We cannot set it like this. To do that, we need to implement another magic method called setItem. It's pretty straightforward. So define setItem. It takes three parameters, self, key, and value. In this case, our key is tag and our value is just count. So here, we set self the tags of tag.loader to this new count. So with this implementation, we can set the number of a given tag. Now, in order to be able to get the number of items in this tag cloud, we should implement the LEN magic method. Again, very, very easy. So define LEN takes only the self parameter. And here we return LEN of self the tags. And finally, to make this iterable, so we can iterate over it using a for loop, we need to implement another magic method. That is iter. So define it takes self. Now, all we have to do is to use one of the built-in functions to get an iterator object. An iterator object is an object that walks a container and gets one item at a time. So we call either, which is one of the built-in functions, what do we want to iterate over? In this case, self the tags. So this function returns an iterator object, which gives us one item at a time in a for loop. So we simply return it. This class that we built in the last lecture has a tiny problem. Let me show you. So here we have a cloud object. I'm going to call cloud.ad, pass Python, repeat this a couple of times and then change this to an uppercase p. Now, if we print cloud of Python all in uppercase, we get three. So our program is working. However, if I access the underlying dictionary in this class, our program is going to crash. Let's take a look. So we got an exception of type key error, because we don't have this key in our dictionary. Everything is stored as lowercase. So the problem with this class is that it gives us access to the underlying dictionary that is used to keep track of the count of tags. To fix this problem, we need to hide this attribute from the outside. So we cannot access it. How do we do this? Very easy. So back to our class. Put the cursor on this attribute and press F2. This is used for renaming objects in VS code. Now, to make this private or inaccessible from the outside, you need to prefix it with two underlines. Now, when you press enter, you're going to see an error on the bottom right corner of the screen. It's going to tell you that the refactor in library, rope, is not installed. Go ahead and install that and then try this again. Now, we can see all occurrences of self.tags is renamed to self.double underscore tags. Now, back to where we use a tag cloud object. If we use the dot operator, so cloud dot, we no longer have tags here. We also don't have double underscore tags. So if we print this, we get an exception of type attribute error, tag cloud object doesn't have this attribute. So this is how we can make certain attributes or certain methods in the class private. If we prefix them with double under squares, they're considered private. Having said that, technically, these members are still accessible from the outside. It's just a little bit harder to access them. So the point of this practice is not security. It's more of a warning or alert to someone who is using this class. It's telling the consumer of this class, hey, don't touch this. This is private. But let me show you how you can still access this. I'm going to delete all this code. Every class or every object has this property called underscore underscore dict. This is a dictionary that holds all the attributes in this class. Let's take a look. So in this class, we have this attribute called underlying tag cloud, double underlines tags. So when Python interpreter runs this code, it automatically renames this attribute and prefixes it with the name of its class. So technically, we can still access it. Let me show you. I'm going to copy this name and then print cloud dot this attribute. Let's take a look. We get an empty dictionary. So in Python, unlike languages like C sharp or Java, we don't really have the concept of private members. These private members are still accessible from the outside. Using double under squares is more of a convention to prevent accidental access of these private members. There are times that you want to have control over an attribute in a class. For example, here we have this product class in the constructor. We set the price attribute with this implementation. We can create a product object and give it a negative price. And Python interpreter will execute this without any problems. This is not good. So how can we prevent this? How can we ensure that our products don't have a negative price? Here's one simple solution. We can make this field private and then define two methods for getting and setting the value of this attribute. So we define a method called get on the line price. Here we simply return self that price. And similarly, we define set on the line price that takes a value. Now here first we check if value is less than zero, we can raise an exception of type value error saying price cannot be negative. Otherwise, we set self that price to this new value. Now in another implementation, instead of raising this exception, we could just ignore setting the value if it's negative. Now with these two methods in place, we go back to our constructor. Instead of directly setting the price attribute, we call self that set price and give it this initial value. When we run this program, our data validation logic is going to kick in and it will throw an exception. Take a look. So we got a value error because price cannot be negative. So this was a simple solution, but it's kind of ugly. It's what we consider un-pithonic. Pithonic is one of those expressions that you hear a lot in the Python community. When we say this code or this implementation is not Python, that means it's not using Python's best practices. It's not using the Python language features to the fullest potential. This implementation is the kind of code that a Java programmer learning Python writes. But in Python, we have a better way to achieve the same result. That's when we use a property. A property is an object that sits in front of an attribute and allows us to get or set the value of that attribute. Let me show you how to define a property here. So in our product class, after we define these two methods, we define a class attribute with the ideal name. In that case, we want to call that price. Here we call the built-in property function. This function takes four parameters and all these parameters are optional. The first parameter is a function for getting the value of an attribute. The second parameter is a function for setting the value of that attribute. The third parameter is a function for deleting that attribute and the last parameter is for documentation. In this case, we need to supply two arguments. The first one is going to be get price and the second is going to be set price. Note that I'm not calling these methods. I'm simply passing a reference to them. So when we call the built-in property function with these arguments, this function will return a property object that property object will use this function for reading the value of the price attribute. Now by adding this line, we can come back to our product. Let's set the initial price to 10. Here, when we use the dot operator, you can see we have this price property and we can use it like a regular field. So we can simply print it here and we see 10 on the terminal. And also, we can set it. But if you set it to a negative value, this will throw an exception. Let's run our program. There you go. Value error. So a property looks like a regular attribute from the outside, but internally it has two methods that we call a getter and a setter. Now, while this price property solves our problem, the two methods that we wrote are still accessible. So if it's our product dot, you can see we have get price and set price methods. These methods are polluting the interface of our object. As a metaphor, think of a remote control with 50 buttons. Nobody likes that kind of remote control. It's so confusing. It's much better to have a remote control with few buttons that can do a lot. We want our objects or our classes to be the same. We want them to have minimal number of functions or methods exposed to the outside. So to hide these one solution is to come back and make them private. But again, this adds extra noise in our code. There is a better, shorter and cleaner way to achieve the same result. We can use a decorator. Remember decorator earlier, we used a decorator called class method to convert an instance method to a class method. We have another decorator for creating a property. So instead of explicitly calling the property function to create a property object, we can apply the property decorator to this method. Then we renamed this method to the ideal name. In this case, we want to call it price. When Python interpreter sees this code, it will automatically create a property object called price. Now similarly, we need to apply another decorator to this method. The name of that decorator starts with the name of our property, in this case price, and then dot setter. Also, similarly, we need to rename this method to price. So our implementation is cleaner. It's less noisy. We don't have that get underlying and set underlying. This is much better. Now how this works internally is a little bit complicated, and we're going to look at that later in the future. For now, all you need to take away is that with these two decorators, we can easily create a property. Now there is one more place that we need to modify here, and that is our constructor, because we no longer have set price. But the good thing is that we can use our price property like a regular attribute. So we set self that price to price. With this new implementation, if we try to create a product with a negative price, our code will throw an exception. Let's take a look. There you go, value error. Now one last thing before finish this lecture, when defining properties, you don't always have to define a getter and a setter. In this case, if we comment out these few lines, we'll have a read only property. So we can only read the value of this price. Once we set it, we cannot change it. So we can initially set it to, let's say 10, but if we try to update it later, we'll get an exception. So if it's that product.price2.2, and run this program, we get an attribute error because we can't set that attribute. So this is all about properties. As you build various classes, you may notice that some of these classes might have one or more features or functions in common. Here's an example. I'm going to create a class called mammal. All mammals should be able to eat, right? So let's define a function called eat, and in this function, we simply print eat. Now all mammals, as far as I know, should be able to walk. So let's define another method, walk, and in this method, we print walk. Now I'm going to select all this code and hold down shift, alt, and down arrow to duplicate this class. Now let's rename this second class, fish. As we know, all fish should be able to eat, but fish don't walk. They swim. So let's change the second method to swim, as well as this message that we print. Now what is going on here? As you can see, we have repeated or duplicated the eat method in both these classes. Now in this implementation, our eat method is only a single line of code, but in a real-world program, you might have a method that is five or ten lines of code, and you might have repeated that in multiple classes. This is bad, because if there is a bug in one of these methods, you have to fix it in multiple places. Or similarly, if you need to change the behavior of this method, then again, you have to do it in multiple places. In programming, we have this concept called dry, which stands for don't repeat yourself. So we don't want to repeat ourselves. To solve this problem, we have two solutions. We can use inheritance or composition. In this lecture, we're going to look at inheritance, and I'm going to talk about composition later in this section. Inheritance is a mechanism that allows us to define the common behavior or common functions in one class, and then inherit them in other classes. Here's how it works. So I'm going to define a separate class called animal, and then move the eat method in this class, like this. Now you can see our mammal class is simpler. So to have it inherit the eat method from the animal class, we simply add parenthesis here, and then specify the animal class. This is inheritance in action. We say the mammal class is an animal, so it inherits all the features or all the methods of the animal class. In this situation, we refer to the animal class as the parent or base class, and mammal as the child or subclass. So let's go ahead and apply the same change on the fish class. We get rid of the eat method, and add animal as the base class. Now when we create a mammal object, like M, you can see this mammal has both the eat and walk methods. So let's call eat, run the program, we see this message on the terminal. So this verifies that our mammal class inherits from the animal class. Now this inheritance is not limited to methods, we can also inherit the attributes of a base class. For example, back to our animal class, I'm going to define a constructor, and in this constructor, let's set age to one. Now when we create a mammal object, our mammal object will automatically have the age attribute initialized to one. Let me show you. So back here, let's print M dot age. There you go. Run the program. Here's a result. So this is the basic of inheritance. Now in real programs, we don't build animals or mammals or fish on us for building a game, but I use this as an example because it's easier to understand the relationship between a mammal and an animal. Later in this section, I'm going to give you a real word example of inheritance in our programs. So in the last lecture, we defined this mammal object. Now let me show you a couple of useful built-in functions. We have this function is instance, and it tells us if an object is an instance of a given class. So if we pass M and mammal here, obviously this M object is an instance of mammal. So when we print the result, we should see true. What if we pass animal here? Let's run the program. We still get true because mammal inherits from animal. So an instance of the mammal class is also an animal. Now let me show you something interesting. This animal class that we defined here inherits from another class called object. Even though we didn't add that here. So we have a class called object, and that is the base class for all classes in Python. So every class that we have directly or indirectly derives from the object class. Let me show you. So let's delete this and go back to line 18. Let's see if M is an instance of object. Run the program, we get true. So mammal inherits from animal, which inherits from object. We also have this built-in function for creating an empty object. Now if we inspect this object, you can see all these magic methods. These are the magic methods that every class in Python has. So if we type M dot, you can see our mammal class or our mammal object also has these methods because it inherited them from the base object class. We have another built-in function that you might find useful in certain situations, and that is subclass. And with this, we can see if a class derives from another class. So let's see if mammal is a subclass of animal. Print the result. Obviously we get true. Now if we change animal to object, we still get true because mammal indirectly derives or inherits from the object class. In this example, our animal class has this constructor where we initialize the age attribute to one. What if we want to add a constructor to the mammal class and initialize its weight? Let's do that and see what happens. So to save time, I'm going to copy these two lines and then paste them in the mammal class. Now instead of the age attribute, I'm going to set the weight attribute to two. With this, let's print M dot age as well as M dot weight. Run the program. We got an attribute error because mammal object has no attribute age. The reason this happened was because this constructor in the animal class was not executed. In other words, this constructor that we defined in the mammal class replaced the constructor in the base class. This is what we call method overwriting. So we are overwriting or replacing a method in the base class. Now what if we still want to execute this constructor and initialize the age of an animal? That's very easy. Here in the constructor of the mammal class, we can use the built-in super function to get access to the super or base class, which is in this case, animal. So we have an access to the animal class dot. Now we can call any of the methods in this class. So let's go ahead and call the init method. Now to see the execution flow, I'm going to add a print statement here and print mammal constructor. Similarly, here in the constructor of the animal, I'm going to print animal constructor. Let's save the changes and run the program to see what happens. As you can see, first the constructor of the animal was called. So here we set the h to 1. Then the constructor of the mammal was called where we set the weight to 2. And finally we print 1 and 2, which are the results of these two statements. Now we can also change the order of this method cause. So we can call the constructor of the animal after we initialize a mammal object. So here in the mammal class, instead of calling super dot init first, we're going to do it after we do all the basic work in the mammal constructor. Let's save the changes and run the program. As you can see, the constructor of mammal was called first and then we have the constructor of the animal. So to recap, method overwriting means replacing or extending a method defined in the base class. In this implementation, we're extending the init method that we have defined in the animal class. Because here we do some work in the constructor of the mammal and then we call the constructor of the animal. If we didn't have this line here, this implementation would completely replace the init method in the animal class. So you have seen that inheritance is a good thing. It prevents code duplication and allows us to reuse code. For example, here we have this bird class that inherits from the animal. So it inherits all the features of this animal class. In this case, we are reusing the it method here. That's pretty good. However, too much of a good thing is a bad thing. And that's very true about inheritance. Because too much inheritance between classes can increase complexity and introduce various kinds of issues. Let me show you an example. Here I'm going to define a class called chicken. Well, a chicken is a bird. So we can inherit it from the bird class. And here I'm going to use the pass statement to define an empty class. So as I've told you before, pass is a statement that doesn't do anything. We just use it to make Python interpreter happy because we cannot have a class without anything in it. We need to have at least one statement. So here we have the pass class. But there is a problem in this code. What is the problem? Well, the chicken class inherits all the features of the bird class. But the chicken cannot fly. So with this implementation, I can create a chicken object and call the fly method on it. So this is an example of inheritance abuse. Another example of inheritance abuse is around the concept of employees. And I've seen that a lot in my career. So some people saying, well, an employee is a person and a person is a living creature, which is a thing blah, blah, blah. This is what we call multi-level inheritance, which can significantly increase the complexity of your software. To tell you a little story in one of my previous jobs, we had this consultant and he was charging like $150 an hour or more. And he came up with a huge inheritance hierarchy like this. In fact, three times bigger than this. There were so many levels. And he essentially tried to model the entire universe. This is really, really bad. Just because an employee is a person and a person is a living creature in the real world doesn't mean you should have classes like this in your software. The methods you add in your classes are there to solve a business problem. That is the focus of your software. So just because an animal can eat in the real world doesn't mean your animal class should also have the eat method. You got the point, right? So this is multi-level inheritance and you should avoid it at all times. If you want to use inheritance limited to one or two levels, going beyond that, trust me, you're going to shoot yourself in the food. In Python, a class can have multiple base classes. So here we have this manager class that has two base classes, employee and person. This is what we call multiple inheritance and similar to multi-level inheritance, it's a source of issues. If you don't use it properly, you're going to introduce all sorts of bugs in your programs. Let's take a look at an example. So in this employee class, we have a greet method and in this method we simply print employee greet. Our person class also has the exact same method, but here we print a different message. Now our manager class currently has no implementation, it simply inherits all the features of the person and employee classes. Now let's see what happens when we create a manager object and call the greet method. Which greet method do you think is going to get called? Let's take a look. So I'm going to define a manager and call manager dot greet. Let's run the program. We get employee greet because we added the employee class first. So when Python interpreter tries to execute this line, first it looks at the manager class to see if it has a method called greet. If it doesn't, it will look at its first base class. Does the employee have a greet method? Yes, so the lookup terminates here. If the employee class doesn't have the greet method, then it will look at the person class. So why is this an issue? Because if tomorrow another programmer joins our team and for whatever reason, they decide to change the order of these base classes, our program will have a different behavior. So if they move this person class over here and run the program, now we get a different output. So similar to multi-level inheritance, multiple inheritance can create all sorts of issues in your programs. You will end up with classes that inherit features that they shouldn't, like a chicken that flies. So if multiple inheritance is a bad thing, why does Python support it? Well, multiple inheritance is not always a bad thing. It's bad if you don't use it properly. If these classes that we have here, there are small classes and they have absolutely nothing in common and you want to inherit their features in a separate class, that's perfectly fine to use multiple inheritance. Things start to get complicated when these classes have things in common, like the greet method here. So let me show you a good example of multiple inheritance. Here we could have a class called flyer. It's any object that knows how to fly. So let's add flyer here. So it's a very simple abstract concept. Similarly, we could have another class called swimmer. It's an object that knows how to swim. Now, as you see, these two classes are very small and abstract. They have nothing in common. Now we can combine the features of these two classes so we can create a flying fish that knows how to fly and how to swim. So it's a flyer and also a swimmer. This is a good example of multiple inheritance. Now let's look at a good example of inheritance. Let's imagine we want to model the concept of a stream of data. We can read a stream of data from a file, from a network, or from the memory. All these streams have a few things in common. We can open them, we can close them, we can read data from them, but how we read data from a stream is dependent upon the type of the stream. Because reading data from a file is different from reading it from a network. So let's start by defining a base class called stream. In this class, I'm going to define methods like open and close. So define open. Now here, let's say we need a flag to know if the stream is open or not. So we can define a constructor. And in this constructor, we can set the open flag initially to false. When we call the open method, we can set this to true, like this. Now, what if we try to open a stream that is already open? That is an invalid operation. So perhaps we want to raise an exception. So we can check if self that opened, we want to raise an exception. What kind of exception? Well, we don't want to do a value error because here we are not dealing with a value. In this example, we can create a custom exception called invalid operation error. We don't have this in Python. In this case, we can create a custom exception called invalid operation error because we don't have a built-in exception in Python that represents this concept. So on the top, let's create another class invalid operation error. So by convention, all custom exceptions should end with error. Now we want to derive this from the base exception in Python. So every time you want to create a custom exception, you should derive your class from the exception class. Now, here we don't need any code. So we simply add a past statement. Back to our open method. If the stream is already open, we want to raise an invalid operation error. And here we can give a friendly message, like stream, is already open. So this is our open method. Now, let's define the close method. That's going to be very similar. So to save time, I'm going to copy these fill lines and rename this method to close. Now here we want to check if the stream is already closed. You want to raise an invalid operation error. So if not self.open, we should raise this exception and change the error message to stream is already closed. Finally, here we set open to false. So these are the common features that we need in every stream. Now let's go ahead and implement a file stream. Oops, actually I have a typo here. Sorry about that. So we define another class file stream, which inherits from our stream class. Now, as I told you before, how we read data from a file is different from how we read it from a network. So I'm going to define a method called read. And for simplicity, let's just print reading data from a file. Save the changes. Now, let's duplicate these fill lines and create a network stream class, network stream. And we should also change the message to reading data from a network. This is a good example of inheritance. Because first of all, we don't have multi-level inheritance. We only have one or two levels depending on how you want to calculate it. So we have the stream class on top of our hierarchy and below that we have two subclasses file and network stream. It's okay if we add another level of inheritance here, but we shouldn't go beyond that. Also, as you can see, we don't have multiple inheritance. So our subclasses don't have multiple parents. We're going to continue with the example from the last lecture. There are a couple of issues with this implementation. The first issue is that we can create a stream object and call the open method. Why is this an issue? Because this stream class is an abstract concept. What does it mean to open a stream? Are we working with a file stream here and network stream? What kind of stream? So we shouldn't be able to directly create an instance of the stream class. We should always subclass it and then create an instance of the subclass. That is the first issue. So we only created this stream class as a base class to provide some code that we're going to reuse across different kinds of streams. This is the first issue. Now the second issue. If you look at the implementation of file stream and network stream classes, you can see both these classes have a read method. If tomorrow we decide to create a different kind of stream, we should remember to implement this read method and call it exactly read. If we call it read line or read SDR or read whatever, it's not going to be consistent with the other kinds of streams that we have here. In other words, currently there is no way to enforce a common interface across different kinds of streams. This is more of a convention we have used here. It would be nice to have a common contract or a common interface across these different types of streams. So how can we solve these problems? That's when we use an abstract base class. An abstract base class is like a half baked cookie. It's not ready to be eaten. It's half baked. It's half cooked. Its purpose is to provide some common code to its derivatives. So here we want to make this stream class an abstract base class. To do that, we go on the top and from ABC module, which stands for abstract base class, we import the ABC class and abstract method function, which we're going to use as a decorator. So make sure to type this exactly like what you see here. So the name of the module is all lowercase and the name of the class is all uppercase. Now, to make this stream class abstract, we should derive it from the ABC class, abstract base class. Okay, that is the first step. The second step is to define the common interface for all streams. We want all streams to have a read method and potentially a write method in the future. So here we define a read method. This method has no implementation. So we simply pass here. Now we need to decorate this method with abstract method decorator. With these two simple steps, we fix both the problems I talked about in this lecture. So now, if I save the changes and try to run the program, you can see we immediately have this read on the line with abstract methods instantiated. Basically, when a class has an abstract method, it's considered an abstract class and we cannot instantiate them, which means we cannot create an instance of them. So when we run this program, we get this type error. Okay, now let's look at the second problem. So let's say tomorrow we're going to create a new kind of stream. We call it memory stream and we drive it from the stream class. For now, let's just pass and create a memory stream object. Once again, you can see we have a read on the line, abstract class with abstract methods instantiated. What's going on here? In our stream class, we defined an abstract method called read. Let's take a look. Here's our abstract method. If a class derives from the stream class, it has to implement this method. Otherwise, that class will also be considered abstract. So in this example, our new class memory stream is also abstract. If you want to make this a concrete class, so we can instantiate it, we'll have to implement the read method. So define read and here we print reading data from a memory stream. Now this memory stream is a concrete class. We can instantiate it here and it also follows the contract or the interface of the stream class. So all our streams now have a read method. So in the last lecture, you learned about abstract based classes. As another example, here I have defined an abstract based class called UI control. This class has an abstract method called draw. And as you can see, this method has no implementation. So this class only defines the contract or the interface that all its derivatives should follow. Okay. Now here we have two classes that derive from UI control. One is textbox and the other is drop down list. Both these classes implement the draw method. Here we simply print textbox and in the drop down list class, we print drop down list. So nothing new so far. Now here we also have a function called draw that takes a UI control object and calls the draw method on it. So with this, I can create a drop down list object, drop down list and pass it to this draw function like this. This should be perfectly because a drop down list is an instance of the UI control class. To verify this, let's call is instance function and pass this ddl object as well as the UI control class. And then print the result on the terminal. For now, I'm going to comment out this line. So save the changes and run the program. We get true. So a drop down list object is an instance of UI control. And that means wherever we expect a UI control object, we can pass any of its derivatives like a textbox or a drop down list. Right? So let's delete this line and call the draw function with this ddl object. What do we see? We see a drop down list. Now what if we pass a textbox to this function? Let's take a look. So I'm going to create a textbox like this and then pass it through this draw function. Run the program. This time we get textbox. I might ask, what is the point of this? Well, let's take this to the next level and make it more interesting. I want to change this draw function. So instead of getting a control object, I wanted to get a list or a topple of controls. So let's rename this to controls. And here we'll use a for loop to iterate over this controls object. So for control and controls, we call the draw method on each controller object. Now, we're going to pass a list of two objects, a drop down list and a textbox. Let's run the program and see what happens. As you probably expect, we get two messages drop down list and textbox. So using this approach, we can render the user interface of an application. Imagine we have a form with a bunch of text boxes, drop down lists, radio buttons and so on. We could have a list of all these objects and pass that list to a function like draw. And that function would take care of rendering the entire form. What is interesting here is that our draw function doesn't know what kind of control it's working with. This is determined at runtime. It simply iterates over the list of controls and calls the draw method of each controller object. This is what we call polymorphism. Polymins, many, morph means form. So polymorphism means many forms. In this example, our draw method is taken many different forms and this is determined at runtime. We could be calling the draw method on a textbox or a drop down list or a radio button and so on. So this is the classic example of polymorphism. What you saw in the last lecture was the classic example of polymorphism. So to achieve polymorphic behavior, we'll start by defining a base class. And in this class, we define the common behavior or the common methods that we need in its derivatives or children. With this, we achieve polymorphic behavior in our draw function on line 22. So depending on the type of control object that we're working with at runtime, this draw method takes a different form. It might be the draw method in a textbox or a drop down list or radio button and so on. So this is how polymorphism works in pretty much all languages that support classes. But because Python is a dynamically type language, we don't necessarily need this UI control as the base class here. In other words, if we get rid of this class, let's just delete it for now. We should also delete it from these two places. With this change, we can still achieve polymorphic behavior. Why? Here is the reason. Look at this control's parameter. Nowhere here, we have specified the type of this parameter. This is purely a label, a name. We can pass any kind of objects to this draw function. As long as that object is iterable, Python will be happy. Because here, on line 15, we are looping over that object. So that object has to be iterable. So technically, we can pass a string, a list, a tuple, a dictionary, anything that is iterable here. By the same token, that iterable object, its individual parts, should have a draw method. So Python doesn't care if these objects derive from the UI control class. As long as these objects have a draw method, Python will be happy. This is what we call duck typing. So if it walks like a duck and quacks like a duck, it is a duck. That is how Python works. Because Python is a dynamically type language and it doesn't check the type of objects. It only looks for the existence of certain methods in our objects. In other words, in this case, on line 16, it only looks for the existence of the draw method. So if this object has a draw method, Python assumes it's a UI control. It's exactly like saying, if it walks like a duck and quacks like a duck, it is a duck. So to achieve polymorphic behavior, we don't necessarily need a base class like UI control because Python supports duck typing. Having said that, having that UI control as an abstract base class is a good practice because it enforces a common interface or a common contract across all its derivatives. With this, we'll make sure that every kind of UI control will have a draw method. In Python, we can also use inheritance with the built-in types. For example, we can create a class clock text and have it inherit from the built-in string class. With this, our text class will inherit all the features of Python strings, but we can also add additional features to it. For example, we can add the ability to summarize it or duplicate it and so on. So let's define a method called duplicate that takes self and in this method, we simply return self plus self. So let me explain what's going on here. As I told you before, self represents the current object, which is in this case an instance of a string class. So here we're concatenating a string with itself. Now we can easily use our text class. So let's add Python, store the result in this variable. Look, our text object has all the methods of Python strings. So we can convert it to lowercase and print it. And here's the result. But we can also duplicate it. So when we duplicate it, we get a new string, which is Python Python. Pretty useful, right? As another example, we can also extend Python lists. So let's define a new class called a trackable list that inherits from the built-in list class. There here, I want to override the append method. So every time we want to append an object at this list, we want to print a message on the terminal, perhaps for logging. So let's print a append called. Now we want to call the append method of the super class, the base class. So we call super dot append and pass this object. So here, technically, we're extending the append method of the list class. We are not replacing it. Okay. Now we can create a list object using trackable list, call the append method. And when we run this program, you can see this message on the terminal. So as you see, extending built-in types in Python is really easy. So you have learned that we use classes to bundle data and functionality into one unit. Now, as you work on larger programs, you may come across classes that don't have any behavior. They don't have any methods. They only have data. Here's an example. We have this point class that has two attributes, X and Y. It doesn't have any methods. Now with this, we can create two point objects. So P1, we set it to point of one and two and P2, the same. Now when we compare these two objects and print the result, we get false because these two objects are stored in different locations in memory. So by default, Python compares objects based on where they're stored in memory. If two variables are referencing the same object in memory, they're considered equal. In this example, our point objects are in two different locations, even though they have the same attributes. So to prove this to you, I'm going to call this built-in ID function. This returns the address of the memory location where an object is stored. So let's look at the address of P1 and also P2. As you can see, these objects are in two different locations in memory. So to solve the issue with comparing point objects, we need to come back here and implement a magic method EQ. This method takes self and other and here we should compare self.x with other.x and self.y with other.y. Now when we compare these two objects, P1 and P2, we get true. So the problem is solved. However, writing all this code for data classes is a little bit tedious. If you're dealing with classes that have no behavior, no methods, they only have data. You can use a named topple instead. Let me show you how that works. So let's do it this. On the top, from the collections module, we should import the named topple function. We call this function. As a first argument, we specify the name for this new type we want to create. So we're going to call that point. So note that I'm passing a string here. Now as the second argument, we pass an array of field names or attribute names. We want our point objects to have two attributes x and y. So this returns a name topple that we can store here. Note that I'm using Pascal naming convention because point here represents a type like a class. So we can call it to create a new point object. However, instead of passing these arbitrary values here, we should pass keyword arguments. So we said x to 1 and y to 2. The first improvement here is that our code is more clear and less ambiguous. We don't have to wonder what are these values. Now point is a simple concept. It's easy to guess that 1 and 2 represent x and y here. But sometimes when creating objects, you might have to pass some magical values and someone else written that code. They don't know what these values represent. So these keyword arguments make our code more clear. The second benefit is that we don't have to explicitly implement a magic method to compare two objects. So if we have two point objects with the exact same attributes, we can easily compare them and we get the result that we expect. So if you're working with classes that have only data and no method, you might want to use a name topple instead. You will write less code. And these name topples are better than regular topples because here we'll have attributes in this point object just like the attributes we have in our classes. So if we print p1.x, we see one. Just be aware that these name topples are immutable, which means once we create them, we cannot modify them. We cannot mutate them. So if I set p1.x to a new value and run the program, we get an attribute error because we can set an attribute of a name topple after we initialize it. So if you really need to modify one of these values, you need to create a new point object. So we set p1 to a new point with x set to 10 and y set to 2. So this is all about name topples. So far we have written all our code in one file app.py. But that's not how we build real programs because a real program can contain tens of thousands of lines of code. We don't want to write all that code in one file. That is like going to a supermarket without any sections. All products are in one place. Finding a product in a supermarket like that is really hard, right? That's why in supermarkets we have various aisles or sections or departments. We have the same concept in programming. So as our program grows, we should split our code across multiple files. If you refer to each file, a module. So a module is a file that contains some Python code. Now here's a question. How do we decide what functions or what classes we should put in what modules? Once again, let's go back to a supermarket example. In a supermarket, each section contains highly related products. So when you go to the fruit section, you only see fruits. You don't see cleaning products there, right? By the same token, a module should contain highly related objects. These objects can be functions, classes, variables, and so on. So here, as an example, I have defined two functions. These functions have no implementation, but they are both highly related to the concept of sales. We have calculate tax and calculate shipping. So let's go ahead and put these functions in a separate module called sales. Here in the project folder, I'm going to add a new file and call it sales.py. This is our sales module. Note that in terms of naming convention, just like variables and functions, we use all lowercase letters. And if you have multiple words, we separate them using an underscore. Now, back to app.py. Let's get all this code and move it to sales module. Okay, now back to the app module. We need to import one or two functions from our sales module. There are a couple of different ways to achieve this. You have seen one way before. So we start with from, then we add the name of our module, which is sales. Note that it's not sales.py. It's only the name of the file. Okay, so from sales import. Now, if you press control and space here, you can see all the objects defined in this module. Currently, we have these two functions, as well as a bunch of variables that Python automatically creates. We'll look at this later. So let's say you want to import the calculate shipping function. There you go. Now we can call this function just like a function that we have defined in our app module. So calculate shipping. As simple as that. Now, if you want to import multiple objects from a module, you can separate them using a comma. So here we can also import calculate tags and then call it here. Now, there are some tutorials out there that teach you a shortcut to import multiple objects using an asterisk. While this makes your code shorter, it's actually a bad practice because in that module, you could have several different functions or variables. And if you blindly import them into the current module, some of those objects may overwrite the objects with the same name in the current module. So don't import all objects like this. Only import the stuff that you need. So let's put calculate shipping and calculate tags here. There is also another way to import a module. Instead of starting with from, we start with import. And then we add the name of the module. Now, in this module, we have an object called sales. And we can use the dot operator to access its members. So our calculate shipping function is now a method in this object. And we call it like this. So basically, you can either import the entire module as an object or you can import specific objects from that module. What approach you choose is purely your personal preference. There is no right or wrong here. There is not even a performance difference because whenever we want to import one object from a module, that entire module needs to be loaded. Now we can pick one object or every object in that module. So these are the files or modules we currently have in this folder. We have app.py, which is our main module or the entry point to our program, as well as the sales module. Now, whenever on this program, you will see a new folder here. So pythonapp.py. There you go. We have this new folder.py cache. And in this folder, we have the compiled version of the modules that we import into our program. So currently, we have the compiled version of the sales module. The reason python stores these compiled files in this folder is to speed up module loading. So next time we run our program, python will look at the content of this folder. And if we do have the compiled version of the sales module, python will simply load that compiled version. So it will skip that compilation step. And this will result in faster loading of the sales module. Note that it only speeds up the loading of this module, not the actual performance of the application. Now how does python know if this compiled version is up to date with the latest code in the sales module? Well, it basically checks the daytime of these two files, the compiled version, as well as the source code. If the daytime of this source file is newer, it realizes that our source code is changed. So it will recompile it and store it in this pie cache folder. So that's the basic idea. Now this see python 37 you see in the file name here represents the python implementation used to compile this file. So we have compiled this file using see python version 3.7. In this file, we have python bytecode. Let me quickly show you. So when we click this, by default, VS code doesn't show the content of this file because it's binary. But if we click this link here, we can see the python bytecode representation of our sales module. Now back to this pie cache folder. Note that we don't have the compiled version of the app module, because python always recompiles the module that we load directly from the command line. So in this demo, I passed app.py as the entry point to python. And that's the reason python didn't cache the compiled version of this module. So here in app.py, I'm currently importing the sales module. When python sees this, it will look for a file called sales.py in the current directory. If it doesn't find this file, it will look in a bunch of predefined directories that come with python installation. Let me show you. So we have a built-in module called path. Let's import that. In this module, we have a variable path, which returns the list of directories that python will look at to find a module. Let's print this on the terminal. So as you see, we get an array of strings. The first element in this array represents the current folder. So on my machine, that is, Moshvik, Hamadani, Slash Dropbox, Courses, Python, blah, blah, blah. On your machine is going to be different. After that, we have library frameworks, Python framework version 3.7, dah, dah, dah, dah, dah. Again, this is going to be different on your machine, depending on your operating system. I'm using Mac. So this is the address of Python installation on Mac OS. On Windows, you're probably going to get something like C drive, backslash program files, Python, blah, blah. So when Python sees an import statement, it will search all these directories to find this module. As soon as it finds the module, the search stops there. Now you might be curious how we can import a module from a sub directory. Well, to do that, we need to look at packages, and that's the topic for the next lecture. Currently, all our files or modules are in this folder. But as our application grows, we probably want to organize this files into sub directories. Otherwise, we'll end up with hundreds or even thousands of Python files or Python modules in one folder. That is not good. So in this demo, I want to move the sales module to a sub directory called e-commerce. So I'm going to add a new sub directory, e-commerce, and then drag and drop this module right here. Now back to app.py. You can see we have a red underlying here, because Python cannot find the sales module. To fix this issue, we should come back to our e-commerce folder and add a new file called double underscore in it double underscore dot pi. When we add this file here, Python would treat the e-commerce folder as a package. So a package is a container for one or more modules. In file system terms, a package is mapped to a directory, and a module is mapped to a file. So now we can go back to app.py and prefix the name of this module with the name of its package. That is e-commerce.sales. Save the changes, the error is gone. Now to use any of the objects in the sales module, we need to prefix them with the name of their package and modules. So e-commerce.sales.calculate tags. Obviously, this is going to make our code a little bit noisy, because every time we want to use one of the objects in the sales module, we'll have to type e-commerce.sales.s. That is tedious. A better approach is to use the from statement. So we change this to from e-commerce.sales, import, calculate tags. Now we can simply call this function, like a function defined in app module. That is better, but what if we want to use multiple objects in the sales module? Well, we can list them all here, but if that ends up being too noisy, we can take a different approach. So we can type from e-commerce, import, sales. So we're importing the sales module as an object, and then we can use the dot operator to access all the members of this module. As your programs grow, you may want to break down a package into sub packages. For example, let's imagine our e-commerce package has grown a lot. We have so many files and modules here, so we decide to break this package into a few sub packages. So I'm going to add a new folder here, call it shopping, and then move the sales module in this folder. So on the top, we have the e-commerce package, and under that we have the shopping package. Currently shopping is not a package because in this folder we don't have the init file. So let's add a new file, double underscore init, double underscore.py. Now back to app.py. Once again, Python cannot find our sales module. So to fix this issue, we need to add the name of our new sub package here. So e-commerce dot shopping. There are times that you want to import modules from sibling packages. For example, here in our e-commerce package, I've added a new sub package customer. In this package, we have this contact module for contacting our customers. Now let's say in our sales module, you want to use the contact module in the customer package. Let me show you how to do this. So we open this. To import a module from another package, we can use an absolute or relative import statement. So here's an absolute import. From our top level package is e-commerce. So we start there, then we go to the customer sub package, and now we import the contact module. So this contact object has a method we can use anywhere in this module. So this is the absolute import. We can also use a relative import. So from dot, this represents the current package. Dot dot takes us one level up. So now we are at the e-commerce package level. In this package, we have two sub packages, customer and shopping. So we can go to the customer sub package and then import the contact module. As a best practice, prefer to use absolute imports. And that's what PEP 8 also recommends. But if your absolute import gets really verbose like a dot b dot c dot d dot e, then you might be able to simplify the import statement by using a relative import. In this lecture, we're going to look at a powerful built-in function called DUR. With this function, we can get the list of attributes and methods defined in an object. So in this example, we're importing the sales module. As you learned earlier, now sales is an object. So we can use the dot operator to access all the methods and attributes defined in this object. As you work on large projects, there are times that things don't work as you expect. So we can use the DUR function for debugging. Let me show you. So let's print DUR of sales. Then we run this program. We get an array of strings. In this array, we have all the attributes and methods defined in an object. So as you see in our sales module, we have these two functions, calculate shipping and tax, as well as these magic attributes that are automatically created for us. Let's take a look at a few of these. So I'm going to comment out this line and print sales dot name. That returns the name of our module. We can also get the name of the package. As well as the file name, as well as the address of its file. So let's run this program. So here is the name of our module. As you can see, it's fully qualified with the name of its packages. After that, we have the name of our package. So the sales module is defined in e-commerce, the shopping package. And below that, we have the pass to this file and file system. Here in our sales module, currently we have defined two functions. But we can also write any statements and these statements will be executed. The first time this module is loaded. So if we import this module in a few different modules in our program, Python will load this module only once and then cache it in memory. So the statements that we write here will be executed once. As an example, let's print something like sales initialized. Now let's go back to our app module. To quickly look up a file, you can press command and P on Mac or control and P on Windows. Here we can type after pie. There we are. Now when we run this program, we can see our sales module is initialized. Using the same technique, we can write the initialization code for our packages. So once again, command and P on Mac or control and P on Windows, we can go to the init file for the e-commerce package and print e-commerce initialized. Now let's go to our app module. Run the program again. As you see, first our e-commerce package and then the sales module are initialized. Now let's take this to the next level. Let's go to our sales module and print the name of this module. So as you learn in the last lecture, every module has a built-in name attribute that is automatically created for us. So save the changes back to app module. Let's run our program. So as you see, here is the name of our module that is e-commerce that's shopping that sells. However, if we go to sales.py and run this file, the name of our module is changed to main. So the name of the module that starts our program is always main. Now we can do something interesting. Let me show you. So I'm going to delete this initialization code on the top. After we define this function, I'm going to write some code like this. If name equals main with two underscores, I'm going to print sales started and then call the calculate tax function. With this code, we can make this file usable as a script, as well as a reusable module that we can import into another module. So if we run this file directly, the name of this module will be main. And here we can have any initialization code or we can call one of the existing functions in this module. However, if we import this module into another module, this code will not be executed because at that point, the name of this module will no longer be main. It will be e-commerce that's shopping that sells. Python has a batteries included philosophy, which means it comes with a comprehensive library of packages and modules that provide common features that we need when building real applications. So in this section, we're going to explore Python standard library. More specifically, you're going to learn how to work with files and directories, SQL like databases, data and time objects, generate random values, send emails and so on. As you go through this section, don't worry about memorizing anything. Just try to get an idea what is where and what you can do. You can always come back to this section and treat it as a reference. For example, if in the future you want to generate random values, you can come back and watch the corresponding lecture. With all that, let's get started. Over the next few lectures, you're going to learn how to work with files and directories in Python. In this lecture, we're going to look at the past class because that's the foundation to work with files and directories. So from the past lip module, let's import the past class. Now we can create a past object in a few different ways. We can create an absolute pass. For example, if you're on Windows, you can create a past object like this. C drive, backslash, program files, backslash, Microsoft or whatever. Now when working with a long path, these double backslash just get a little bit ugly so we can simplify this by using a raw string. In a raw string, backslash is not an escape character. It's taken literally as is. So you prefix this with an R. Now we have a raw string so we can get rid of this second backslash like this. Now if you're on Mac or Linux, you can create an absolute pass like this, slash user, slash local, slash bin. We can also create a past object that represents the current folder or we can use a relative path here. So current folder, let's go to the e-commerce sub folder and then pick in it that pie. We can also combine past objects together. For example, we can have one past object and then using a slash combine it with another path or we can also combine a past object with a string. So here we can have a string and then again we can combine this with another string. We can also get the home directory of the current user. So this past class has a class method called home that returns the home directory of the current user. So these are various ways to create a path object. In this demo, I'm going to use what we have online six. So let's delete the rest and store the result here. Now this past object has quite a few useful members and in this lecture, I'm going to show you the most important ones. But if you want to see the comprehensive list, simply search for Python 3 pathlib. On this page, we can see all the members of the past class. So with this past object, we can call the exist method to see if this file or directory exists or not. To check to see if this past represents a file we call is file, we also have is directory. We can also extract individual components in this past, which is extremely useful. For example, let's print path.name. So this returns only the file name in this path. We also have path.stam, which returns the file name without the extension. If you want to get the extension, you can access the suffix attribute. So this returns dot pi. We can also get the parent of this path. So pass dot parent. And this returns the parent folder e-commerce. Now here we have a couple other useful methods that I really like. One of them is with name. So pass dot with name. And we can use this to create a new past object based on this existing past, but only change the name and the extension of the file. So if I pass, let's say file.txt, we get a new past object here. Now let's print this. So this returns e-commerce slash file.txt. We can also get the absolute value of this past. So pass dot absolute. Let's run the program. So here's the absolute value of this file. Obviously, this file doesn't exist yet. They're only representing its path. Now similar to this with name, we have another method with suffix. And we use that to change the extension of a file. So with suffix. And here I'm going to pass dot txt. Now let's simply print this path. So we get e-commerce slash in it the txt. Note that here we have not renamed the file. We're only representing a path object. Over the next couple lectures, I will show you how to rename files and directories. So these are the important members of the past class that you should know. In the next lecture, we'll look at working with directories. So here we have a past object that represents directory. A few useful methods that you need to be aware of are exists that returns a Boolean MKDuer to create this directory. RMDuer to remove it. And rename to rename it to a new name. Let's say e-commerce to that. These are pretty self-explanatory. So in this lecture, we're not going to look at these. Instead, we're going to look at another method that is either Duer with this method. We can get the list of files and directories in this path. So let's print the result and see what we get. We get a generator object. Remember generator object? A generator object, as the name implies, returns a new value every time we iterate it. So when we're working with a large list of items, instead of storing all those items in the memory, we use a generator object. We iterate it and get a new value every time. This is more efficient. So that's the reason this method returns a generator object. Because when working with files and directories, it is possible that we can have a directory with a million files in it. So now we can iterate over this, let's say, for P and then print P. Let's run the program. So on my machine, I have one file and three directories at this path. As you can see, this method returns both the files and directories. Now, if you're working with a directory that doesn't have a million files in it, you can convert this generator to a list using a list comprehension expression. So instead of iterating over this generator, we can use a list comprehension, which is pretty similar to what we have here. We add the square brackets and at P here. So P for P in paths that are iterative. Now we get all these paths and we can print them. Let's see what we get. We get an array of POSIX Path Objects. What is this? Well, this pass class that we imported on the top, this is the base class for two different classes, POSIX Paths and Windows Paths. POSIX is the standard use in Unix-like operating systems. So because I'm using a Mac, here we have a list of POSIX Path Objects. If you're on Windows, you see a list of Windows Path Objects. Now here we can take this comprehension expression to the next level and apply Filtery. Let's say we only want to get the directories. So if P dot is DUR, you learn about this method in the last lecture, right? Let's run the program. So here are the three directories that we have inside of the e-commerce directory. Okay? So this method is pretty useful to get the list of files and directories in a path, but it has two limitations. One is that we cannot search by a pattern and second is that it doesn't search recursively. So for those scenarios, you need to use a different method. That is glob. Let me show you. So path dot glob, this method takes a pattern. So we can search for all files or let's say all PIFiles. Similar to the other method, this returns a generator. So we can use it in expression like this. P for P in path dot glob. Now we get the PIFiles. Let's print them here. So in this directory, I have only a single PIFile. Now to search recursively, we need to change this pattern to something like this. The other option is to use the R-Glob method. So we remove the pattern and use R-Glob, short for recursive glob. Now when we run this program, we get all the PIFiles in the e-commerce directory and all its children. In this lecture, you're going to learn about the useful methods to work with files. So here we have a pass object that references a file. We can check to see if this file exists. We can rename it to, let's say in it, dot txt. We can delete it by calling the on-link method. We also have the stat method that returns information about this file. So let me comment out this for your Lions and look at what this method returns. We get a stat result object with these attributes. For example, SD-Online Size returns the size of this file in bytes. We can also get the last access time, the last modified time, and the creation time. Now all these time values are in seconds after Epic, which is the start of time on a computer. And that is platform dependent. For example, on Unix systems, the Epic time is January 1st, 1970. So to print the human readable time on the top, from the time module, we need to import the C time function. Now from this stat object, we can pick SD-Online C time, that is the creation time, and then pass it to the C time function. Let's run this program. So this is the creation time of this file. We also have a couple methods for reading data from a file. So pass the read bytes, which returns the content of the file as a bytes object for representing binary data. We also have read text, which returns the content of the file as a string. So we can simply print the result here. And this is the content of my Python. Now using this method is easier than the built-in open function that I have mentioned throughout the course. With the open function, we'll have to specify the file name. Let's say in it that pi, then we need to specify the mode. Now this returns a file object. So we're going to make sure to close it. So as a best practice, we should use the width statement, then get the file object like this, and then do something with it. In contrast, let me use read text. All this magic happens inside of this method. So we no longer have to worry about opening a file, closing it, and so on. Similar to read text and read bytes, we have write text. So we can call it to write some textual data to a file or pass the write bytes. Again, both these methods take care of opening and closing a file. So with this pass object, we can do all kinds of operations with a file. However, when it comes to copying a file, this path object is not the ideal way to copy a file. Let me show you. So I'm going to comment on this for your lines. Let's say we want to copy this file to a different location. So I'm going to rename this path to source, then I'm going to create a target path, which would be let's say the current directory plus in it that pi. Now to copy this file, we'll have to write code like this. First, we need to read the content of the source. So read text, then we need to write it to the target. So target that write text like this. It's a little bit tedious. There is a better way. We have a module called SHUTIL or Shell Utilities, and this module provides a number of high level operations for copying and moving files and directories. So on the top, let's import SHUTIL. Now with this module, we can easily copy source to target. This approach is cleaner and easier than using a path object. In this next slide, you're going to learn how to work with zip files in Python. So from the zip file module, let's import the zip file class. Now we create a zip file object. Let's call that files that zip. Then as the second argument we pass, W short for right, because we're going to write to the zip file. So this statement will create this file in our current folder. Let's get a reference to the zip file and store it here, or we could call it zip that is shorter. Now let's say we want to get all the files in this e-commerce directory and write them to the zip file. That is pretty easy. So we create a path object to reference the e-commerce directory and then call our glob method to recursively find all the files in this directory and all its trimmer. As you know, this returns a generator. So we iterate over it for pass in and then call zip that right pass. And finally we should call the close method. Now if something goes wrong here, chances are the statement may not be called. So we should either use a trifinally block or the width statement, which is shorter and cleaner. So with this zip file as zip, now we indent everything here and then we don't need to call the close method. Let's save the changes and run this program. Now we have a zip file here, files.zip. So let's go ahead and read its content. So back in app.py, I'm going to comment out these few lines. This time we're going to create a zip file that is files.zip, but we're not going to open this in the right mode because we only want to read from it. So this object has a method called name list, which returns the list of all the files in this zip file. So let's print this list around the program. So these are all the files we have in this zip file. We can get information about any of these files. For example, let me copy this here. Then call zip that get info and pass the address of this file. This returns an info object. From this we can print info. file on the line size. We also have info.compress size. Let's look at the result. So in this case, we don't have compression because we're dealing with a really simple file. Now finally to extract all the files from the zip file, we call zip.extract all and optional in specify a different directory to extract to. So here let's extract this into this extract directory. Now here we have this extract directory with the content of the e-commerce directory that we compressed into a zip file. In this lecture, you're going to learn how to work with CSV files in Python. In case you don't know, CSV stands for common separated value and it's like a simplified spreadsheet stored as a plain text file. So on the top, we import the CSV module. First we need to open a file. So for this, we need to use the built-in open function. We cannot use the past class. So open. Let's call this file data.csv. Now we want to open this in the right mode because we want to write data to it. This returns a file object. So when we are done, we should make sure to close it or as I told you before, a better approach is to use the width statement. So width open as file. Now we don't need to close the file. That is better. So this CSV module has a method for creating a CSV writer. Recall this and pass our file object. So look at the first parameter here. It has to be a file object. That's why we cannot use the past class. So we pass the file object here and this gives us a CSV writer. And with this, we can simply write tabular data to our CSV file. So writer. That write row. Here we pass an array of values. So for the first row, I want to add the headings of this table of data. So let's say we're going to have three columns, transaction ID, product ID, and price. And one more time, writer, that write row, we pass an array of data. So let's say transaction ID is 1000, product ID is one and price is $5. We can duplicate this, write another row with different data. Now I want to save the changes and run this program. Okay. So here in our project folder, we have data that CSV. As you can see, this is like a simplified spreadsheet. So we have a table of data, each line represents a row, and our cells are separated using a comma. This is a very simple way to store data and transfer it from one machine to another. Now let me show you how to read a CSV file. So let's say we have a CSV file called data.csv. Now we should open this file in the read mode. So we don't want to supply this second argument. Next, instead of a CSV writer, we need a CSV reader. So let's call the reader method and rename this variable to reader. Now we can call the list function to get all the data in the CSV file and convert it to a list object. Let's take a look. So run the program. As you see, we get a list of lists. So each line in our CSV file is a list of objects. Note that the value of each cell is represented as a string, even if you're dealing with a number. So we have to manually convert these strings to integers, floats, and so on. We can also iterate over this reader object because it's iterable. So for row in reader, let's print row. Run the program. Now we don't see anything here. We only see the output of line 5 where we convert this reader to a list object. So what happened to these two lines? Well, this reader object has an index or position that is initially set to the beginning of the file. When we convert this reader to a list, that position goes to the end of the file. So at that point, when we iterate over it, we are already at the end of the file. And that is why we cannot iterate this reader twice. So let me comment out line 5 and run the program one more time. There you go. Now we have three rows. Each row is an array of strings. So as you see, working with CSV files is pretty easy in Python. With these objects, we can do some interesting things. For example, let's say we have a directory of 100 or 1000 CSV files. We can iterate this directory, open its CSV file, and remove the first row, which is the header row. Or perhaps we want to combine these CSV files into one file. We can easily do that here. Another interesting thing we can do is to summarize the value of these CSV files. Let's say we have 10 CSV files and each CSV file represents the transactions for a given product. With only a few lines of code, we can read all these CSV files and calculate the sum of sales for each product and then store the result in another CSV file. The possibilities are endless. In this lecture, you're going to learn how to work with JSON files in Python. JSON stands for JavaScript object notation and it's a popular way to format data in a human readable way. These days, it's very important to know JSON because a lot of popular websites like Facebook, Twitter, Yelp, YouTube, and so on provide their data in JSON format. Also, if you have a website, you can provide your data in JSON format. Let me show you how to work with JSON files. On the top, we import the JSON module. Now let's create an array of movie objects. So movies with Senate run array. Each item in this array is going to be a dictionary because each movie object has properties like ID, title, year, and so on. Each movie object is essentially a collection of key value pairs. So let's add a dictionary. The first key is ID. We map that to one. The second is title. We map that to Terminator. The third is year and we map that to let's say 1989. Now let's add another object. Change the ID to two. Title to Kindergarten, Cop, and year to 1993. So here we have a movie's object. Now we can call JSON the dumps. Pass this movie's object here and get a string that includes our movie's data formatted as JSON. Let's take a look. So data, we print it on a terminal. There you go. So this is an example of JSON data. Now in this case, what you see here happens to be identical to the syntax that we use to define an array of dictionaries in Python. But this is not the case when working with other languages. Now, back here. So we have this data variable, which is a simple string. Now we can write it to a file. So on the top, from the past lib module, let's import the past class. Then instead of printing this on the terminal, we're going to create a past object. Let's say movies that JSON. And then call, write, takes on it, and pass this data string. Let's run this program. Okay. Now here in our project folder, we have movies that JSON. Beautiful. So you learn how to write data to a JSON file. Now let's imagine we get this JSON file from somewhere else. This could be the data we get from Facebook, Twitter, IMDB, Yelp, YouTube, and so on. So we should be able to read this data in Python back to app.py. I'm going to delete this movies array as well as the line where we dump it to a JSON string. So we start with this file, movies that JSON, and read all its text, and store it in this variable. So now data is a string that includes data formatted as JSON. Next, we need to parse this string into an array of objects. So we call JSON that loads, past this string here, and this will return an array of dictionaries. Let's call that movies and print it on the terminal. So this is the movies array that we had earlier. An array of dictionaries. So we can simply get any items in this array. Here's the first movie. Now we have a dictionary. Using square brackets, we can get the value of any of these keys. For example, let's get the title of the first movie around the program. We get Terminator. So this is all about working with JSON files in Python. In this lecture, you're going to learn how to work with SQLite in Python. SQLite is a very lightweight database that we use for storing data of an application. It's often the technology of choice for smaller applications like the apps that we run on phones and tablets. So it allows us to easily store our data in a structured format like a table of rows and columns. So let's start by importing the SQLite 3 module. Now in the last lecture, we created this movies that JSON file. So let's go ahead read all the movies from this JSON file and store them in our SQLite database. So back in app.py, we should also import the JSON module and from the past-lip module, we should import the past class. Now we create a past object to load movies.json file, read all its content. This will give us a string. So we can pass that to JSON.loads. And this will give us the list of movies. Now before going any further, let's print this movies object and see if everything is working up to this point. So let's run the application. Beautiful. So we have a list of dictionaries. All right. Now we want to store this list in a database. So this SQLite object has a method called connect. We passed an M of our database file here. Let's call it DB that SQLite 3. We could call it anything. It doesn't matter. Now if this file doesn't exist, this method will create it for us. So it will return a connection object. This connection object, similar to files, should be closed when we are done with it. So a better approach is to use the width statement and then get the connection here. Next we need to create a command. This command is basically the instruction we send to the database for creating data, updating data, deleting it, and so on. Quite often we use a language called SQL that is beyond the scope of this course. So if you're not familiar with it, don't worry. It's pretty easy to learn. In fact, it's far easier than Python. So here's an example. I'm going to create a command and set it to your string like this. Insert into movies. So I'm assuming we have a table called movies where we store all our movies. Then we add values, parenthesis. And in parenthesis, I add three question marks separated by a comma. So these question marks are placeholders for the values that we're going to supply in the next step. So our table of movies will have three columns, ID, title, and year. So next, we need to iterate over our movies list. That is pretty easy for movie in movies. Now we need to execute this command. So we use our connection object. This has a method called execute. As the first argument we pass our command and as the second argument, we need to pass the actual values. So each movie object in this for loop is a dictionary. It has key value pairs like ID, title, and year. All we want here is the actual values. So we call movie.values. Now we need to get these values and put them in a topple. So we use the built in topple function like this. So here we're iterating over our movies for each movie we execute this command. When we're done, we should call connection.comit. At this point, all these changes will be written to the database. Let's save the changes. Now if we run this program, we're going to get an error. Let me show you. So there you go. Operational error, no such table movies. Because here we're dealing with an empty database, this database doesn't have any tables. So we need to create the movies table first. Here on Google, if you search for DB browser for SQLite, you will find this website, SQLitebrowser.org. On this website, you can find an application to open a SQLite database and look at its content. As you can see on the right side, we have executables for various operating systems. So go ahead and download the right executable for your operating system. When you open DB browser, you're going to see something like this. So on the top, let's go to open database. Here in our project directory, let's open our database file. There you go. So as you see, we don't have any tables here. Let's go ahead and create a table. We're going to call that movies. And then we need to add three fields or three columns to it. So add field, the first one is ID. The type of this column should be integer. And we're going to mark this as primary key, which means we're going to use the value of this column as a unique identifier for each movie. You want to make sure each movie has a unique ID. Okay. Now let's add another field. We're going to call that title. The type of this column should be text. And finally another field, we're going to call that here. Once again, the type of this is going to be integer because here we're going to store values like 1984. So this is how we create a table. As we can see, that's pretty easy. Let's go ahead. Okay. Now in the list of tables we have this movie's table. If you expand it, you can see all its columns looks like I made a mistake here. So the name of my third column is field three not here. So let's select the table, go to modify table here. And then we're name this column or field two here. Now press tab to make sure that the changes are applied. By the way, we also have this column here. If we take these check boxes, we're telling SQLite that the data in this column cannot be known. In other words, we cannot have a movie without a title or without a year. So it's better to check this as well. We don't have to check not known for the ID field because when we select a column as the primary key, SQLite will make sure that every row will have a value for that column. All right, let's go ahead. Okay. We're almost done. Now we need to click right changes. Beautiful. So back to our program. Let's run it one more time. Okay, this time we didn't get an error. So back to DB browser. Now if you select the movies table and go to browse data, you can see both our movies ended up here. They're stored in a structured format. So we have a table with columns and rows. It's beautiful. Now let me show you how to read data from this database. So we don't need line five anymore because we're done with this JSON file. To read data from a database, first we need to connect to it. So we're going to keep line five, but we're going to change line six. So instead of inserting a movie into the movies table, we're going to select all the movies. The command that we should write is select star from movies. Now we don't need to iterate over the movies object. We simply need to execute this command. So connection that execute we passed the command and this will return a cursor. So when we read data from a database, we'll get a cursor. Let's store that here. A cursor is an iterable object. So we can iterate over it and get one row at a time for row in cursor. Let's simply print row and we don't need connection.com it because we only need this when writing data to a database. So delete save the changes run the program. You can see in each iteration, we get a topple of the values for a row in our database. We also have this method. So cursor dot fetch all that will return all the rows in this table in one go. So here we'll get a list. Let's call that movies and then print it on the terminal. Now if you run this, we're not going to get any result because after we iterate over this cursor, we'll get to the end of the cursor. So we won't be able to read it again. So I'm going to comment out these two lines, save the changes and run the program. Now as you see, we get a list of topples. So this is the basics are working with SQLite databases in Python. As I told you before, when working with databases, you should also be familiar with the SQL programming language. That is beyond the scope of this course, but there are plenty of tutorials online and it's really easy to learn. Over the next few lectures, you're going to learn how to work with data and time in Python. Basically, we have two modules for working with data and time. One is the time module, which gives us a timestamp and the other is daytime, which gives us daytime objects with attributes like year, month, and so on. In this lecture, we're going to look at the time module and we'll look at the daytime module next. So this time module has a method called time that returns the current daytime as a timestamp. Let me show you. So print, the result. This is what we get. This floating point number represents the number of seconds from the beginning of time. No, I'm not talking about big bank here. That is the beginning of time on your operating system on Unix that is January 1st, 1970 on Windows. Honestly, I'm not sure. So this floating point number you see here is the number of seconds after January 1st, 1970, which is referred to as Unix Epic Time. As you can see, these timestamps are not human readable, so we use them to perform calculations. Here is an example. I'm going to define a function to simulate sending an email to 10,000 recipients. So send emails. Let's just do a for loop for i in range 10,000. I'm going to do a pass here. Now, we're going to call this function, but before calling that, we're going to call time the time to get the current time stored here. And one more time after we send the emails. So time the time that is the end time. Now we set duration to end minus start. Let's print the result duration. So this is the amount of time it took to execute this function. Now, earlier in the course, I also talked about the time it module. We can also use that to calculate the execution time of some piece of code. Both approaches are perfectly fine. So as you learn more about Python or any other program in languages, you will realize that there are multiple ways to solve a problem. So these are timestamps in Python. Next, we'll look at daytime objects. And this lecture, you're going to learn how to work with daytime objects in Python. So on the top, let's import the daytime module. This module has a class called daytime. There are a few different ways to create a daytime object. Here's one way. We can pass the year, the month, and the day. And optionally, we can pass the hour, minute, and second as well. So this returns a daytime object. Let's call that DT. Now, what I don't like about this code that you see in a lot of tutorials is this daytime dot daytime. That is just ugly. It is better to import the daytime class from this module. So from daytime, let's import daytime. Now, we can create a daytime object like this. This is especially important if you're creating multiple daytime objects. You don't want to repeat daytime dot daytime. So this is one way to create a daytime object. We can also call daytime dot now. So this is a method defined in the daytime class. And this returns the current daytime. We also have daytime dot STR P time. That is for parsing or converting a daytime string. This is particularly useful when we get input from the user or read it from a file. In both these scenarios, we're dealing with strings. So our daytime values are represented as strings. And we need to convert them to daytime objects. So let's say we have a string like 2018, 01, 01. Now, we need to tell Python how to parse or how to convert this string into a daytime object. So we need to tell it what parts represent the year, the months, and the date. For that, we use directives. So as the second argument, we pass a format string that includes the directives that specify various components of this daytime string. So we use a percent capital Y to represent a four digit year. Then we have a slash percent lowercase M to represent a two digit months and percent D to represent a two digit day. We also have directives for hour, minutes, and second. Now, don't worry about memorizing any of these. We can always find this in the documentation. So if you search for Python 3, SDR P time on this page, down the bottom, we have this table of directives. So you can see various directives and their meaning. So as an example, here we have this percent with a capital Y which represents a four digit year. If you use a lowercase Y that represents a two digit year. Okay. Now back here, so this method returns a daytime object and we can store it here. We can also convert a timestamp into a daytime object. So on the top, let me import the time module. We call time the time. Let's say we have this timestamp somewhere in our program. Perhaps we read it from a file. Now we want to convert it to a daytime object. So this daytime class has another class method called from timestamp. You can pass this timestamp here. This returns a daytime object. So we store it here and now let's print it to see what we get. So this is the current daytime on my machine. So these are a few different ways to create a daytime object. Now our daytime object has attributes like year, month, day, and so on. So we can print a formatted string like this. dt.year slash dt.month. Let's run this program. There you go. So 2018 slash 11. We also have a method for formatting daytime. So dt.strf time. This method is the opposite of strp time. So with this method, we convert a string into a daytime object. With strf time, we convert a daytime object into a string. So we need to specify our directives here. Let's say percent y slash percent m. Now let's print the result. We get the exact same output. We can also convert daytime objects. For example, let's change this variable to dt1 and this one to dt2. We can see if dt2 is greater than dt1. Let's run the program. Obviously that is true because today is November 21st. So this is all about daytime objects. Next we'll look at time delta, which represents a duration. In the last lecture you'll learn about daytime objects, these objects represent a point in time. In the daytime module, we also have a class called time delta, which represents a duration. So let's import time delta from here. Now when we subtract these two dates, we get a time delta object. So let's add duration to dt2 minus dt1 and print it on the terminal. So here is the difference between these two date times. Now this time delta object has a few interesting attributes. We have duration that days. Let's print that on the terminal and add a label for clarity. We also have seconds. Let's take a look and run the program. So we have 324 days and 46,000 seconds. So this 46,000 represents this value. 12 hours and 58 minutes is equivalent to 46,000 seconds. We also have a method called total seconds. This is a method not an attribute. Let's see what this returns. So this value you see here is the total duration represented as seconds. So if we calculate the number of seconds in 324 days and 12 hours and 59 minutes, we get this value. So these are a few interesting members of the time delta class. Now in case you're wondering why we don't have months or year here, the reason is that we can have a varying amount of time in a month or in a year. That's why we only have days, seconds and microseconds. Now we can also add a time delta object to a date time object. Let me show you. So for our first day time, I'm going to add a time delta a one day. Now if we print DT1, we get January the second and the difference is 323 days. However, someone else looking at this code may not be quite sure what this one here represents. Is it one day, one hour, one second? So it's better to use keyword arguments here for clarity. We said days to one. We can also set seconds to a thousand. Now let's run the program. So that gives us 16 minutes after January the second. It is like sure you're going to learn how to generate random values in Python. So on the top we import the random module. This module has a method called random that generates a random value between 0 and 1. So let's print that and see the result. So we get a floating point number. Every time we run this program, we get a different value. Now we also have another method, random int that generates a random integer between two numbers. Let's say one and 10. So we get 10. Now we get two, eight and so on. We have another super useful method called choice that takes an array, let's say an array of numbers and randomly picks one of the items in this array. So let's run this program. We get three. Now we get two, three, three, four, and so on. Now we have a similar method choices that selects multiple values from this array. So here as the second argument, after this array, we need to supply a keyword argument that is K. We set it to two and this returns two random items from our original array. Now with this choices method, we can generate a random password. Let me show you. So let's duplicate this line, set K to four. Let's say we want a password of four characters. Now instead of an array, we should pass a string. So a, b, c, d, e, f, g, h, i, whatever. Basically, we can pass any sequence to this method and it will pick four items from that sequence. Now when we run this program, we get an array of four characters picked from this string here. Let's run the program one more time. Now we get different characters. There you go. So to generate a password, we should combine all these items in this array into a string. To do that, we create an empty a string and call the join method on it and this will join all the items in an array using an empty a string as a separator. So when we run the program, we get a string instead of an array. Now if we use a comma in this string, that comma will be used as the separator when joining the items of this array. So let's run the program one more time. See what we get? You don't want that. We want an empty string. Now the only issue we have here is the limited choice of characters. Now one way is to type all the lowercase and uppercase as well as digits, but that is tedious. There is a better way. We have this string module. Let's import that. This module has a few interesting attributes. Let's print, string, that ASCII letters. This returns a string that includes all the lowercase and uppercase letters. We also have ASCII lowercase, uppercase, as well as digits. Take a look. So we get all the numbers from zero to nine. Now instead of passing a string here, we can pass string dot ASCII letters plus string dot digits. So let's run the program one more time. And here's our random password. Every time we run this program, we get a different password. We also have another useful method for shuffling an array. So let's say we have an array of numbers one, two, three, four. We can call random that shuffle and pass this array here. Now when we print this, the order of these items are randomly changed. So let's run the program. We get four, one, three, two. Let's run it again. We get two, one, three, four. So this is how we can generate random values in Python. In this lecture, you're going to learn how to open a web browser in a Python script. This is particularly useful if you're building an automation script that does a bunch of tasks. And at the end, you want to open up a browser window. For example, let's say you're building a script to deploy your website. So you build your website locally on your development machine. When you're done, you want to run this script to deploy to a web server. At the end, you will have to open a browser window, type the address of your website and press enter. This is manual and we can automate it. So you can have your Python script open up a web browser at the end of deployment. So here, let's print deployment completed. Now to open a web browser, we need to import the web browser module. This module has this method called Open. We simply pass the URL of the target website. Let's say google.com. Now when we run this program, we see this message here and a browser window opens pointing to google.com. So we don't have to manually type this. In this tutorial, you're going to learn how to send emails in Python. This is particularly useful if you have a database of customers and you want to send them various emails based on their interests. So let me show you how to send emails in Python. Basically, we need to import a couple of classes, want to create email messages and the other to connect with an SMTP server for sending emails. So from email.mime.multipart, we should import the mime.multipart class. What is going on here? So basically, we have this email package in Python standard library. In this package, we have a sub package called mine. Mine stands for multipurpose internet mail extensions. And this is a standard that defines the format for email messages. It says nothing to do with Python is purely a standard for defining the format of emails. In this package, we have another sub package that is multipart that exposes a class called mine.multipart. With this object, we can send an email message that includes both HTML and plain text content. So when the email client of the receiver received this email message, if it supports HTML, it will render the HTML content. Otherwise, it will render plain text content. So now let's go ahead and create a mime.multipart object. Some mime.multipart. We store it here in message. Now we need to set various headers. Some message. We use square brackets to set from. I'm going to set that to mosh.amadanim. Similarly, we set to. Let's send that to test user at code with mosh.com. Next, we need to set the subject. So let's say this is a test. So these are various headers supported by mine.multipart objects. But we don't have a header called body. So to set the body, we need to attach it to this message. So this message object has a method called attach that gets a payload. This payload can be text, image, or other types supported by the mime protocol. So on the top, from email.mime.txt module, we need to import the mime.txt class. Now to set the body of this message, we need to create a mime.txt object, some mime.txt, and include our text here. So let's say body. The by default, you can see the value of the second parameter is set to plain, which refers to plain text. If you want to pass HTML content, we should set this to HTML and pass an actual HTML text here, but I'm going to leave that to the next lecture. So for now, let's just send plain text content. So here we have a mail message object. Now we need to send this using an SMTP server. So on the top, let's import the SMTP lib module. This module has a class called SMTP. But here we need to pass two keyword arguments. The first one is host. I'm going to set that to SMTP.gmail.com and port to 587. The values we set here depends on the SMTP server we use. Now this returns an SMTP object. When we're done with it, we should make sure to close it to release this resource. So I would prefer to use the width statement and get that SMTP object here. All right, now there are a few steps that we need to follow before we send an email. First, we need to call SMTP.hello. Well, this is spelled differently, but this is a hello message or greeting to the SMTP server. Basically, we're telling the SMTP server, hey, I'm a client, I want to send an email. And this is part of the SMTP protocol. So the communication between a client and an SMTP server should start with the hello message. Next, we need to call SMTP.startTLS. And this puts the SMTP connection in TLS mode. TLS stands for transport layer security. With this, all the comments that we sent to the SMTP server would be encrypted. Now, we're ready to login. So we call SMTP.login. We pass our user and password here. So test user at codewithmosh.com. And the password is today, sky is blue, one, two, three, four. Don't try this because I'm going to delete this email account after recording this video. All right, and finally, we call SMTP.send message and pass our email message object. That's all we have to do. Now for confirmation, let's print, set, save the changes. I'm going to go ahead and run this program. So our email message was sent successfully, beautiful. In a real world application, various things could go wrong. So make sure to handle exceptions using a tribe lock. Now here on my email client, you can see I've got a message with the right subject and body. Let's take this to the next level. I want to attach an image to this message. So here on line nine, just like how we attach text to this message, we can also attach image on the top. From email.mime.image, we need to import the mine image class. Now here in this directory, I put a picture of myself, mosh.png. So after line 10, I'm going to call message.attach, create a mine image object. Here we need to pass our image data in binary. So we need to import our pass class from passlib.let's import the pass class. Now we create a pass object and load mosh.png. As you learn before, this has method read bytes. So this returns all the data in a file in binary. Now let's save the changes, send this one more time. Okay, send now back to my email client. You see I got a second message and here's a picture of me. In the last lecture, we added the body of our email right here. But that's not how we build real applications. Because in real application, the body of an email can be several lines of text. We don't want to write all that text here. Quite often, we put that text in a separate file as a template. And we use HTML to build that template. HTML is the language of the web. That's the language that we use to build web pages. We use it to present content. Like if you're not familiar with HTML, don't worry. There are plenty of tutorials online. You can learn it on your own. Just follow along with me and see how we can create templates in Python. So in a project folder, I'm going to add a new file and call it template.html. Now in a real application, we often have different templates for different scenarios, such as when a user signs up or attempts to reset their password or places in order, these are various scenarios. So we need different templates for these scenarios. And we should name our template files based on those scenarios. In this demo, I'm just going to go with a simple name like template that HTML. Now let me show you a cool technique to quickly generate some HTML code. We type an exclamation mark and press tap. So now we have a basic HTML template. When sending emails, we don't need anything in the head section. So let's delete all this. In the body, I'm going to type something like this. High user, this is our test email. Now what if you want to dynamically replace this with the name of the recipient? So let's define a parameter that we can replace later. To define a parameter, we start with a dollar sign and then give that parameter a name. For example, name. Now let's save the changes. Beautiful. Back to our app.py. Here on the top, from the string module, we need to import the template class. We use this class to replace these parameters in a template string. Let me show you how that works. So back to app.py. Let's create a template object. Here we need to pass our template as a string. So I'm going to create a path object to load template that HTML. Here we call read text. This returns the entire content of this file as a string. Now we have a template object. This template object has a method called substitute. With this method, we can replace parameters dynamically. Let me show you how that works. So let's delete this line. Where we're attaching the body of this message. Instead of hard coding, this body here, let's call template that substitute. Now here we can pass a dictionary that contains key value pairs for parameters in our template or we could pass keyword arguments. Now to make this code a little bit cleaner, let me put this on a separate line. So let's call that here, pass a dictionary. In this dictionary, we should have a key called name. And let's set that to john. This substitute method will return a string. So let's call that body. And then we pass it here. And finally, we change plane to HTML. Save the changes. Round the program. Okay, beautiful. And here's our new email message. Hi, john. This is our test email. Now this email message is pretty simple. It doesn't use any of the features of HTML. So let's go back to our template and make the name of the user bold. So here in our template file, I'm going to add a strong tag around the name parameter. This will make the name of the user bold. Save the changes back to app.py. Let's run the program one more time. Okay, now here we get a new email. And as you can see, the name of the user is bold. So this is the benefit of using HTML over plain text. Now back to the substitute method. As I told you, you can pass a dictionary. So you might have a dictionary that includes all the values that you want to replace dynamically. If that's the case, pass a dictionary object here alternatively, you can pass keyword arguments here. So instead of passing a dictionary, we can pass the keyword argument name equals john exactly the same. So this is all about templates in Python. You might want to create a Python program that expects command line arguments, just like this Python program itself that receives the name of our Python file as an argument. Now we can extend this, take it to the next level and supply additional arguments here. These arguments can be the name of a user, their email, their password, whatever. So on the top, we import the sys module. This module has an attribute called a rgv short for argument variables. So let's print that on the terminal. Now back on the terminal, let's execute this command. We get an array of four items. The first item is always the name of our Python program. So even if we don't supply any arguments, we'll get an array of one item. After that, we have all these arguments represented as separate items. With this, we can do something interesting like this. We can get the length of this array. And if it equals to one, that means the user has not supplied any arguments. Because as I told you, this array always has at least one item. And that is the name of our file. So we can print a usage message like Python 3 after applying. And after that, we expect a password. Otherwise, assuming that the user has supplied this argument, we can read it like this password equals sys.argv01. And then we can print it on the terminal like this. Back on the terminal, let's run Python 3 after applying. We get the usage message beautiful. Now if you pass one to three four, that will be considered the password. In this tutorial, you're going to learn how to call external programs from your Python scripts. This is particularly useful as part of an automation script. For example, let's say you want your Python program to run the LS command and capture the output. On Mac and Linux, this command lists the files and directories in the current directory. This is equivalent to the DIR or DIR command on Windows. So in this lecture, you're going to learn how to run any of the operating system commands as well as external programs. For example, you can have your Python script execute another Python script. For that, we need to run Python 3. Let's say other dot pi. So let me show you how to achieve this on the top, we import the sub process module with this module. We can spawn a child process. A process is basically an instance of a running program. So with this module, we can run other programs. Now in this module, we have a bunch of functions or methods like call, check call, check output, and so on. All these methods are helper methods to create an instance of the P open class process open. Now these methods have been around for a long time and they're kind of considered legacy. There is a newer method and that is the preferred approach to create an instance of the P open class. That method is called run. So if you look at other tutorials or courses and they talk about these methods, remember there is a better approach. So don't waste your time on these methods. Now let's see how we can use the run method to run an external program. The first argument of this method is an array of strings. Here is an example. Let's say we want to run the LS command. So we add that here. Now if you want to supply any arguments to this command, we add them as items in this array. So let's say LS-L, which gives us a detailed view of the files and directories in the current directory. Let me show you. So LS-L. Here's what we get. We get the name of the file, its creation date, size, the owner, and so on. So let's save the changes and run this program. As you can see, our program executed LS-L command and this is the output printed on the terminal window. Now let's look at the return value of this method. So let's call that result and print its type. Run the program again. So what we get is an instance of this class. Subprocess that completed process. So let's rename this variable to completed. Now look at the attributes of this object. We have args, return code, standard error and standard output. Let's inspect each of these attributes. So I'm going to print this also. For clarity, I would like to add a label. After that, let's print, return code, and change the label accordingly. Next, let's print standard error, standard error, and finally standard output. So SDD out. Let's run the program and see what we get. So args is an array that includes the command that we executed. Return code is zero, which means success. Any non-zero values indicates an error. Now in this case, because we don't have any errors, standard error is non. Otherwise, we would have an error message here. And standard output is also non, because we are not capturing the output. The output is automatically printed on the terminal window. Sometimes we want to read the output of another program and do something with it. Perhaps we want to save it to a file. So let me show you how to do that. This run method takes quite a few keyword arguments and all of these have default values. The one we're going to use now is capture output. If we set this to true, when we run this program, the output will not be printed on the terminal. It will be available in this attribute, standard output. Let's take a look. So save the changes. I'm going to comment out this line and run the program. So look, we don't see the list of files and directories here. The output is available in this attribute. So let's print that and see what we get. There you go. Now note that this string is prefixed with B, which represents a binary object, to convert this to a string, we need to pass another argument to the run method. So I'm going to break this down into multiple lines for clarity. Let's set text to true. Now when we run this program, we no longer see that B prefix. So here we have a regular string object. Now we can print this on the terminal window or save it to a file. As another example here, let's run another Python script. So I'm going to create a separate file here. Let's call that other dot pi. Let's say this is a complicated Python script that we want to call as part of running our main script. So for now, let's just print. Here is a complicated script. Now back to app dot pi, we can simply run this script as a child process. So instead of LS, we want to execute Python or Python 3. And as the argument, we pass other dot pi. Save the changes, run the program. So as you see, the other script was executed and here's the output that we captured. Now note that here I'm executing this other Python script as a child process. So it's going to be in a completely different memory space. This is different from importing that script and executing it here. So these two scripts will be in two different processes and they will not share the same variables. So this is the basic of running child processes. And one last thing before we finish this lecture. Earlier, I told you that any non-zero return code indicates an error. So let's take a look at a real example. We have this command called false. I'm not the intern sure if this is available on Windows or not. But if you're a Windows user and this doesn't work on your machine, please pair with me. So let's run this program and see what happens. As you see, our return code is one because this false program always exits with one as the return code to indicate an error. Now it's our job to check for this error. So one way is to check if completed that return code is not zero. Then perhaps you want to print completed dot standard error. The other approach is to pass another keyword argument here. Check. We said this to true. When we do that, if there is an error, this method will automatically raise an exception. Let's take a look. So I'm going to run this program one more time. As you can see, we have an exception of type called process error. And this class is defined in this subprocess module. We just changed. We don't have to check for errors like this. So we can wrap this code in a tribe block. And then add the accept clause. The exception we want to capture is subprocess.called process error. We can get the exception in this object and then simply print it on the terminal. So this is all about running external programs in your Python scripts. In the last section, we explored Python standard library. Now, even though this library is very comprehensive, it doesn't have everything that we potentially need when building a real application. There are times that we need features not implemented in Python standard library. That's where PiPI or Python package index comes into picture. PiPI is like NPM or node package manager for JavaScript developers. It's basically a repository of Python packages built by people like UNI. So if you head over to pipe.org, on this page, you can see that currently we have almost 160,000 projects registered in this repository for pretty much anything you imagine. There is a Python package here. Let's say you want to work with PDF files in your application. Simply search for PDF here. As you can see, currently we have over 2,000 projects for working with PDF files. Here are a few examples. This first package is a two-dimensional barcode generator. We also have this package for managing and processing PDF files. The next one is for converting a PDF file to text. We can also convert a PDF to image and so on. So we have tons and tons of packages for working with PDF files. Of course, not all of these are useful. Some of them are buggy or incomplete, but if you do a little bit of research, you can find a good and stable package for your projects. Alternatively, you can also Google the best Python packages for working with PDF files and see what other people in the community say. So in this section, you're going to learn about all the tooling you need to install these packages and publish your own packages to this repository. Are you excited? All right. Now let's get started. To install a package from PyPI, we use a tool called PIP. If you're on Mac, similar to Python, you should use PIP3. Now with this tool, we can do various things, such as installing packages, uninstalling them, upgrading them, or listing the currently installed packages. Let's take a look at a few examples. So here to install a package, as the first argument we pass install, and as the second argument, we specify the name of the target package. So here I'm going to install this requests package, which we're going to use to send HTTP requests. So let's go ahead. All right. This is successfully installed. But here down the bottom, we have a warning in yellow that is saying you're using PIP version 10. However, version 18 is available. So this version 10 is the version that came with my Python installation. But because PIP is developed independently, we need to upgrade it from time to time. So right below that, you can see the command that you need to run upgrade PIP. That is PIP install dash dash upgrade PIP. All right. Now I have the latest version of PIP. Let's look at the packages that are currently installed on my machine. So PIP list. Here in this list, you can see we have installed the version 2.20.1 of the requests package. This version you see here is what we call semantic versioning. The first number represents the major version. The second number represents the minor version and the third number represents the patches or bug fixes. Now back on pipi.org, let's search for the requests package. So here we have a few packages with a similar name. We've got requests, requests 3, and requests 2. And they're not always in the same order. So make sure to pick the requests package without 2 or 3. Now on this page, on the left side, you can see the release history of this package. So the latest version that I've installed is 2.20.1 at the time of recording this video. There are times that you want to install an earlier version. Perhaps the latest version has a bug or is incompatible with the other packages you are referencing. So let me show you how to install an earlier version. So back on the terminal, let's say we want to install version 2.9.0. That is very easy. Just like before pip, install, requests. Now we add 2 equal signs followed by the version 2.9.0. So as we can see, this successfully uninstalled the latest version that was version 2.20.1 and then installed version 2.9.0. Now here we can also use wildcards, for example, pip, install, requests, equal 2.9 point asterisk. That means install the latest compatible version with version 2.9. So if there are any patches or bug fixes, include those as well. Now here on pip.org, you can see we have 3 2.9 versions. This is the base version and then we got a couple more versions before version 2.10. So when I run this command, people will install the latest compatible version with 2.9.0, which is 2.9.2. Let's take a look. Now we got this message, requirement, already satisfied, because we already have version 2.9.0 installed. So first we need to uninstall it before we install the latest compatible version with this. So that is very easy. Pip, this time we're going to use uninstall and then requests. We don't care about the version. This is asking for confirmation, so let's go ahead. Now requests version 2.9.0 is uninstalled. So now let's install requests version 2.9 point asterisk. This will install the latest compatible version with 2.9. We also have another syntax for installing the latest compatible version. So instead of two equal signs, we use a tilde equal sign and then here we specify a specific version. Let's say 2.9.0. Once again, this will install the latest compatible version with 2.9.0, which is 2.9.2. Now we can use this asterisk with a minor version as well. For example, let me uninstall this first. So pip, uninstall, requests. Okay, let's go ahead. Good. Now pip, install, requests, 2.9 asterisk. This will install the latest compatible version with version 2. So back to the release history. If you scroll to the very top, you can see the latest compatible version with version 2 is 2.20.1. Let's go ahead and run this. There you go. So with successfully installed, requests 2.20.1. Now we can use this package just like the modules in Python standard library. So we import requests. Now we have a module object with these members. You can read about these on the documentation for this package. So back on pip.org, here on the page for the requests package, if you scroll down, you can see a link to the documentation. Now back to our code, I'm going to call the get method. Let's send an HTTP request to google.com. This returns a response for now. Let's simply print the response on the terminal. Let's run the program. So we got a response with the status 200, which indicates success. In the last lecture, you learned how to install a package using pip. Now let's run pip, list. You can see currently we have installed requests version 2.20.1. There is a problem here. Let's say we have another project and in that project, we want to use an earlier version of this package. With the current structure, we cannot have two versions of any of these packages side by side. We can have only a single version. To solve this problem, we need to create an isolated virtual environment for each application and install these dependencies into that virtual isolated environment. Let me show you how to do that. So here in the project folder, we run Python, dash m vn, and then specify the name of a directory for containing this virtual environment. By convention, we call that nth. Now don't worry about memorizing any of these because later, I'm going to show you a better and simpler way. So technically, you're never going to execute this command after I show you the latest tools. I'm just going to take you on a step by step journey. So you understand exactly how these various tools come together. So let's go ahead and run this command. Good. Now here on the file explorer panel, you can see we have a new directory. And in this directory, we have this config file. With this parameters, home is referencing the directory where my Python interpreter is installed. And here's the version of that interpreter. So I'm using c python version 3.7. We also have this bin or binary directory where we have a bunch of tools like pip, pip three, Python, Python three, and so on. Next to that, we have include, which is currently empty. We have lib. Instead of this directory, we have Python 3.7. And instead of that, we have site packages. Now this directory structure is slightly different on windows. So if you're a windows user, don't get hung up on this subtle differences, focus on the big picture. What matters here is that this site packages directory is where we'll install the packages for this application. So a virtual directory is an isolated environment where we have a specific Python interpreter. In this case, see Python version 3.7, as well as a bunch of packages that this application needs. Okay, now that we have a virtual environment, we need to activate it. Here in the bin folder, we have a script called activate. We need to run this from the terminal. So back in the terminal, if you're on windows, you execute the script directly. So you reference it like this. And backslash bin backslash activate that back. If you're on mac or Linux, you will have to type source and slash bin slash activate. There you go. Now we can see the name of the currently active virtual environment. In this case, that is n. We could call this anything, but by convention, we use n. So now that we are in the virtual environment for this application, let's go ahead and install an earlier version of requests package. So pip install requests 2.9 point asterisk. So as you can see, we have installed requests version 2.9.2, which is different from the request package that we installed globally on this machine. This is specific to this application. Now back to our directory structure. Now under the site packages directory, we have this new directory requests. This is where we have installed the request package for this application. Finally, whenever we're done, we need to deactivate this virtual environment. So we run deactivate. Done. So you have learned about pip and creating virtual environments. As you have noticed, using these tools requires memorizing various commands and arguments. There is a lot to remember. That's where pip and comes in the picture. Pip and is a tool that combines pip and virtual environments into a single tool chain. So we don't have to use pip or virtual environments separately. If you're familiar with NPM or Node Package Manager, pip and is the equivalent tool in the Python work. So it's a dependency manager for Python projects. Now you might be curious why I didn't start this section with pip and because as I told you, pip and internally uses pip and virtual environments. So you need to understand how exactly it works under the hood. Also, as you look at various websites, you will come across pip or virtual environments. So I wanted to make sure that these tools are not foreign to you. Now let me show you how to use pip and here on the terminal, first we need to install it. So pip install pip and all right. Now back to VS Code, I'm going to delete this end directory because we don't need it anymore. We're going to use pip and to automatically create a virtual directory. So delete, good. Now back to the terminal. Instead of using pip to install a package, we use pip and so pip and install requests. Now a few things happen here. This tool created a couple of files, pip file and pip file.loc. We'll look at this later. It also created a virtual environment for us and installed this request package inside of that virtual environment. But that virtual environment is not here. Where is it? Let me show you. So here on the terminal, let's run pip and dash dash vn. This is the path to our virtual environment directory. As you can tell, this directory is not part of our project and this is a deliberate decision because as we install various packages, we'll end up with hundreds or even thousands of files in this virtual environment and this will increase the size of our project. So we want to exclude this virtual environment from our project directory. Now I'm going to uninstall the request package that we installed globally using pip. So pip uninstall requests. Let's proceed. Good. So we installed a dependency using pip and now let's run our application. But for this demo, I'm not going to use code runner. You will see why in a second. So let's run pip on app.py. We got a module not found error. No module named requests because we removed the requests package from the list of global packages. And here Python doesn't know where to locate this package. It has no knowledge of this new virtual environment. So we need to activate it. Once again, we use the same tool that is pip and as the first argument we pass shell. So as you can see, it's activated the virtual environment for this project. Now let's run our program one more time. We got a response. Beautiful. So Python could successfully locate the request package. So here we're currently in the virtual environment for this project. If you want to deactivate it, simply type exit. Now we are outside of the virtual environment. So in the last lecture, I didn't run this program using the code runner. I used the terminal. Now let's see what happens when we run this program using the code runner extension. So there you go. We get the same error. No module named requests because code runner is running this program using the Python interpreter that is installed globally. And that Python interpreter cannot find the request module to fix this problem. We need to tell code runner to use the Python interpreter in our virtual environment. So back in the terminal, let's find the virtual environment directory for this project. pip and dash dash v. And there you go. Now let's open this. So this is our director structure that you have seen before here in this virtual environment inside of the bin folder. We've got Python 3. If you're on Windows, you have Python. So we need to get the past this Python interpreter and give it to the code runner extension. Back in VS code on the top. Let's go to the code menu, then preferences and settings. Here click this dot dot dot and open settings that JSON. Now if you scroll down somewhere here, you should see code runner that executor map. We said this earlier in the course. In case you missed that step, simply add a new key value pair here. The key is code dash runner dot executor map. When you press enter, it automatically generates all these settings. Now here we have the past to Python. As you can see, I've changed this to Python 3. Now we need to replace this with the past to the Python interpreter in a virtual environment. So this is the past to our virtual environment. Let's copy this and back to user settings and replace this with this slash bin slash. So we're referencing the Python interpreter in our virtual environment. Let's save the changes back to app.py. Let's run this program using the code runner extension. There you go. So we fixed the issue with code runner, but we have a red on the line here, unable to import requests. So VS code cannot find a request module. To fix this problem, we need to tell VS code which Python interpreter to use. Now if you look at this status bar here, you can see Python 3.7. Click this. In this list, you should see various Python interpreters. Now look at the last one here. This is the past to the Python interpreter in our virtual environment. If you don't see this on your machine, you need to go back to the user settings page. And add a new setting. That is Python dot Python pass. We set this to the past to the Python interpreter in a virtual environment. So let's paste the past to the virtual environment. Then slash bin slash Python 3. Now after we add this, we need to restart VS code. Then when we go back to app.py here in the list of virtual environments, you should see this new Python interpreter. So let's select this. We can see the compilation error is gone, but we got this other error. Linter pilot is not installed because earlier we installed this globally. And now it's not available in this isolated virtual environment. So we need to go ahead and install it here. All right, the error is gone. Let me install a package using pipn two files get automatically created. pip file and pip file dot lock. These two files are used to keep track of the dependencies of our project and their version. Let's take a look. So first I'm going to open up pip file. Here we have four sections. The first one is source that specifies the address of the repository where these packages are downloaded from below. Now we have dev or development packages. These are the packages that we use as part of our development, such as packages that we use for automated testing. They're only used during development. So they don't have to exist for our application to run. Below that, we've got the packages that our application is dependent on. In this case, we're dependent on the request package. And this asterisk you see here, because we didn't specify a version when installing this package. This asterisk means the latest version. If you specify the version that would end up here. And finally below that, we've got requires that specifies the version of Python we need to run this application. So this is our pip file. Now let's look at pip file dot lock. This is a JSON file that lists the dependencies of our application and their exact version. Let me show you. So here on the top, we've got this section called meta. Don't worry about that. Below that, we have default and instead of the default, we've got all the dependencies of our application and their exact version. Here's the first one, certify. Now we didn't explicitly install this package. This is one of the dependencies of the requests package. So all the packages that we installed and their dependencies and their dependencies are listed and this file. So the version that is installed on my machine is this version. Now if you scroll down, you can find the requests package. And here's the version that is installed on my machine. Now with all the information stored in this file, we can take our source code, put it on another machine like a production environment and reproduce this exact execution environment. And this minimizes or eliminates the situation where your application runs on your machine, but doesn't run on another machine because there is a different version of one of these dependencies on that machine. Now let me show you this workflow in action. So here on the terminal, let's find the virtual environment for this project. pip n dash dash v n. Okay, here's the directory. I'm going to delete this directory to simulate the scenario where we copy our project onto another machine. On that machine, this virtual environment does not exist. All we have is the source code of our application. Right? So on Mac or Linux, we can delete a directory by running rm dash rf and then the path to that directory. Delete. So now if you run pip n dash dash v n one more time, it tells us that no virtual environment has been created for this project yet. All we have is this source code and our pip files that specify the dependencies of our application. Right? So now we need to install all these dependencies and that is very easy. We run pip n install without any additional arguments. When we run this command, pip n, we'll look at our pip file and install all the dependencies of our application. All right. Now let's run pip n dash dash v n. We can see we have this virtual environment and in this virtual environment, we've got all the dependencies of this project. Now these dependencies are installed based on the version specified here. So for the request package, we're asking for the very latest version. However, on my machine, at the time of development, I've been using version 2.20.1. So chances are in the future, when we put this project on a different machine and install the dependencies, we might have a newer version of the request package. In that case, those dependencies installed on that machine will be different from the dependencies on my development machine. If you want to install the exact same versions listed here, you should tell pip n to ignore the pip file and use pip file.lock. So back on the terminal, we run pip n install and then supply an additional parameter, dash dash ignore dash pip file. As we can see, this time pip n installed the dependencies from pip file.lock. So you have learned the basics of pip n. Now let's take a look at a few useful commands for managing the dependencies of our application. We can run pip n graph to see the list of all the installed dependencies. So currently we have installed requests version 2.20.1 and below that you can see the dependencies of the request package itself. In front of each dependency, you can see the version that was required by the requests package, as well as the version that is installed on our machine. Now let's uninstall the requests package. So pip n uninstall requests. So the request package is gone. If you look at the pip file, it's not here anymore. Also, if we run pip n graph, it's gone. However, the dependencies of the request package are still here because pip n doesn't know if these dependencies are used somewhere in our application or not. However, if we take this project, put it on a different machine and install all these dependencies from scratch, these packages will not end up there because currently we have not referenced them in our pip file. Now let's install an earlier version of the requests package. So pip n install requests version 2.9.0.0.0.0.0.0. All right, now in our pip file, you can see we have the request package with the version that we have requested. And if you look at pip file.loc, you can see the actual version that is installed. That is 2.9.2. Now to find the outdated packages, we can run pip n update dash dash update it. We get this yellow warning skip update of package requests. So this is the version that we have installed. As you can see, there is a newer version available, but pip n won't be able to install that because in our pip file, we ask for the most recent version compatible with 2.9. So 2.2. It may not be compatible with 2.9. So let's go to our pip file. Let's change this to 2.asterisk. So we are asking for the latest compatible version with version 2. Now let's run this command one more time. This time we don't see the yellow warning anymore. Package requests is out of date. This is the version that is installed and this is the version that is available. Now we have two choices. We can update this package for all packages in our project. To update all packages, we're on pip n update and to update a specific package, we add its name here. So requests. Okay, now all our dependencies are up to date. So if you look at pip file.log, you can see that we have requests version 2.20.1. And similarly, if we run pip n graph, you can see that we have installed the latest version of the requests package. In this lecture, I'm going to show you how to publish your own packages to pipi.org. The first step is to create a new account. So pause the video, create a new account, make sure to activate it by clicking on the link that they send you and then come back continue watching. Mix here on the terminal, we need to install three tools globally. So pip or pip3, install, setup tools, wheel and twine. You will see these in action momentarily. So let's go ahead. All right. Now I'm going to start with a brand new project. Let's say we're going to create a package to work with PDF files. So I'm going to create a new directory, call it mosh pdf. Now let's go to this directory and open VS code. Now as a best practice, we should create a high level directory with the same name as our package. So I'm going to call that mosh pdf. Here potentially we could have another directory for unit tests. We're going to look at unit tests in the future. Perhaps we could have another top level directory for some sample data and so on. All our source code will end up here. Now in this directory, we should add an init file. So Python will see this as a package. Now let's add a couple of modules. So I'm going to add a new file, call that pdf to text.py. Here I'm going to write a basic function like convert. So convert that simply prints pdf to text. Okay. I got this error message. Formatter AutoPap 8 is not installed. I realized that VS code is still referencing the virtual environment for our previous project. So make sure to change that to the main Python interpreter installed on your machine because now we are in the context of a completed different project. So let's ignore that. So here's our PDF to text module. We can add another module. Let's say PDF to image.py. Again, here we can have some code. Let's not worry about that. So this is a basic structure for a package. Now in order to publish this to PyPI, we need to add three files here. The most important one is setup.py. So at the root of this project, add a new file setup.py. Here on the top, we should import setup tools that we installed earlier. This module has a method called setup. We call this method and pass a few keyword arguments. Here are the essential ones. The first one is name. We should set this to a unique name for our package. So it doesn't conflict with another package in PyPI repository. In this demo, I'm going to set this to mosh pdf. Next one is version. I'm going to set this to version 1.0. We need a long description. For now, I'm going to set this to an m2 string. We're going to come back to this in a second. And finally, we need to tell what packages are going to be distributed. Because in this project, currently, we have one package that is mosh pdf. And in this package, we have these two modules. So we need to tell setup tools about the modules and packages that we're going to publish. So here we add packages. And we set it to setup tools dot find underlying packages. This method will look at our project and automatically discover the packages that we have defined. However, we need to tell it to exclude two directories tests and data, because they don't include source code. So we pass on right here with a couple of strings, tests and data. So this is our setup file. Now we should create a readme file. What we put in the readme file will be displayed in the homepage of our package on PyPI. So here in the root of the project, let's add readme. And by convention, we use all capital for readme. And then lowercase md, which is short for markdown. So here we can use the markdown syntax. For now, I'm just going to go with a simple example. This is the homepage of our project. Save the changes. We also need a license file. So once again, in the root of the project, let's add license. Now if you head over to choose a license.com, you can find a basic template for this license file. So let's say you care sharing improvements. Click that. Here you can see a basic license agreement template. On the top, I'm going to click this button to copy this to clipboard and then paste it into this file. That's for license. Now back to setup at Py, we should set this long description to the content of our readme file. So on the top, from passlib, we should import the pass class. And then create a pass object, set it to readme.md, and then call readtext. There you go. So here's the final result. Actually, I realized I forgot the keyword argument here. So exclude equals. So we call find packages until it to exclude these two directories. Now let's quickly recap. We added three files to our project, a readme file, a license file, and a setup Py. Now we need to generate a distribution package. And that's pretty easy. Be open up the terminal and run Python, set up.py, and pass two arguments. S-dist, which is short for source distribution, and be a dist on the line wheel, which is short for built distribution. So with this command, we're going to generate two distribution packages, a source distribution and a built distribution. Let's go ahead. All right. Now here we have two new directories, build and dist. In the dist directory, we have a wheel file, which is a built distribution and a source distribution. Both these are zip files. You can unzip them and see what is inside if you're adventurous. Now that we have these two distribution packages, the final step is to upload them to Py.py.org. Back in the terminal, we use twine to do that. So twine, upload, dist slash, asterisk. So we're telling twine to upload all the files in the dist directory. Let's go ahead. It's asking for my username, some mosh, and then the password. All right. My packages are uploaded to Py.py.org. So back here, if we search for mosh pdf, we can find that here. The current version is version 1. Here on the homepage, we have the content of our readme file. So we can easily install this package just like the other packages on Py.py. For example, here in our HelloWord project, I'm going to use ppn to install mosh pdf. Okay, it's installed here. So on the top, we can import mosh pdf. You can see mosh pdf has these two modules. So I'm going to import the pdf to text module. So from mosh pdf, let's import pdf to text. Now we can call pdf2text.convert, run the program, and here's the output. So this verifies that we successfully published a package to Py.py and then installed it and used it. When we publish our packages to Py.py repository, it's really important to document our code so other people know how to use it. For example, think of the math module. When we import this on the top, import math, and then call any of its methods, we see this little documentation here. This is what we refer to as IntelliSense. So VS Code has this IntelliSense feature which basically reads the documentation for this method and displays it in this little tooltip window. In contrast, our convert function has no documentation. So if we call it here, it's not clear what this function does. This is a very basic function, but in real application, we could have a function with one or more parameters. So people who use these functions need to know what these parameters are, what this function does, and what it returns. So this is the purpose of documentation. Now in Python, we have a special format for documenting our code called docString or documentationString. It's basically string with triple codes that we add right after declaration of function or class or variable. This is different from using comments because we should use comments to explain why we have done things in a certain way. So we shouldn't use a comment to explain what a function does. What it does should be reflected in the documentationString, how it does what it does, or why we implemented it in a certain way should come in the comment. So let me show you how to document this module using docStrings. So let me publish a module for other people to use. We should document the module itself as well as every object in it. So any classes, any methods in those classes, or any stand-alone functions in that module should be perfectly documented. So here the first line of the module should be a docString. We use triple codes to define a docString. Here we can have a one-line description that ends with a period. This is for simple cases, but if you want to explain more, you should use a multi-line docString. By convention, the first line should be a short summary followed by a blank line and then a more detailed explanation. So if you want to use a multi-line docString, this is the convention you need to follow. The first line should be a short description followed by a blank line followed by multiple lines of text. If you're dealing with a simple case, you can simply use a one-line docString. This changes into something more meaningful like this module provides functions to convert a PDF to text. Now I want to document the convert function. So right after the declaration, we add triple codes, pay attention to indentation, and do it exactly like what you've seen in this video. So here we need a short summary like convert the given PDF to text. Next we need to have a blank line. If you want to explain this function in more details, we can do that here. In this case, we don't need it. So the next part is parameters. Currently we don't have any parameters, but let's say we have this past parameter here. We need to explain what this parameter is, what its type is, and what we use it for. So past of type String, colon, the past to a PDF file. Now if we had more parameters, we would list them here, one on each line. Next we need a blank line followed by returns. What do we return here? Let's say we return string and that is the content of the PDF file as text. Save the changes, VS code automatically formats our code. And by the way, when we're dealing with multi line doc strings, we can put the first line on a new line. It's more of a personal preference. I personally think this is cleaner because we have this triple double quotes on the top and bottom of our doc string. Let's save the changes. Now to demonstrate what the consumer of this module will see, let's go back to our project. And here in the root, I'm going to add a new file app.py. Let's say we're going to consume this module. So from March PDF, we import PDF to text. Now here you can immediately see the documentation for our module. This module provides functions to convert a PDF to text. So that's the first benefit. Now PDF to text.convert. Again, look at our documentation. Here's the short summary of our function. Convert the given PDF to text. You can see the parameters, the return time, and so on. So back to our module. Here we currently have only a single function. If we had classes, again, we would have to document them. So as an example, I'm going to define a class here, class, converter. And then I'm going to put this function inside of the converter class. So let's select it and indent it here. Now we need to add the first parameter that is self-save the changes. So here's our converter class. Right after declaration, we need to add a doc string that summarizes the behavior of this class. In this case, we can go with something like a simple converter for converting PDFs to text. And we end it here. Now I know that this may look a little bit repetitive, but if you're providing code for others to use, this is really important. Please document your code because nobody likes to use a library that is not well documented. In Python, we have a utility called PyDoc that comes with Python installation. With this utility, we can easily see the documentation for a module. That module can be one of the modules in Python standard library or one of our own modules. Let me show you. So here on the terminal, if you're on Windows, type PyDoc, if you're on Mac or Linux, type PyDoc3. Next, we add math. So we're going to look at the documentation for the math module in Python standard library. There you go. So the name of this module is math. Here's the reference documentation. So we can copy paste this into your browser. And on this page, you can see all the details of the math module. You can see all the functions and their description. Alternatively, you can see all the documentation here in the terminal window. So look at this colon here. That means this is a multi-page documentation and you can go to the next page by pressing space. So here's the description for this module. And below that, you can see all the functions and the short description. Now to exit this multi-page documentation, we press Q. Now let's take a look at the documentation of our PDF to text module. So PyDoc3, Marsh PDF.PDF2Text. There you go. So here's the name of our module. Next to that, you can see our one-line description. This module provides functions to convert a PDF to text. Below that, you can see classes. So any classes that we have documented will end up here. As you can see, we have this converter class that derives from the object class in Python standard library. So here we can see the hierarchy of our class. Below that, we have the documentation for the converter class. Here you can see our short summary for the converter class. After that, we have methods defined here. So here's our convert method followed by its short description. Let's go to the next page. You can see its parameters, the returned value, and so on. Now this PyDoc has a few interesting switches. One of them is W for writing this documentation to an HTML file. So PyDoc3-W, Marsh PDF.PDF2Text. Now this generated this HTML file that contains the documentation for this module. Now let's open this HTML file. There you go. So here's our module. It's short description, the classes. Here's our converter class that derives from the object class. And you can see the convert method, its parameters, and so on. We also have another interesting switch for loading the documentation for this application as well as Python standard library in a web server. So we run PyDoc3-P that is short for port, and then add a port number like 1, 2, 3, 4. So you started a web server at this address, localhost, port 1, 2, 3, 4. If you open this in our browser, we see something like this. So on the top we have a few built-in modules. After that, you can see the modules in our application. So we have this app module, we have the setup module, as well as Marsh PDF, which is a package. Let's go here. In this package, we have two modules. PDF to image and PDF to text. And this is a documentation for PDF to text module. Now let's go back. Below this, you can see the documentation for Python standard library. For example, we have the path-lipped module here. Let's take a look. So in this module, we have the path class that you have worked with. As you can see, this class derives from another class called pure path, which derives from the object class. Also, path has two derivatives, POSIX path and Windows path. Again, here you can see the complete documentation for all the objects in this module. So this is all about PyDoc. In this section, we're going to look at some of the most popular packages in the Python community. So you're going to learn how to work with Excel spread sheets, PDF files, send text messages, automate browsers, scrape websites, and so on. These have a lot of applications in the real world. Now, before we get started, I just want to let you know that we're only going to look at the basics of these packages because each of these packages has so much detail that goes beyond the scope of this course. You need to look at their documentation to learn these additional details on your own. So in this section, I just want to show you what is out there for you and how you can use it. Now, as you go through this section, it is possible that some of these packages may not work on your machine as you see in these videos. There are basically two reasons if this happens. The first reason is that you didn't follow the instructions exactly as I showed you in the video. Maybe you had a typo or you missed a space or you didn't use the lowercase or uppercase letters exactly like how I type. So first, make sure to follow each step exactly as I show you. Now, if you still encounter an error, then chances are there is something wrong on your machine, and unfortunately, I won't be able to help you with that because every machine is different. I don't know what software you have installed or whether you have changed any of the configuration settings, so you need to resolve this issue on your own. How? All you have to do is simply copy paste the error messages you get in Google. I can promise you are not the only person on this planet who encountered these problems. I'm pretty sure there are other people who have faced the same situation. You are not the first one or the only one in the world. With all that, let's get started. These days, a lot of websites make their data available to others by all what we call application programming interfaces or APIs. In simple terms, these APIs are endpoints that are publicly accessible on the internet, so they have URLs just like the websites themselves. Here is an example. On Yelp, we have this API for searching for businesses. And this API has an endpoint at this address or URL. That is api.yelp.com, slash version three, slash businesses, slash search. So we can send an HTTP request to this endpoint to get the list of businesses that match some criteria. In case you are not familiar with HTTP, it's basically the protocol that powers our web. So as we're browsing the web, our browser sends HTTP requests various websites and gets something back. Let me show you. So here in Chrome, on the top, from the View menu, go to developer and open up developer tools. Now open up the network tab. In case you don't see anything here, press command and R on Mac or control and R on Windows to refresh the page. There you go. So these are all the HTTP requests that my browser sent to Yelp. Look at the first request, business search. That's a request to get a document. Let's inspect this request. Here in the header tab, you can see various attributes of an HTTP request. So this is the request URL or address. And that is the endpoint where we're sending this request to. Every HTTP request has a method. And that method determines what we're going to use this request for. We have a few standard HTTP request methods. Get for getting data, post for creating data, put for updating data and delete for deleting data below the request method we have status code. And that is the status code of the response that we get from the web server 200 indicates success. Now here, if you look at the response tab, you can see the response that this web server sent to our browser. This is basically an HTML document that represents this web page. If you open the preview tab, you can see a preview of this web page. So over the next few lectures, you're going to learn how to communicate with Yelp API to search for businesses based on some criteria. In this lecture, we're going to have a quick look at Yelp API. So if you search for Yelp API, you can find this website, Yelp.com slash developers. Let's have a quick look here. So we have this Yelp fusion, which is the rest API for Yelp. When we're working with APIs, quite often you see this term rest, which is basically a technical jargon that stands for representational state transfer. Basically, it's a bunch of conventions and rules that we have to follow to build or consume APIs for exchanging data. So let's take a look at this Yelp fusion. On this page, you should see this documentation link. Here we have various endpoints for working with businesses. For example, we have endpoints for finding businesses by keyword, location, category, or using a phone number. We also have an endpoint for getting details about the particular business or reviews. These are all business endpoints. Now on the left side, if you look, we also have endpoints for working with events as well as categories. So there are so many different things that we can do with Yelp API. Now, to get started, first we should create an app. So let's give our application a name. I'm going to call this pie Yelp. Now, if you do have a website, we can put that here, but in this case, we don't have a website. We simply have a Python program. Next, we need to specify the industry for this application. I'm going to send that to business. The next piece of information that we need to supply is the contact email and some description. So I'm going to type programming with marsh at gmail.com. And some description, it doesn't really matter. We can always come back and change this in the future. So obviously, we need to accept their terms and conditions and I don't want to get any emails about their product news and so on. So let's go ahead with this and create a new app. All right, our application is created. Now we have a client ID that uniquely identifies our application. This is like a user name for an application. We also have an API key, which is kind of like a password for an application. We'll need this API key whenever we want to talk to any of the endpoints on Yelp. This is for security. So Yelp wants to know who's calling their API endpoints. With this basic information that we provided, at least they have a contact information. They know who's the creator of this application. All right, we have created our application. Next, I'm going to show you how to send an HTTP request to Yelp API to get the list of businesses. All right, I'm starting with a brand new project called Py-Yelp. In this project, currently I only have one file that is app.py. Now let's open up the terminal window and using pip-n install the request package. We use this package to send HTTP requests. Let's go ahead. So this is creating a virtual environment. Our package is installed. Beautiful. Now let's change the virtual environment in VS Code to the one that is created for our Py-Yelp project. Now VS Code is telling us that Linter Pylent is not installed. So let's go ahead and install this as well. All right, now in app.py, on the top, let's import the request module. This object has a method called get for sending an HTTP get request to an endpoint. As I told you before, every HTTP request has a method and that method determines what we want to use the request for. So get is for getting data. So here we need to pass the URL or the address of an endpoint. Back to Yelp documentation. Here under Yelp Fusion, let's take a look at business endpoints. Here we have this business search endpoint. That is right here. So we can see we have to send a get request to the send point. I'm going to copy this address and then paste it here. Now this get method returns a response object. Now let's save the changes. VS Code is telling us that formatter autoPF8 is not installed in our virtual environment. So let's go ahead and install this as well. All right, now let's print this response. Save the changes and run the program. We got a response with this status 401, which is one of the standard HTTP error codes. So here on Google, if you search for HTTP 401, you can see that 401 represents unauthorized. In this case, we got this error because we didn't tell Yelp who we are. So every time you want to call one of the endpoints of Yelp, we should send our API key to tell Yelp who we are. This is what we call authentication. Now back on Yelp documentation. Here under Yelp Fusion, let's take a look at the introduction document. Under authentication, we have a link to the authentication guide. So this page is telling us that we should first create an app to get an API key. We only done that. Beautiful. So next is telling us to authenticate API calls. We need to set the authorization HTTP header to better API key. What is going on here? Well, these HTTP requests have two sections or two components. The header section and the payload section. In the header section, we have a few headers that specify some metadata about this request. These headers are key value pairs. One of these headers is the authorization header, which is defined in the HTTP protocol. We use this header to tell the web server who we are. Let me show you how to do that. So to make this code a little bit cleaner, I'm going to grab this URL and store it in a separate variable. Let's call that URL and then pass that here. Now this get method optionally takes keyword arguments. One of them is headers. You can read this in the documentation of the requests package on PyPI. We can set this to a dictionary of key value pairs. So for clarity, I'm going to create that dictionary separately. Let's set headers here to a new dictionary. In this dictionary, we're going to have a key called authorization. And we should set this to better followed by a space and our API key. So back on Yelp, here let's go to manage app and grab our API key. So copy this and now let's store that in a separate variable. So API on the link key, we set this to this string. Make sure you don't accidentally put a space here. Otherwise Yelp is going to tell us that it didn't receive a valid API key. So no space here and also no space at the beginning, right? So here's my API key. Now we need to append that here. API key. Finally, we set the headers here, save the changes. Let's run the program one more time. Okay, this time we got a response with a different status code. That is 400. Once again, if you search for HTTP 400, you can see that 400 represents a bad request, which means the server expected some data and we didn't supply that. How do we know what the server expected? Well, this response object has an attribute called text. With that, we can see the details of what the server sent us. So let's run the program one more time. This is a JSON object with a property called error, which is set to another JSON object. Now here the error message says, please specify a location or a latitude and longitude. So back to Yelp, let's look at the documentation for this endpoint. That is under business endpoints. Let's expand this one more time. It's right here, business search. So these are the parameters that we can send to the server. One of them is term, which is optional. Another one is location, which is required. And here are some examples. We can set that to something like New York City or NYC or an address. So we can either send the location or a latitude and longitude. So now let me show you how to pass parameters when sending HTTP requests. This get method of the requests object optionally takes another keyword argument, perhaps. Just like the headers, we set this to a dictionary. So I'm going to define a dictionary here, perhaps. And set the location key to let's say in New York City. And then we pass this keyword argument here. Save the changes. Run the program one more time. Okay, this time we didn't get an error. Instead, we got a JSON object that includes the list of businesses in New York City. Now let's filter this. So in our prams object, I also want to set the term to barber. So I only want to see the barbers in New York City. Save the changes and run this one more time. If you scroll to the top, we can see that this JSON object has a property called businesses. And this is set to an array because here we have square brackets. In this array, we have a bunch of JSON objects because we have curly braces. So back to our response object. Now instead of using the text attribute, I'm going to call the JSON method. And this will convert the result into a dictionary. So we can store that in a variable called result. Now as you saw, this dictionary has a key called businesses that is set to a list. So we can immediately access this key businesses. And let's rename this variable to businesses. Now we have a list of dictionaries. Now let's print the businesses variable. So we get a list of dictionaries. Each dictionary has these key value pairs ID, alias, name, and so on. So this is the name of the business. Now let's say we only want to get the name of this business. So we can simply iterate over this list, get each dictionary and extract the value of the name key. So for business in businesses, we can print business of name. Let's save the changes, run the program one more time. That is better. Now let's take this to the next level. We can use a list comprehension to get the name of businesses that are rated 4.5 stars or higher. So remember this comprehension. The syntax is like this. Item for item in list. In this case, our list is businesses. Each item is a business, which is a dictionary object. Now to get the name of the business, here we type business of name. So this list comprehension will return the list of these businesses. Now we want to filter. So if business of rating, that's another property that we have in the result. So if the rating is greater than 4.5, then we want to add the name of the business to the list. Finally, we start the result in names. And then we can simply print the names variable. Let's run the program one more time. So these are the highest rated barbers in New York City. So in our current implementation, we have stored the API key in our source code. There is a problem if you add this code to a version control system like Git and publish it to GitHub, this API key is visible to anyone who has access to that GitHub repository. And that means they can create an application, a malicious application, and use our API key to pretend to be us. That's not good. So if they violate any of the policies of Yelp, we'll be in trouble. So how to prevent this? Well, we need to extract this API key, put it in a separate file, and exclude that file from Git. Let me show you how to do that. So that's pretty easy. We add a new file here. Let's call that config.py. In this file, we'll have all kinds of configuration parameters for our application. So now back to app.py. I'm going to move line 4 into config.py. So cut, then move it here, save the changes. Now back to app.py. On the top, we import this config module. In this module, we have an attribute called API key, right? So we can access it using the dot operator. So this is where we are referencing the API key. We need to prefix that with config dot. That was the first step. Now to exclude this file from Git, we need to come to our project, add a new file, and call it dot git ignore. Here we can specify what files and directors should be excluded from our Git repository. So currently that is config.py. Save the changes. So now when we push our code to git hub repository, our config file will not be there. So if you're working in a team, every developer needs to create this config file on their own machine. So it's the responsibility of the team lead who has access to the API key to give the API key to every developer in the team. In this lecture, I'm going to teach you how to send text messages using Twilio. Twilio is a very popular communication platform for adding voice, video, and messaging to your applications. For example, you can quickly make and receive video calls, send text messages, and this is particularly useful for confirming reservations, sending appointment reminders or promotions. The possibilities are endless. They provide an API that is perfectly documented and is super easy to use. So we can directly communicate with this API by sending HTTP requests using the RECOS module, but they also provide a library that we can install using pip or pip and this library is essentially a wrapper around their API. So it gives us objects and these objects encapsulate all that HTTP communication. So we no longer have to work at a low level of sending HTTP requests to Twilio API. We work at a higher level in a more abstract and simplified fashion. Their objects, these objects have methods we call them and they internally will take care of sending the right HTTP requests to Twilio API. Alright, so the first thing you need to do is to create a Twilio account. Let's go to the sign up page. Here we have a simple form. You need to provide your first name, last name, email, and password. On the next page, it's going to ask you to provide a phone number and this is used to verify your account. So pause the video and do these steps when you're done. Come back, continue watching. Okay, so here we are on Twilio console. On the left side, let's go to phone numbers. We need to provision a phone number for sending text messages or making phone calls. So let's click get started and then click get your first Twilio phone number. Alright, this is the number we're going to use to send a text message in the next step. So let's go ahead and choose this number. Beautiful, we have set up our account. Now we are ready to write a program to send a text message using Twilio. So let's start by creating a brand new project. We're going to call that pi text. Now let's go to this folder and open it in VS code. Alright, here first we need to install Twilio. So pip n install Twilio. Okay, beautiful. Now let's add a new file here. We call it app.py. Next we need to select our virtual environment. So we can either click this virtual environment on the status bar or we can press shift, command and P on Mac or shift control P on Windows. Here we search for Python interpreter. There you go. So let's select that and we set this to pi text. Okay, now from Twilio dot rest, we need to import the client class. So this class represents a client to Twilio rest API. Now let's create a client object. Here we need to pass an account sit, which is short for security identifier, as well as an authentication token. We can find both this on Twilio console. So here on Twilio console on the top, you can see the project name right below that we've got account sit or security identifier. Let's copy this. Now back in VS code. Here I'm going to store this in a separate variable. So later we can export this and put it in a separate module. So account sit, we set it to this string. Now back to Twilio console below account sit, we've got authentication token. So let's view that, copy and then similarly we're going to store it in a separate variable. So all on their line token, we set it to this string. Now we create a client object and pass account sit as well as the authentication token. And here's our client object. This client object has a few interesting attributes. The one that we're going to look at in this lecture is messages and we use that to send text messages. We also have calls for making voice calls. We've got facts, video, chat, and so on. So messages. Now this object has a method called create. Here we need to pass three pieces of information. Two, which we set to a phone number from on the line, which we set to our Twilio number. This is the phone number that we generated earlier. And finally, body. Let's say this is our first message. So with only four lines of code, we can easily send a text message to any numbers in the world. This create method takes care of sending the right HTTP request to Twilio API. So finally, it will return a call object. This call object has attributes like date created, date sent, date updated, and so on. So this was the basics of sending text messages using Twilio. The earlier one we consumed the Yelp API, I told you that you should not store this kind of information in your source code and then check it into a version control system like yet. So as a best practice, we should take these two variables out, put them in a separate file, and then exclude that file from our version control system. But I'm not going to do that because you already know how to do it. And I don't want to waste your time repeating what you already know. So you have learned how to consume APIs using the request module. However, not every website has an API for us to work with. So in situations like that, the only way to get the data we want is to parse the HTML behind a web page, get rid of all the HTML tags and extract the actual data. This technique is called web scraping. So we scrape all the HTML tags and get the actual data that we want. And that's what I'm going to show you in this tutorial. So we're going to write a program that will extract the list of newest questions on stackoverflow.com. We refer to this kind of program as a web crawler or a web spider. So let me show you how to build a web crawler in Python. So here in a new project, first we need to install beautiful soup version four. This is a very popular Python package for extracting information from HTML and XML files. So let's go ahead. Beautiful. We also need to install the request module to download the web page that contains the newest questions on stackoverflow. So pip n install requests. All right. Now let's add a new file here app.py. First, let's change our virtual environment. So I'm going to set that to PyCrawler virtual environment. Let's install pilot. So the first step is to download the web page that contains the newest questions. Let's import the request module. And then we call get and pass HTTPS stackoverflow.com slash questions. Now we get the response and store it here. This response object, as you have seen before, has an attribute called text. And this returns the HTML content of this web page. So using this HTML content, we can create a beautiful soup. Let me show you. So from BS4, let's import the beautiful soup class. Now here we create a beautiful soup object and pass our HTML content. Now here we can get the HTML content from a web page on our internet, but we can also read the content of an HTML file on disk. Beautiful soup doesn't care. As long as we give it a string that contains some HTML or XML content, it's happy. Now as a second argument, we need to pass the type of parser because we're going to parse on HTML file, we should pass HTML dot parser. And with this we get a soup object. Now it's soup object mirrors the structure of our HTML document. So we can easily navigate this document and find various elements. Now back here, let's right click on the first question and inspect it. So here's the structure of our document. Here we have an anchor that contains the title of our question. Now let me expand these elements here. So we have this div with the ID questions. And this is the container for all our questions. Let's look at one of these questions. That's a div with the class question, dash summary. Inside of this div we have two other divs, one with the class, stats, container that includes the number of votes and answers. And another div with the class summary that contains the title and summary of our question. So using our soup object, we need to find all elements with the class question, dash summary. That's pretty easy. So soup, has a method called select that takes a CSS selector. If you're not familiar with CSS selector, you really need to learn that on your own because that's beyond the scope of a Python course. But basically a CSS selector is a string that helps us find an element in an HTML document. So here we want to get all elements with the class question, dash summary, we type dot to specify a class and then the name of the class question, dash summary. This will return a list, let's store that here. Each item in this list is an instance of the tag class. Let me show you. So I'm going to print the type of the first question questions of zero. Let's save the changes, run the program. We get this error, no module named BS4 because code runner is using the wrong Python interpreter. I showed you how to fix this issue earlier. So I'm not going to repeat that here. Instead, I'm going to run this program using the terminal. So Python three app that pie. So each object in this list is an instance of the tag class. In this case, this tag object represents this diff here, the first question. Now, as you see, this element has a couple of attributes class and ID. These attributes are stored in a dictionary in our tag object. Let me show you. So I'm going to print questions of zero dot attributes. Save the changes. Let's run it one more time. So here we have a dictionary with two key value pairs. There's the first one class and here's the second one. Now, we can easily read these attributes using square brackets. So we don't have to access the attributes dictionary. We can simply use square brackets here to get the value of the ID attribute. Now, if this element doesn't have this attribute, we're going to get an exception. So a safer way is to call the get method. Get ID and we can optionally supply the default value. So this is all about the attributes. Now we need to get the title for each question. So back to our HTML document. Here's our question summary. Inside this div, we have this div with the class summary. Let's expand that. We have an h3 with an anchor that contains the title of our question. Now, look at the class attribute here. The class of this element is question dash hyperlink. So back to our code, this tag object also has this select method like the super object. And here we can pass another CSS selector. In this case, question dash hyperlink. Let's save the changes. Run the program again. This returns a list of objects. We can see the first object here is our anchor. Now, in this particular case, we know that each question has one title. So we don't need a list here. We have another method called select one that returns one object instead of a list. And this is more efficient in situations where we know we're dealing with a single element. So we don't waste time searching the entire document for more items. So save the changes. Let's run this one more time. Now we have one anchor. So the next step is to get the actual text here. This is the title of our question. This tag object has a method called get text. Let's try this. So back to the terminal. Let's run the program. And here's the title of our first question. So next we need to iterate over all the questions and get the title of each. So for question in questions, let's print question that select one and then get text save the changes. Run the program one more time. Here are all the questions. Beautiful. The last step is to get the votes for each question. So back to our HTML document. As I told you before, each question summary has a div with the class stats container. Here we have another child a div with the class stats. And we've got the votes right here. So we have a span with the class vote count post. So similarly we print question dot select one. Then the class is vote count post. And once again, we call get text to get the text inside of the span element. Save the changes. Run the program one more time. And we successfully got all the newest questions and their vote on the first page. Now to get the questions on page two we need to follow the same approach. So first we need to find the pagination component on this page. Here we can find the last page. So we extract that here and then run this logic inside of a loop. In this loop, in each iteration, we'll get the questions for a specific page. Let's say you get hired as a test engineer at a web development company. Every day you have to test various functions of a website. Doing so requires a lot of manual and repetitive work. You have to launch your browser, direct it to the address of your website, click on a few links here and there, perhaps fill out the form and repeat all these with different values several times a day. This is very time consuming and it doesn't scale. So that's where Selenium comes in the picture. With Selenium, we can automate our browser so we can write a bunch of scripts to test various functions of a website. Here's an example. Let's say we want to test the login functionality of GitHub.com. So we'll have to launch our browser, head over to GitHub.com, click on the signing link, then fill out this form. And finally, click on this avatar and check to see if our username is displayed here or not. If not, that means there's something wrong with the login functionality. So this is an example of automated testing. Now let me show you how to do this with Python and Selenium. So here in the brand new project called Py Selenium, on the terminal, let's run pipn install Selenium. Next, we need a driver. A driver is a piece of software to automate a specific browser. For all these popular browsers like Chrome, Firefox, and so on, we have a web driver that we need to manually download. So head over to pipi.org and search for Selenium. Here it is. Now on this page, if you scroll down under driver, so you can see this table. So here are the drivers for Chrome, Edge, Firefox, and Safari. In this demo, I'm going to automate Chrome. So let me show you how to install Chrome driver. Let's go here. Now you can see the latest release. Chrome driver version 2.44. Let's click this. Here in this directory, you can see the Chrome driver for various operating systems. I use a Mac, so I'm going to download this. Here we get a zip file. Let's extract it here. So we get an executable called Chrome driver. We need to put this somewhere in the path. If you're on Windows, you need to put this in the Windows folder on C drive. If you're on Mac or Linux, you need to copy your local bin directory. So here on a terminal, we can run copy, Chrome driver, to slash user, slash local, slash bin. That's it. Now back to VS Code, first we need to change our virtual environment to Py Selenium. Beautiful. Now on the top, from the Selenium module, we need to import the web driver module. In this module, we have classes that represent all the popular browsers like Chrome, Firefox, and so on. So to automate Chrome, we need to create an instance of the Chrome class. So web driver.crome, this is actually a class, but VS Code IntelliSense shows it as a module. So don't worry about that. Let's create an instance of Chrome. And this returns a browser object. Now, let's call browser.get and head over to httpsgithub.com. Save the changes and run this program. So this will open a new instance of the Chrome browser. And as we can see, we are on github.com. Beautiful. Next, we need to click on this signing link. So we need to tell Selenium to find this element and click it. Now, when it comes to finding elements, we have a few different options. We can find elements by their ID, class, name, and tag. So let's right-click this element and inspect it. So here's our signing link. We have an anchor with these classes. None of these classes uniquely identify this link because we have header menu, dash link, which can be reused somewhere else. We also have no underlying as well as MR3. So these are pretty generic classes. So we cannot find this element using its class. Also, as you can see here, we don't have the idea attribute. So in this particular case, the only way to find this element is by its text. Let me show you how to do that. So back in VS Code, let's call browser that find element by link text. So our link text is signing. Make sure to spell this exactly as you see on a web page. In this case, if we use a lowercase s, this method is going to raise an exception telling us that there is no element with this link text. So signing. Now this returns a web element. We can get that and store it in a variable like sign in link. Now to click this, we can simply call the click method. So sign in dot click save the changes run the program again. Okay, we're heading over to GitHub and now we are on the signing page. Beautiful. The next step is to fill out this form. We're going to follow the same approach. So we inspect this element right click and go to inspect. All right, here's our input fill. As we can see here, we have an ID and this uniquely identifies this element on our web page. So this time, we can find this element by its ID. The ID is login filled. So I'm going to copy this. Now back in VS Code, let's call browser that find element by ID. We passed the ID here. This time we get the user name box. Okay. Now we want to fill this out. So here we have a method called send keys that simulates a user typing in a text box. So username box that send keys. I'm going to type this user name ninja coder 22. Now similarly, we need to fill out the password field. So here's our password field. And as you can see, the idea of this field is password. So back in VS Code, I'm going to duplicate these two lines and change this to password box. Let's change the ID to password. And also line 12. Let's change this to password box. And the password I'm going to pass here is today is Monday one. Don't try this because I'm going to change this after recording this lecture, but you can trade with your own user and password. So we filled out the form. Now we need to submit it. That is pretty easy. So we call password box dot submit. Save the changes. Let's run the program one more time. Okay, we're going to GitHub. We logged in and here we are. So this is my avatar. You saw that happened pretty quickly. No human can do it that fast. Finally to ensure that this login function works properly, you want to make an assertion. So when we click on this avatar, we see our username displayed here. So here we can make an assertion that ninja coder 22 is rendered in the HTML of this web page. Here's one way. So let me show you back in VS code. So this browser object has an attribute called page source. Again, VS code is making a mistake here. It's displaying this as a function, but it's an attribute. And this returns the HTML content of this web page. Now in Python, we have this statement called assert. And with this, we can verify something. For example, we want to verify that ninja coder 22 is in this string. So page source returns a string. That is the HTML content of this web page. Now if we do have ninja coder 22 here, our program will continue execution without any problems. Otherwise, if we don't have this text in our HTML, this is going to throw an exception. So to simulate that, let me change 22 to 23. Obviously, we don't have this. So let's run the program and see what happens. So we're going to log in one more time. Beautiful. Now back in VS code here, on the terminal, you can see we have an assertion error. So we asserted that ninja coder 23 is in the HTML of this web page. And that assertion failed. However, if we change that to ninja coder 22 and run the program again, this time we don't have any exceptions on the terminal. So this is the idea behind assertions and automated testing. Now this assertion is kind of general. Let me show you a more specific assertion. Back to GitHub.com. When we click on this avatar, we see this drop down box. Let's right click on this element and inspect it. Okay, here's our label. It's inside of a strong tag. And this strong tag is part of this anchor, which is part of this list item. To do a more specific assertion, we can find this anchor. Look at its inner HTML and ensure that here we have ninja coder 22. This is more specific and searching for ninja coder 22 in the entire HTML. Right? So look at our anchor. Here we have this class user profile link. So we can find this element using its class. So browser that find element by class user profile link. So let's do that in profile link. Now we need to get the inner HTML of this link. So we call profile link that get attribute. The attribute name is inner HTML. Now we get the result and store it in link label. Finally, we can assert that ninja coder 22 is in link label. So that was the basics of using Selenium to automate our browser. Now there are more advanced topics about automated testing with Selenium that goes beyond the scope of this course. So if you want to learn more, search for Python Selenium on this page Selenium-Python.read the docs.io. We can read about these advanced scenarios. The two sections that I highly encourage you to read about are weights and page objects. This is a pattern that helps you organize your code in a reusable fashion and it's extremely important when testing a real application with tens or hundreds of functions. You don't want to write all your test code in a linear fashion like this. You want to organize it into classes with methods that you can reuse in many different scenarios. Now one last thing before we finish this lecture, whenever you're done with your browser object, you need to call the quit method. Otherwise, you will end up with so many open browser windows. So down the bottom, we call browser dot quit. In this lecture, you're going to learn how to work with PDF files in Python. As I showed you earlier in the course, there are several packages to work with PDF files and unfortunately, most of these are either unstable or poorly documented. The one that is more popular is PyPDF2 and that's what we're going to use in this lecture. So here in a brand new project, on the terminal, let's install PyPDF2. Okay. Now here in app.py, on the top, let's import PyPDF2. In this module, we have a few classes to work with PDF files. Let's take a look. We've got PDF file reader, PDF file writer, and PDF file merger. I'm going to give you a quick overview of each of these classes. Let's start with PDF file reader. So here when creating a PDF file reader, we need to pass a file string. This is the object that the built-in open function returns. So using the open function, let's open, here I got a couple of PDF files first and second. We can download this as a zip file attached to this lecture, but there is nothing particular about this. We can use any PDF files you want. So let's open first.pdf. It's very important to open this file in the binary mode. So as a second argument, we need to pass rb, which is short for read in binary. Now we get a file stream object. Let's use the width statement here and here's our file stream object. So we pass this right here and we get a file, a PDF file reader object. Now this reader object has a few interesting members. One of them is num pages, which returns the number of pages in your PDF. Let's print that here. So in this file, we have only a single page. We also have this method get page that takes a page number, but more accurately, this parameter should have been called page index because the index of the first page is zero. So here we pass zero to get the first page. This returns a page object. This page object has a few interesting members like rotate clockwise as well as rotate counter clockwise. We also have scale as well as scale by a given factor or scale to a given width and height. We can read about this in the documentation for this package. In this demo, I'm going to use the rotate method. So let's rotate this 90 degrees clockwise. Now what you need to understand here is that this does not modify the original PDF. This is only rotating the page object in memory. So we need to write this to a separate PDF file. For that, we need a PDF file writer. So pi PDF2.PDF file writer. Here, we don't pass any arguments. This simply creates a writer object. So we're dealing with a writer object in memory, not a file on this. So now we call writer.ad page. And then we pass this page object here. This method will add this page object at the end of this new PDF in memory. We also have another method insert page that takes an index. So if you want to reorder PDFs, you can use this method to add pages at specific indexes. We also have insert blank page that doesn't take any arguments. So let's revert this back to add page and pass this page object. Now finally, we need to write this PDF in memory to a file on disk. For that, we need another file stream. So we can use the width statement here to open another file like rotated.PDF. And as the second argument, we need to pass WB, which is short for write binary. Very important to pass this argument. Otherwise, it's not going to work. Let's call this file output. Now finally, we call writer.ad write to this file stream. Let's save the changes, run this program. So here is my first PDF. We have some basic text here. And here's our rotated PDF. So as we can see, with Python, you can easily write a script to iterate over all the PDFs in a directory and process them by rotating them, scaling them, or combining them. So let me show you how to combine multiple PDFs into a single PDF. So back to VS Code, as I showed you earlier, in this module, we have this class PDF file merger. And we use this to merge multiple PDF files. So let's create a merger object. Now let's say we have an array of file names. So file names we set this to an array of two strings, first.PDF and second.PDF. In a real world application, instead of this hard code array, you can iterate over all the PDFs in a directory. So here we have all the file names. Let's iterate over this array. So for file name in file names, we simply call merger.appand and pass this file name as simple as that. So up to this point, we're merging these PDFs in memory. Finally, we need to write the result to a file on disk. And that is pretty easy. So merger, that right, there here we can pass a file object or a string that specifies the name of the file. So let's call that combined.PDF and run this program. So here's our combined PDF. It has two pages. The first page comes from our first PDF and here's the second page that comes from the second PDF. In this lecture, you're going to learn how to work with Excel spreadsheets in Python. Out of all the lectures in this course, this is one of my absolute favorites. Because it has a lot of applications in the real world. So here I have a brand new project called Pi Excel. In this project, I have a spreadsheet called transactions. You can download this as a zip file attached to this lecture. When you open this, you're going to see something like this. So we have three columns transaction ID, product ID and price, as well as three rows of data. Pretty straightforward. So back to VS code, the package we're going to install is open pi Excel. So let's run pip n install, open pi Excel. All right, beautiful. Now let's select our virtual environment from the status bar and set it to pi Excel. Next, we're going to install pilot just like before. All right, now on the top, we start by importing open pi Excel. Now when working with spreadsheets, we need to start with a workbook object. We can either create an empty workbook and memory or load an existing workbook on disk. So this module open pi Excel has this workbook class. We can create a new workbook object like this. Now we have an empty workbook with one sheet. Later, I will show you how to save this to disk. We also have this function open pi Excel.load workbook for loading an existing workbook. So in this demo, I'm going to load transactions.xlsx. And this gives us a workbook object. So I'm going to comment on this line because we're not going to use it. So we have a workbook. Now this workbook has an attribute called sheet names. This is actually an attribute, even though VS Code is showing it as a function. Let's print this on the terminal. So in this workbook, we have only a single sheet. That is sheet one. Let's go ahead and access that. That is pretty easy. We use square brackets just like how we work with dictionaries. So sheet one. And by the way, this is case sensitive. So if you use a lower case s, you're going to get an exception telling you that this sheet doesn't exist. So make sure to spell it properly. Now we have a sheet object. We can also create a new sheet or remove an existing one. So our workbook object has a couple of methods. You should be aware of one is create sheet. Here we pass the name of the new sheet like sheet two. And optionally, we can pass an index. For example, we can pass zero to put this before sheet one. We also have remove underlying sheet. That takes a sheet object like this. And it will remove it. Now I'm not going to use these methods in this demo. Just be aware of them in case you need them in the future. So we have a sheet next minute to access an individual cell or a range of cells. That is pretty easy. So using square brackets, we can pass the coordinate of a cell. So we can pass A1. And that refers to the cell here. A1. So first row first column. So here we get a cell object. Now this cell object has a few attributes you should know about. One is value. We can print this on a terminal. So the value of the cell is transaction ID. You have seen that before. We can also change the value here. Pretty straightforward, right? We also have row. Let's print that on the terminal. We have column and coordinate. Let's have a look. So the row of the cell is one. The column is A. And the coordinate is A1. Now we also have another approach to access an individual cell. And that is using the cell method of the sheet object. Let me show you. So instead of using square brackets and passing the coordinate, we can call sheet.cell and pass a row and a column. So one and one. Now we can make this code more readable by using keyword arguments because it's not quite clear what row or what column we're working with here. So we said row to one and column to one. And this gives us the exact same cell. Now obviously this code is shorter and easier to use. But the second approach is useful when we are iterating over all the rows and all the columns and we want to dynamically access various cells. Let me show you. So this sheet has a couple of attributes. One is max row. Let's print that on a terminal. We also have max column. Let's run the program. So in this sheet, we have four rows and three columns. Now we can easily iterate over all these rows and columns. So we can write a four loop like this. Four row in sheet that max on the line row. Now this returns a number. So we need to pass that to the range function. Now as you know, this function generates numbers starting from zero. So we need to set the start index to one because we don't have row zero in a spreadsheet. The first row is one. Also for this reason, we need to increment this white one so we can access the last row. Now using the same technique, we can iterate over all the columns. So for column in range of one and sheet that max on the line column plus one. Now we can call sheet.cell and pass the row and column here. And with this, we can print the value of each cell. Save the changes and run the program. So these are all the values we have in this spreadsheet. Now using square brackets, we can also access a range of cells. So let me delete this four loop. Here are a few examples. We can access sheet of A and this will return all the cells in the A column. So here's the A column. It will return all these cells. We can store the result in column. Let's print that and see what we get. So we get a topple because here we have parentheses. In this topple, we have four cell objects. Cell A1, A2, A3, and A4. Pretty self-explanatory. We can also work with a range of columns. So sheet of A to C. This will return all the cells in columns A to C. Now let's store that here. So cells and then print it on the terminal. Let's see what we get. Note that we get a topple of topples. So each topple in this topple will represent one column. Let me show you. So here's one of our inner topples. In this topple, we have cells A1, A2, A3, and A4. So this inner topple represents the A column. That is this column here. So A1 all the way to A4. This is one of the inner topples. Next, so that we have another topple and then another topple. And these three topples are packed inside of another topple. Now we can also use coordinates here. So sheet of let's say A1 to C3. And this will return all the cells in this area. So A1 to C3. Now using the same technique, we can also access the cells in a given row or a range of rows. So sheet of A1 returns all the cells in the first row. Or if we use A1 to C3, this will return all the cells in row 1 all the way to row 3. So this is how we can access a range of cells. Now this sheet object has a few methods you should be aware of. One of them is a pen. And we use that to add a row at the end of this sheet. So here we pass a list or a topple of values. Let's say 1, 2, 3. We also have insert rows. And we use this to insert a row at a given index. We also have insert columns as well as delete rows and delete columns. So you can perform various kinds of operations in a spreadsheet. You can also add charts, sort and filter data and so on. I leave it up to you to look at the documentation of OpenPyXL and learn about the features that you need in your applications. Now to finish this lecture, let's save this workbook. So workbook.save. We're going to save it as a new file. So transactions to.xlsx. Save the changes. Run the program. Now we have a new spreadsheet here. And in this spreadsheet we should have an extra row of data. And here's our updated spreadsheet. You can see the row that we added using Python. In this lecture, I'm going to talk about a very important principle in computer programming called command query separation. This principle states that our methods or functions should either be commands that perform an action and change the state of a system or queries that return answer to the caller without changing the state or causing side effects. So our methods should either be commands or queries, but not both. Let's see this principle in action. So in the last lecture you learned that this workbook object has a method called create sheet. This is an example of a command method because it's responsible for performing a task, the task of creating a sheet. As a result of calling this method, the state of our system in this case our workbook changes. So every time we call it, we get a new sheet in this workbook. Now let's take a look at an example of a query method. So here we have this sheet that represents the first sheet in my workbook. In the last lecture you learned about the cell method, we use this to access a cell in this sheet. This is an example of a query method. We use it to access a given cell. However, this method violates the command query separation principle. Let me show you why. I'm going to write a loop to print the value of all the cells in the first column. So for row in range, one, let's say to 10, we want to call sheet.cell, pass row here, and one as the column. We get the cell, now we print cell.value. Let's run this program. So here are the values. We've got transaction ID followed by three rows of data and a bunch of non objects. Now, after this loop, I'm going to call sheet that append to add a new row with these values and finally save the workbook as transactions to. Let's see what happens when we run this program. So run, okay. Now I'm going to open up this transactions to here's a result. This new row that we added ended up here, but didn't we expect it to be right here after the last row? This is the result of violation of command query separation principle. Here's the reason. In this for loop, we're iterating over the first 10 rows to get the cell in the first column. Now in our original spreadsheet, we only had four rows. These are the rows. So the heading row followed by three data rows. So when we use the for loop to iterate over the first 10 rows, the cell method magically created these new cells. In other words, when we call this method to access a cell at a given coordinate, if that cell doesn't exist, this method will create it for us. And this is the violation of command query separation principle, because this is a query method, so it should not change the state of our system. In this case, the workbook. In other words, you should not have a side effect. So the developer who implemented this method probably had no idea of this very important principle in programming. So as we can see, the violation of this principle can create unexpected issues in your program. It makes it hard to reason about your code and figure out what is happening. So it would be better if this method raised an exception if we tried to access a cell that didn't exist. Similar to accessing the fourth item in a list of three items, let me show you. So here we have a list of numbers, one, two, three. If we try to access the fourth element, what happens? Our list will raise an exception. Or if you have a dictionary and try to access an item with an invalid key, again, our dictionary raises an exception. It doesn't magically create a key value pair with this key, because here we're querying our dictionary. So earlier in the course, you learned that when we use square brackets to get an item with its key, a magic method called get item will be called. This is a query method. It should not change the state of the system, or it should not have side effects. In other words, asking a question should not change the answer. So I thought this was a great opportunity for me to talk about the command query separation principle. It's very important. Make sure your methods are either commands or queries. And when using openpy excel, be aware of how this cell method works. So if you generate an excel spreadsheet and see some blank rows or columns, go back, check your code, and make sure you didn't accidentally reference those cells. In this lecture, we're going to look at a very important package called numpy, which is heavily used in scientific computations. So if you want to get into data science and machine learning, this is one of the packages you will be using quite often. There are also several other packages that are built on top of this package. So it's a very comprehensive topic, and it really requires its own course. But in this lecture, I'm going to give you a very sweet introduction to numpy. So you know what it is, and what you can do with it. So here on the terminal, let's do pipn install numpy. So numpy enters just python by bringing super fast multi-dimensional arrays that take less memory than the built-in lists in python. So anytime you want to work with large multi-dimensional arrays, numpy is your best friend. So let's import it on the top, import numpy. We can optionally give it an alias using the ask keyword. So call it np, and now we can access this module with np. This makes our code shorter, because in a real application, you're going to use this package a lot. So we don't want to type numpy. numpy. numpy. numpy. okay. Now here we have this array function for creating an array. We can pass a normal list here, and this will return a numpy array. Let's have a look. So print array. So here's our array, but this is actually a numpy array. So if we print the type of this array, you can see it's an instance of n-dimensional array class in numpy. Now here we can create a multi-dimensional array like this. So we have one list. In this list, each item is a list. Here's the first item. It's a list of three items, and here it is the second list with three more items. So now we have a two-dimensional array, which is called a matrix in mass. Let's print this on a terminal. This is what we get. So we have a matrix with two rows and three columns. Now this array object has an attribute called shape. So let's print array.shapes. And run the program. There you go. So as you see, this returns a topple that specifies the number of items in each dimension. So here we have a matrix with two rows and three columns, and that's why we get a topple with two and three. Now in numpy, we have a bunch of helper methods for creating arrays and initializing them with zeros, ones, specific numbers, or random values. Let me show you. So np.0s, this will create an array and initialize it with zeros. Now the first argument to this method is a topple that represents the shape of the array. So here we pass a topple, let's say three and four. Now we get an array and print it on the terminal. So we get a matrix of three rows and four columns, and each element is initialized to zero. Now by default, all these numbers are floating point numbers. That's why we have this decimal point here. If you want to change the data type, you can pass a second argument here that is d type. So d type, we set this to let's say integer, random program again. So now all our numbers are integers. Now we have another method called once, and we use that if you want to initialize this array with once. Let's take a look. Here it is. We can also fill this array with a specific number. So we call the full method. And as the second argument we pass, the number we want to fill this array with, let's say five. And here is the result. So pretty cool, right? We also have a method for creating an array with random values. So we go to the random module and this module we have this random function. So we just pass the shape of this array and this will create a three by four array and every item is random number. Now if you want to do this in pure Python without numpy, our code is definitely longer than this. It's going to be two, three lines of code. So numpy makes a lot of trivial things really, really easy. So now we have a three by four array. We can access individual elements using an index. So here we have our array. Let's get the element at the first row and the first column. So print. So here's our array. And as you can see, the item at the first row and the first column is this number, which is printed here. Now in contrast, if this array was a multi-dimensional list in Python, our code would end up looking like this array of zero and zero. So we would have extra square brackets and this would make our code a little bit noisy. Now let me show you something really powerful. I'm going to print an expression like this. Array greater than 0.2. Now let me comment out what we have online eight. We don't need it anymore. Let's run the program. See what we get here. Here's our original array. And below that, we have an array of Boolean values. Each element determines if the corresponding element in the original array was greater than 0.2. Extremely powerful. If you want to do this in pure Python, we would have to write a lot more code than this simple expression. So now pay arrays support various kinds of mathematical operations. We also have Boolean indexing again, extremely powerful. So we print array of, now instead of using a numeric index, we use a Boolean expression. So let's say array is greater than 0.2. Let's run the program and see what happens. So this will return a new array with only the values that are greater than 0.2. We also have a bunch of functions for performing computations on arrays. Let me show you a few examples. So let's print numpy.sum and we pass our array. This returns the sum of all items in this array. So here's the result. That's pretty cool. We also have floor and this returns a new array with the exact same dimension and computes the floor of each item here. Similar to floor, we have seal to get the ceiling of each number of round. Let's run this. So when we round these numbers, we get an array of zeros and ones. Pretty cool. And one last thing before we finish this lecture, we can also perform arithmetic operations between arrays and numbers. Let me show you. So I'm going to delete all this code. Let's say we have one array here, np.array with 1, 2, 3. We have another array here. Now we can print first plus second. Let's run it. So here's the result. All the arithmetic operators that you're familiar with, like multiplication, division, subtraction, all these are supported by numpy arrays. We can also add a number to our first array. Let's see what happens. So this creates a new array and adds to to each item in the original array. Now here's a real word example of using this operation. Let's say we have an array of dimensions in inch and you want to convert it to centimeters. So dimensions on the line inch, we set it to numpy.array and pass one, two, three here. Now to convert these values to centimeter, we can write code like this. So dimensions on the line centimeter equals dimensions on the line inch multiplied by 2.54. Let's print the result. So there you go. Again, pretty easy. If you want to do this in pure python without the use of numpy, our code would be longer. Let me show you. So as comparison, we create dimensions inch and set it to a regular list in python. Now we need a list comprehension to transform this array into a different array. So here's a syntax for list comprehension item for item in list. In this case, our list is dimensions inch. Let's call each item x. Now we need to get x and multiply it by 2.54. And with this we get dimensions on the line centimeter. So this is the implementation in pure python and here's the implementation in numpy. So numpy provides multi-dimensional arrays that are super fast and take less memory. Plus they support various kinds of mathematical operations that regular python lists don't. So it's the core library for scientific computation. In this section, you're going to learn how to build a simple web application using a super popular web framework called Django. I love their tagline. The web framework for perfectionists with deadlines. And that's absolutely true. If you're a perfectionist and want to build a real enterprise web application that is fast, secure, and scalable, Django is your best friend. Here's some of the popular websites that are built with Django like Instagram, Spotify, YouTube, Washington Post, Dropbox, and so on. So in this section, we're going to use Django to build a simple, imaginary video rental application called Ridley. So here we have a list of movies. Each movie has properties like title, genre, number and stock, and daily rental rate. We can click on each movie to see more details. Now I know this is not a fascinating looking application because our focus in this section is not to build a full-featured application that looks fancy. We just want to learn how Django works. So I'm going to walk you through the process of building applications with Django. So in this application, we have these two pages. We also have an API that is available at API slash movies. So this API returns the list of our movies as Jason. Now if you're not familiar with APIs, don't worry. You're going to learn everything from scratch. So in this section, we'll build this application and more importantly, deploy it to a cloud platform called Haruku. So you will see the process of building a simplified web application from A to Z. Are you excited? I hope you are. And let's get started. In this section, you're going to learn how to install Django and create your first Django project. So here on the command line or terminal, let's create a new directory called Ridley. That is the name of our imaginary video rental application. Okay, now let's go in this directory and install Django using pip-n. So pip-n install Django and let's set the version to 2.1 to make sure we're using the exact same version. So to earn those surprises later on as you go through the videos. Okay, let's go ahead. Now we need to activate our virtual environment. That is pretty easy. So pip-n shell. Okay, as you can see, the virtual environment for this project is activated. Beautiful. So next, we're going to use a tool called Django admin for creating a new Django project. So let's run Django-admin, start project. We're going to call this project Ridley. And we want to create it in the current directory. So let's add a period at the end. When we run this command Django admin is going to create a basic website with some boilerplate code. You're going to see that in a second. So let's go ahead. Beautiful. Now let's open this in VS code. So code period. All right, here's what we got Django admin created this Ridley directory as well as this managed.py file. We use this managed.py to perform some administrative tasks such as starting our web server or migrating our database, populating it with data and so on. You're going to learn about this as we go through these tutorials. Now what is this Ridley directory? And why do we have two Ridley directories? The outer one and the inner one. Well, the outer one is the one that we created and that's the container for this project. The inner one is simply a package that is essentially the core of our project. It has a bunch of settings and that's where everything gets started. So what do we have here? We have init.py. You have seen this before. This tells Python to treat this directory as a package. Below that we have settings.py and in this file, we have various configuration settings for our project. Next, we have urls and this is where we define various url endpoints for our application. And finally, we have WsGI, which is short for web server gateway interface. The purpose of this file is to represent a standard interface between applications, written in Python and web servers. That is an advanced topic and goes beyond the scope of this tutorial. So for now, don't worry about it. Now we're going to use this managed.py to start our development web server. So open up managed.py. Now with our Python code open in VS code, we can select our Python interpreter. So click this Python on the status bar. This is the Python interpreter that is installed globally. We need to change this to the Python interpreter installed in our virtual environment. That is this one here. We get this familiar message, linterpilot is not installed. So let's go ahead and install that. All right, now in this terminal window with with virtual environment activated, let's run Python or Python 3, manage.py run server. Now by default, this is going to start a development server on port 8000. If you have an application that is already listening on that port, you can specify a different port number here. In this tutorial, I'm going to go with the standard port. So let's run this. Okay, you get this warning. You have 15 unapplied migrations. Don't worry about that. We're going to get to that short thing. So as you can see, we have a web server listening at this address. And we can stop it at any time by pressing control C. So now let's navigate to this address. All right, here's our first Django project. Beautiful. Over the next few lectures, we're going to modify this application bit by bit and implement our imaginary video rental application. In Django, a project can contain multiple apps. These apps don't represent that entire application. They represent a small part of an application that is focused on one functional area. For example, let's say we're going to build a website like Amazon. Amazon has a lot of different functional areas such as customer service, orders, shipping, and so on. Each functional area includes a bunch of highly related functions. So with this architecture, we can break down a large complex project into smaller, more manageable, and more maintainable apps. Also, we can reuse these apps in other Django projects. For example, we can build an app that represents a blog and then reuse this app in any websites that needs a blog. Okay? So in this lecture, we're going to create a new app called movies. In this small app, we're going to have all the functionality for displaying the list of the movies as well as the details for a given movie. So let's open up the terminal window. First, we need to stop our development server. So control C. Now here, let's run Python manage.py start app and we're going to call that app movies. All right, let's go ahead. So this created a new directory here movies that don't worry about these use here. The reason you see this is because I added this project under source control. You are not going to see this on your machine and don't worry about it. So what do we have in this directory? We have a directory called myagrations. We're going to look at that shortly below that we have our init file. And again, this tells Python that this is a package. So potentially in the future, we can distribute this package on pipi.org. So other developers can download this package and add it to their applications below that we have admin. And this is where we define how the administration area for managing the movies will look like. Next, we have apps.py. Now the name of this file is a little bit confusing because here we are within the boundary of one app. So why do we have a file called apps.py. But basically we use this to store various configuration settings for this app. A better name would be config.py. So I'm not sure why Django developers name this file apps.py. But that aside, after that, we have models. And here we define classes that represent the domain of this app. For example, in the domain of movies, we could have classes like movie, genre, and so on. Below that, we have tests.py. And this is where we write automated tests for this app. And finally, we have views.py. And this is where we define our view functions. What is a view function? Well, here is an example. Let's say we head over to our website slash movies. When we send a request to this endpoint, Django is going to take this request, pass it to a function, which we call a view function. That view function takes our request and returns a response. That response could be simple plain text like what you see here. It could also be HTML, JSON, XML, image, and so on. So a view function or view in short is a function that takes a request and returns a response. Now, if you're familiar with MVC architecture pattern, here in Django, we have a variation of this pattern called MVT or model view template. The views in Django are like controllers in MVC. If you're not familiar with this concept, don't worry. Let's move on. So views.py is the module where we define our view functions. And that's what I'm going to show you next. All right. Now let's create our first view or view function. So here in the movies app, let's open up views.py and define a function called index. Now, this name is arbitrary. We could call it anything, but usually we use the word index for naming the function that represents the main page of an app. For example, here in our movies app, when we send a request to this address, to this endpoint, our index function is going to get called. So index represents the main page of an app. Now, all our view functions should take a parameter called request. Again, the name is arbitrary, but the object that is past to this function is an HTTP request object. We are not going to call this function Django will take care of doing this. So when we send an HTTP request to an endpoint, Django will figure out based on some configuration what view function should be called. You're going to see that in a minute. Now, in every view function, we should return an HTTP response. So on the top, first, let's import the HTTP response class from Django.htp module. So import HTTP response. Okay. Now in this function, we're going to return an HTTP response object here. I'm going to pass some plain text like hello world on save the changes. Okay, this is our first view. Now we need to map this to URL. So back in the movies app, let's add a new file. By convention, the name of this file should be URL.py. So make sure to spell it properly. In this file, we're going to create a variable called URL patterns that we should set to a list. Again, this is one of the conventions that Django expects us to follow. In this list, we add objects that map your LN points to our view functions. And for that, we use the past function in Django. So on the top, from Django.html, let's import the past function. So we call the past function here to create a past object as a first argument. We should specify a URL endpoint. Here, I'm going to use an empty string. And this will represent the root of this app. For example, in our movies app, we're going to have URL and points like this movies slash that's the root URL. We're going to have movies slash one slash detail. Here, I'm assuming one is the ID of a given movie. So here an empty string represents the root of this app. Now, don't worry about the movies prefix. We're going to add that in the next step. From the perspective of this app, we don't care what the prefix is because we should design this apps for reusability. So maybe another developer wants to download our app from pipe.org and put it under a URL like movies collection. This app shouldn't care where it's hosted. So here, we use relative URLs. Okay. Now, let's delete this. So this is the root of this app. Now, we need to map this to a view function. So we need to import the index function that we created earlier. That is in our views module. So look, the views module is here. So you might think we can import the views module like this. Now, while this is possible in pure Python world, this will not work in Django because of how Django loads these modules. Also, there is a problem with importing the views module like this because it is possible that the application that hosts this app is dependent on a module called views. So with this statement, we'll end up importing the views module that is in the path that is different from the views module we have inside of this directory. So here, we should use a relative import statement. So from period to represent the current directory, import the views module. That is better. Now, back to our past function as the second argument, we need to pass a reference to the view function. That is views that index. Note that I'm not calling this function. I'm simply passing a reference to it. At runtime, when a user stands on HTTP requests to this endpoint, Django will take care of calling this function and give it an HTTP request object. Now, also as a best practice, we should name this URL endpoints. So here, we pass a keyword argument name, we set it to index. So, save the changes. We define this variable URL patterns that contains one or more past objects that map URL endpoints to view functions. We refer to this as a URL configuration. So every app should have a URL configuration. So we're done with configuring URLs for this app, but our main app, the vid app, has no knowledge of the movies app. So if we head over to localhost for 8000 slash movies, nothing is going to happen. Our Django application is not aware of that. So we have to go to the main app that is vid lane. See, once again, here we have URLs.py that defines the URL configuration for our main app. So see here we have URL patterns. By convention, Django looks for this variable when starting our Django project. So make sure to spell this variable exactly as you see here. Now, here in this module, we have a path that maps anything that starts with admin to admin.site.urls. So every Django project comes with an administrative panel that is a separate independent app on its own. We're going to look at that in the future. So here in this list, we need to add a new path object. We're going to tell our vid lane app that any path that starts with movies should be handed off to the URL configuration in the movies app. So here on line 17 from Django.urls, we should import another function that is called include. And here we call that function and pass a string that specifies the name of the module that contains the URL configuration for the movies app. That is movies dot URL. So look, we have this movies directory inside of this directory. We have URLs dot pi. That is why here we need to pass a string movies dot URL. But we don't add dot pi because Django will automatically append the extension and load this module. So with this line, whenever we send a request that starts with movies, Django will chop off the prefix. That is what we have here and send the remaining string to this module movies dot URL. That is the reason in the URL configuration for the movies app, we use an empty string to represent the root of this app. Okay. So back to URLs dot pi, let's save the changes and restart our web server. So here on the terminal, let's run Python 3 manage dot pi run server. We got this error, no module named movies dot URL. Actually, I made a mistake. I should have passed movies dot URLs. We haven't asked that yet. So once again, let's run our web server. Beautiful. Now if you head over to the homepage of our website, you're going to see a page not found error. Don't worry about that. We're going to fix that shortly. But if you head over to slash movies, you're going to see the hell award message. And this verifies that it was successfully mapped a URL endpoint to a view function. The next step is to create the models for this movies app. These models are Python classes that we use to represent our application data. So here in our movies app, we're going to have models like genre and movie. Let's go ahead and create them. So here in the movies directory, let's open up models dot pi. Here I'm going to create a class called genre. And we should derive this class from models that model. What is going on here? So in Django, we have this package Django dot DB. This package encapsulates all the functionality around working with databases. Now in this package, we have a module called models. And in this module, we have a class called model. This class encapsulates a lot of functionality for storing a model object in a database or retrieving model objects, filter them and so on. You're going to learn about them soon. So by inheriting our genre class from the base model class in Django, our genre class will also inherit all that functionality, which means we don't really have to write any code to store genre objects in a database. Django will automatically take care of that. So think of the concept of genre. What attributes should a genre have? Well, in a basic implementation, all we need to know about the genre is its label or name. Is this an action movie or comedy or what? So here I'm going to define a class attribute called name. And we said it to an instance of a field class in Django. So in the models module, we have a bunch of field classes. For example, we have char field to represent a database field that can contain textual data. We also have integer field, we have float field, boolean field and so on. So here I'm going to set this to an instance of the char field class. And here we should pass a keyword argument max length. Let's set this to 255 characters. With this, we can ensure that no genre can have a name longer than 255 characters. And this is one way to prevent security attacks in our application. So a hacker cannot attempt to create a genre with a name that is two billion characters long. So we enforce a limit here. So here's our genre class. Now similarly, we need to create a movie class. So once again, class movie. We derive this from models, the model. Now what attributes of a movie do we need to know? Well, in our imaginary video rental application, we need to know the title for each movie. The year it was published, the number of these movie DVDs we have in the store or in the stock, as well as the daily rental rate. So let's go ahead and create these attributes. We set the title to models that char field. Once again, we have to set max lengths. For consistency, I'm going to set this to 255. Next with another attribute release year, we're going to set that to models that integer field. Now let's create number in stock. Again, we set these two models that integer field. And finally, daily rates. Let's set that to models that float field. So we can store values like 2.95 dollars. Now each movie needs to be associated with a genre. How do we do that? Well, here we should add another attribute genre and we set it to an instance of models dot foreign key. Now with this, we can create a relationship between movies and genres. So as the first argument, we need to pass the genre class because we want to add a relationship between the movie and the genre classes. Right? Now as the second argument, we need to pass a keyword argument that is on delete. And with this, we tell Django what should happen when a genre is deleted? For example, if you have a genre called comedy and we have five movies in this genre, what should happen if you accidentally or deliberately delete the comedy genre? In this tutorial, let's assume that if a genre is deleted, all the movies associated with it should also be deleted. This is what we call cascading. So here we set on delete to models dot cascading. So let me zoom out so you can see the complete code. So up to this point, these are the two model classes that we need in the movies app. And the future we can come back and add additional classes or modify the existing ones. The next step is to tell Django to synchronize our database with the models we have defined in the movies app. And that's the topic for the next lecture. So we have created our model classes. Now we should be able to store our model objects in a database. How? That's pretty easy. Look at this file here, db.esqlite3. This is a blank SQLite database that Django admin automatically created for us. SQLite is a very simple lightweight database that we often use in small applications like applications that we run on mobile devices. But it's not suitable for an enterprise web application that is supposed to serve thousands or even millions of users. So it doesn't have features like security and concurrency. In those situations, we use databases like mySQL, SQL server by Microsoft, Racle, Postgres and so on. The good thing is that Django supports all these database engines. For now, we're going to go with this simple SQLite database. And later in the future, I will show you how to replace this with a mySQL database. Now, what I want you to do is to open up your browser and search for db browser for SQLite. This is a simple application that we use to open an SQLite database. So let me quickly show you. Here it is. So here you can create a new database or open an existing one. I'm going to open the SQLite database in our project. So let's drag and drop it here. There you go. So currently we have no tables here. And that means we have to create a couple of tables in order to store movies and genres in this database. Having said that, when using Django, we don't have to manually design these tables. We can have Django automatically create them for us based on our models. So every time we create new model classes or modify existing ones, we tell Django to compare our model classes with our database. Django will look at our database. It will figure out what tables and columns we have. Then it will calculate the difference between our model classes and our database tables. And based on that, it will create a migration. A migration is essentially a Python file that includes some code. When we run that, it will synchronize our database with our model classes. Let me show you. So let's open up a terminal window and run Python manage.py make migrations. Now it tells us that no changes are detected because by default Django is not aware of our model classes. So the first step is to register our movies app with Django. Let me show you how to do that. So here in our project, inside the Vittla package, open settings.py. As I told you before, this file contains various configuration settings for our application. One of the settings is installed apps. And these are the apps that are installed by default. So the first one is admin. And this creates an administration panel for us. You're going to see that soon. We have us, which is an authentication framework, with this will be able to authenticate users and see if they have permission to perform various tasks. We have content types, which is a framework for creating generic relationships with model classes. We look at this in the future. Below that we have the sessions app, which is a framework that allows us to temporarily store data about the current user. Next we have the messaging framework and we use that in situations where let's say the user creates a new movie, then we redirect them and display a message like the movie was successfully created. And finally we have static files, which is used for managing static files like CSS files, images and so on. Now in most applications, we need pretty much all these install apps. But if you don't need any of these apps in your application, you can simply come back here and delete that app. Now in this demo, we need to register our movies app here. So Django can keep track of our model classes in that app. So back to our movies folder. Here we have this file apps.py. Earlier I told you that here we can have various configuration settings for the movies app. So look at the name of this class movies config. This class is in the apps module of the movies package. So to register the movies app with Django, we need to provide the complete pass to this class. So back to settings.py. Here we add movies, that's our package, then we go to the apps module and finally movies config save the changes. Now back in the terminal, let's run the make migration command one more time. Okay, this time Django detected that there are some changes in the movies app. So it created a migration that is inside movies slash migrations slash this file. Let's have a quick look at this migration. So here we have a class called migration and in this class, we have a couple of operations for bringing our database up to date with our current model classes. So here's the first operation for creating a model you can see the name is set to genre and here are the fields of the genre. So we have ID and name. Now in RECode, we only specified the name field. We didn't add the ID field Django automatically takes care of that. So it ensures that every object has an ID property that unique identifies that object. Similarly, we have another create model operation for creating the movie table and in this table, we're going to have this field ID, which is added automatically plus all these fields that we defined in RECode. Now this migration is not executed yet. It simply describes the operations that need to be performed on the database to bring it up to date with our current model classes. So the next step is to run this migration. Now let me show you something. Let's run Python manage.py run server. Earlier you saw this error, you have 16 unapplied migrations. That basically means we have migrations that need to be executed. Earlier we had 15 migrations. Now after adding these two classes, we have a new migration. So we have a total of 16 unapplied migrations. So let's stop the server with control and see and run Python manage.py migrate. This will run all the pending migrations on our database. Let's go ahead. Beautiful. We can see all these migrations are applied. So as we can see, each of these migrations is prefixed with the name of the app that contains it. So here we have a migration for our content types app. Here's another migration for our auth app below that we have three migrations for our admin app. So each app can have its own models and migrations. Now after all these migrations, you can see the migration in our movies app. Now if you open our SQLite database one more time, you can see we have a total of 13 tables. Each of these tables is prefixed with the name of the app that contains it. So here are the two tables for our movies app. We have movies underline genre and movies underline movie. So the table names are in singular. Of course, this is done by convention and we can always override that in the future if we want to. Now let's expand the movie table. So we can see we have these columns ID title release year and so on. So we didn't have to manually create any of these tables. Django automatically created this for us. Also, we have this table Django underline migrations. Django uses this table to keep track of the migrations that are applied on the database. So let's go to browse data tab and from the list of tables select Django migrations. You can see these are the migrations that are currently applied on our database. If you scroll down, you can see here we have migration for our movies app and this is the name of the migration. And here's a date time that this migration was applied. Let's go through this workflow one more time. So here on our movies app, let's open up models.py. Here's our movie class. I'm going to add a new attribute called date created. So date, underline created, we set this to models that date time field. And here we can optionally supply at default value. And here we can import the date time class from Python standard library and write some code like this date time. Now, but the problem with this approach is that this date time object is not aware of time zone. A better approach is to use the time zone object in Django because that object is aware of the time zone. And later in the future, when we display this date time value to the user, that object will automatically take care of translating that daytime to the user's time zone. So let's delete this on the top from Django dot utild. Let's import the time zone class. Now down the bottom, we said the default argument to time zone dot now. Now note that here I'm not calling this method. I'm simply passing a reference to the now method. If I call this method, when I create a migration, the current date time will be hard coded in our migration. Let me show you what happens. So here I'm going to call this method, save the changes. Now we need to create a migration. So here on the terminal, let's run Python manage that pie make migrations. We got it warning. It seems you set a fixed date time value as a default for this field. What does this mean? Well, we'll have to look at this migration migration number two and it's called movie date created. So let's go to our project here in the migrations folder. Let's have a look at this migration. So in the list of operations, we have this operation for adding a field to an existing table. Here's the name of our model or table and this is the name of the new field and we can see its type is set to a date time fill so far so good. But look at the default value. It's hard coded here and that is the current date time on my machine. We don't want this to happen. We want this value to be calculated at runtime when we insert a new record in this table. So to fix that, we need to come back to our movie class and instead of calling the now method, we simply pass a reference to it. Now save the changes. Now we need to create a new migration. So let's open up the terminal and run Python manage that pie make migrations one more time. All right, now we have migration number three. Let's take a quick look at this migration. There you go. So here we have an operation of type alter field. So this operation is going to go to the movie table and alter a field called date created. And this is how it's going to alter this field. So it's going to set the default to Django.util.timezone.now. So note that the current date time is not hard coded in our migration. Okay, so let's go ahead and apply these two migrations to our database and by the way, make sure to never delete any of these migrations. Otherwise, you're going to run into all sorts of issues because the purpose of each migration is to take the database one step forward. When you delete one of these migrations, they would be a missing step. So do not ever, ever, ever, ever delete a migration here. So back in the terminal, let's run python manage.py migrate. Okay, the second and third migrations are applied beautiful. Like here in our database, you can see our movie table has this new field date created. Beautiful. Now one more thing before I finish this lecture. As you have seen, each migration is essentially a python class that determines how our database should be updated. Now when we run the migrate command Django is going to look at these migrations that are not applied. And based on the operations that they define, it's going to generate some SQL statements to send to the database. If you're curious what SQL statements are sent to the database, you can use the SQL migrate command. Let me show you. So let's say we want to know what SQL statements are generated as a result of applying this third migration. So here on the terminal, we run python manage.py. Instead of migrate, we're going to pass SQL migrate and then we specify our app. In this case, the movies app. So we go in this app and pick a specific migration. So here in the movies app inside the migrations folder, we have three migrations and they're prefixed with a number that unique identifies each migration. So I'm going to pick the first migration. So back to the terminal. Let's add triple zero one. All right, this is the exact SQL statement that is sent to the database. So for creating the movies table, we have this create table statement. Here is the name of the table next to that you can see all the columns, their type and so on. All right, our database is in a good shape. Now the next step is to allow the staff at our imaginary video rental store to populate the list of movies. So we need to create an administration panel for them. However, when using Django, we don't have to do this manually. So all Django applications come with a powerful administration interface. Let me show you. So first, let's open up the terminal and run our development server. So Python, manage.py, run server. Okay, now back to the browser. Let's head over to slash admin. Look, this is the entrance to our administration panel. So by default, we get this login screen. This is coming from the auth app that is installed by default. Earlier we talked about this settings.py. You saw the list of install applications. The second app here is the auth app. So this is the app that knows all about authenticating users. And this login screen is implemented inside of that app. So as you can see, that app is a small reusable package that we are using in this project. By the same token, we can create small reusable apps that other people can use in their projects. Now back to our login screen. Currently, we don't have any users in our database. So the next step is to create a super user back in VS code. I'm going to open a new terminal window. So we don't have to stop our server and restart it. So let's click this. Now let's run Python, manage.py, create super user. Let's enter a user name. I'm going to use admin with this email address. And finally a password. Now if we use a weak password like 1 to 3, 4, one more time, this is going to complain telling us the password is too short or too common, whatever. So here we can bypass the validation and go ahead or create a stronger password. For this demo, I'm going to go with 1, 2, 3, 4. So yes, okay. Super user created successfully. Beautiful. Now back to our login screen. Let's login with admin and 1, 2, 3, 4. Okay. So here's our administration panel. We can manage the list of groups and users. So we can put users in different groups like admins, moderators, guests, and so on. So let's go to the list of users. Here we get this beautiful table that shows all the users in our database. We can sort this list by various columns. We can filter them. We can search for users and so on. Now back to the main page. Currently we can only manage the users and groups. We cannot manage our custom models like genres and movies. But we can easily bring them here with only a single line of code. Let me show you. Back in our movies app, here we have this admin file and this is where we register the models that we want to manage using our administrative interface. So let's open this file. All right. Here we need to import our genre and movie classes. So from the models module, in the current folder, remember, this period indicates the current folder. We need to import the genre and movie classes. Now finally we're going to say admin.site.register.general. And let's duplicate this line and register the movie class. So with these two lines, we're telling Django to register these models in the administration interface. So let's save the changes. Back in the admin, let's refresh the page. Now we have these two models in our movies app. So let's go to the list of genres. In this list, we have one genre that is genre object one. What is that? Well, before recording this video, I created a genre record in the database. So here you can see that in our genre table, currently we have one record with ID1 and name action. I created this just before recording this video. So this one that you see here is the idea of our genre record. Now this table is not very user friendly. It would be better if you had two columns, ID and name and we could see the name of each genre right here. So in the next lecture, I'm going to show you how to customize this administration interface. So the reason our genre is displayed as genre object one is that this is the default representation of a genre object as a string. So one way to fix this problem is to overwrite the stir magic method in the genre class. Let me show you. So back in VS code in our movies app, let's open up models.py. So here's our genre class. In this class, we can overwrite the stir magic method to specify the string representation of a genre object. So let's define a method called stir. These two underscores represent a magic method. So as the first parameter we need to add self. Now here we simply return self dot name. So we want to use the name of a genre to represent it as a string. Save the changes back in admin, refresh the page. Now we see the actual name of a genre. Beautiful. Now let's take this to the next level. Let's say we want to add another column here to see the idea of each genre. For that, we need to go to our movies app and open up the admin.py module. Earlier we registered the genre class with admin. Now to customize how we worked with genres in our admin panel, we need to create another class called genre admin. Now to customize the list of genres in admin, we need to create another class here called genre admin. Let me show you. So we define a class called genre admin. The name doesn't matter, but by convention we use the name of our model plus admin. Now we should derive this class from admin.modeladmin class. So on the top look, we're importing this admin module. In this module we have this class model admin, which is the representation of a model in the admin interface. Now by deriving this class from model admin, we're going to inherit all those features and then we can overwrite some of them. For example, here we can set list underline display attribute to the list of fields that we want to show here in this table. So back here, we set this to a top, and in this top, we specify all the fields that we want to display. So we want to display the ID field followed by the name field. Save the changes. Now when registering this genre, we should also pass this genre admin model. Save the changes one more time. Back on admin, let's refresh this page. There we go. We have two columns ID and name beautiful. So let's go ahead and add a new genre here. Here's our genre form. Currently we only have one field name. ID is not here because its value is automatically generated by our database. This way we can ensure that every genre has a unique identifier. So let's create a new genre comedy. Now let's save this. Okay. So here's our second genre. Beautiful. Now here on this side map, let's go to our movies app. In this app, we have the list of genres and movies. Let's look at the list of movies. Currently we have no movies here. So let's add a new movie. I'm going to call this Terminator release here. I guess 9 in AD. I don't know let's say we have five DVDs of this movie in the stock and the daily rental rate is 1.95. And below that, we have this drop down list to select a genre. So I'm going to set this to action. See we get all these for free. We didn't have to manually create this form. Django automatically created it for us. And that's the beauty of using Django. Also below that we have date created. So here we have the date component followed by the time component. Here we have a calendar. We can select the date from it's really powerful. That's one of the reasons I love Django. Now earlier when we added this date created field, we set a default value for it based on the current date time. And you can see that populated here. Now let's say we don't want to have this field on this form. We can easily hide it. Let me show you how. So back to our admin module. Now similar to genre admin, we're going to create a model admin for our movie. So let's create another class movie admin. And we drive this from admin that model admin. Here we have a couple of attributes that we can override. We can use fields to specify the fields that we want to show on our form. So we set this to a top all. Let's say we want to display the title and genre fields or we can use the exclude attribute to specify the fields that we want to exclude. Once again, we set this to a top all. In this case, I want to exclude date, underline, created. Now because this top all has only one item, we need to add a comma here. Otherwise Python thinks this is a string that we have wrapped in parentheses. So here's our movie admin model. Now we need to pass it while registering the movie class. So movie admin. Save the changes. Back to the admin. You can see the date created field is no longer here. So there are various ways to customize the admin interface. Now let's go ahead and create our first movie. So one more time, Terminator, 1985, 10, 195. And by the way, look at the type of these fields. So here we have a numeric field because we set the type of this field to a float. Now finally, let's select the genre to action and save the movie. Now here on the list of movies, once again, we have the general representation of a movie as a string. So let's go ahead and add three columns in this table. Back to admin module. In the movie admin class, I'm going to override the list display attribute. Let's set this to a top all with three values. Title, number, in stock, and daily rental rate. Save the changes. Back here, refresh. Oops, our web server crashed. So let's go back to VS code and look at the terminal to see what happened. We got this arrow. The value of list display to refers to daily rental rate, which is not a callable and an attribute of movie admin. So looks like I made a mistake here. The name of this field is actually daily rate. So delete. Save the changes and let's try it one more time. All right. So we successfully customized the movies table. So we're done with the admin panel. The next step is to display the list of our movies in the public area of our website. Erdi rebuilt a view function to respond to requests sent to the sign point slash movies. That currently we're only displaying this hello word message. That's pretty boring. So over the next few lectures, we're going to modify this page and display the list of movies in our database. So here's the movie class we created earlier. As you can see, we derive this class from the model class in Django. But why? Because this model class gives us a bunch of methods for creating, retrieving, updating and deleting objects from our database. So if you want to store a movie object in our database, we simply call one of these methods called save. That save method will internally take care of generating the right SQL statements to update our database. This is what we call a database abstraction API. So this model class gives us an API, which is short for application programming interface. And this API abstracts away the complexity of working with the database. So now let me show you how to use this API to get the list of movie objects from our database. So in our movies app, let's open up the views module. So here's the index of your function that we created earlier. Currently we're returning this hello word. Now we're going to use our model API to get all the movie objects from our database. So first on the top, from the models module in the current folder, let's import the movie class. Now in this function, we simply write movie dot objects dot on with this statement, we can get all the movie objects in our database. So when we call this at some point Django is going to generate a SQL statement like this, select star from movies underlying movie. We also have a method for filtering records. So that is movie, the objects that filter here, we can pass arbitrary keyword arguments like give me all the movies with release your set to 1984. When we call this at some point Django is going to generate a SQL statement like this, select star from movies underlying movie, where release your equals blah blah blah. We also have a method for getting a single object. So movie, dot objects that get and here we pass a keyword argument. Let's say we want to get the movie with ID equal to one. We also have methods for saving movie objects or deleting them from our database. So these methods represent our database abstraction API that simplify a lot of cases. Now sometimes we're dealing with complex queries. If these methods don't do what we need, we can always send raw SQL statements to our database. Now that is right. In this demo, let's call the all method to get the list of movies from our database. So movies. Now I'm going to use a list comprehension to get the title of these movies. So I'm the title for M in movies. So now we have a list of strings. We can join these strings using a comma as a separator like this. So a string of comma. Join. So this will combine all the elements in our list and return a string. We can store that here in output. And finally, instead of this hello world, we can send the output. Save the changes back in the browser. Let's refresh. There you go. So just before recording this video, I added another movie hangover. So this verifies that we could successfully get all the movies from our database. But we don't want to display them like this. You want to render them using some HTML markup. And that's what I'm going to show you next. In this tutorial, you're going to learn how to return HTML content from your view functions. So here on the top, you can see we're importing this render function. We use this function to render a template. So in our index view, let's delete line eight. We don't want to format the result as a string. So we have the list of movies. Now, instead of returning an HTTP response, we want to call the render function. The first parameter here is the request. So we pass this request object that we get here. The second parameter is the name of our template. We haven't created this yet. But for now, let's just pass index.html. And the third parameter, which is optional because it has a default value of none, is the context object, which is basically a dictionary that we use to pass data to our template. So in this case, we want to pass the list of movies to render as HTML. So here we pass a dictionary in this dictionary, we add a key called movies. And we set this to our movies object. Now, finally, we need to return the result of the render function, save the changes. Okay, the next step is to create our template. So here in the movies app, let's add a new folder by convention. We should call that templates because that's the name that Django looks for. Okay, in this folder, let's add a new file index.html. For now, let's just render something really basic to make sure all the plumbing is working. So let's add an H1 Hello world. Okay, save the changes. Now, back in the browser, let's refresh this page. Okay, all the plumbing is working. So now let's render the list of movies in this HTML template. Now, back in VS Code, look at the language that is currently selected to edit this document. By default, this is set to Django HTML, which brings a bunch of snippets for quickly generating some Django code. You're going to see this in a minute, but let's temporarily change this to HTML. So click this and type HTML. Now, here, I want to show you a powerful feature that is not available when using Django HTML as the language to edit this file. And that feature is called Zencoating. We that we can quickly generate some HTML markup. See what I'm going to do. Let's say we want a table with the class table inside this table. We want to have a T head section and inside the T head section, we want a TR inside this tag, we want to have three TH tags. So TH times three. Press the tab. There you go. This is what we call Zencoating. So the first column is the title of the movie. The second is genre. Then we have stock. Let's add one more column and call it daily rate. So this is our table heading. Now, let's create our table body. So one more time, T body, inside this tag, we want to have a TR with four TD tags. So TD times four tab. There you go. Now, we want to render this TR dynamically. So basically, we want to iterate over all the movies that we get in this template. And for each movie, we want to render a table row. That's where we use Django template syntax. So in Django templates, we can execute some logic using template tags like this. So we open our curly brace, add a percent, and also close it with a percent. Now, in between these braces, we can write some logic that can infstate man or loop. So here, we want to use a for loop for movie and movies. Now, earlier, we used a context object to pass a dictionary to this template. And in that dictionary, we had a key called movies. That is why we can access this object here. Now, writing logic using template tags can be a little bit tedious. So that's where we switched the language from HTML to Django HTML, which brings a bunch of snippets for automatically generating some code. So let's delete this line and type four. Look at these items here. Anytime you see an item with this square icon, that represents a code snippet. So here I can press enter. And this automatically generates a code snippet for for loop. So here we can type for movie, press tab. Now we are in the second placeholder, movies, now press tab. Now we are in the third placeholder. And this is where we want to render our table row. So I'm going to select this TR and move it right here. Now, let's also indent it. There you go. So this is what we call a template tag. And we use it to execute some logic. Now here in our TR, we want to render some content inside each TD tag. So we use another syntax with double curly braces to render the value of a variable. So in this case, we want to render movie the title. Similarly, we want to render movie.john. Next is stock. So movie.number in stock. Unfortunately, we don't have intelligence here. So that's something that you'll have to live with. And finally, we want to render movie.DailyOnTheLineRate. So essentially in Django templates, we have two special notations. One is double curly braces for rendering a value. And one is curly brace followed by a percent to execute some logic. We use that to execute loops as well as conditional statements. And finally, you can see that our for loop is terminated with an N4 template tag. So save the changes back in the browser, refresh the page, and here's our imaginary table of movies. Currently, it has no styles. But if you inspect any of these elements, you can see that here we have an HTML table. Now back in this template on the top, let's remove this heading. We don't already need this. Save the changes. And one last thing before we finish the lecture. Let's open up the views model. Look at this red underline. Piling is complaining that the movie class has no objects member. Basically, the reason this is happening is that Piling is not familiar with Django objects. But this is pretty easy to fix when it to install a package called Piling Django. So let's open up a new terminal window and run pip and install pylent-jango. Okay, the package is installed. Now the next step is to create a file in the root of our project. So let's collapse, let's fall there. Here in the root, let's add a new file. We're going to call that dot pylent-rc. So this file has no name. It only has an extension. Piling rc. This is the configuration file for Piling. Here we need to tell Piling to load this plugin that we just installed. Piling-jango. So we set load-plugins to pylent-jango. Save the changes. Now back in the views, you can see the compilation error is gone. And one more thing before we finish this lecture, here we passed index.html as the name of our template. While this works, there is a problem with this approach that you may face in a real enterprise application. Let me show you. So temporarily I'm going to change this to index 2. Obviously we don't have this file on this. So we're going to get an error. Back to the browser, let's refresh this page. We got this error, template does not exist. Now if you scroll down, here we can see the paths that Django searches for to find this template. So here we have three paths. The first one is for the admin app. So admin slash templates slash index 2.html. The second one is for the OSAP. So here's the OSAP. It looks in the OSAP slash templates slash index 2.html. Now the source code for these two apps is not part of our project, but they actually exist in our virtual environment. So here is the path to our virtual environment. Somewhere here we have this directory, site packages, slash Django, slash Contrib, slash Auth, and so on. Now the third path here is for our movies app. So vitley slash movies slash templates slash index 2. Why does this matter? Well, in a real project, we're going to have multiple apps. As we can see, when we try to render a template, Django looks at the templates folder of all the installed apps in the order. So here in our settings module, you have seen the list of installed apps before. So we have admin, auth, and so on. So when Django tries to find a template, it starts here on the top. It looks at each app. If that app has a templates folder, it will search the templates folder of that app to find the given template. And that means if we use a general name like index.html, it is possible that Django loads the index.html of another app that is installed first, not the app that we are currently working with. So as a best practice, we should give a namespace to this template. Here's how we do it. In our templates folder, we add another folder, movies. That is our namespace. Now we move index.html, inside this folder. Move. And then in our code, we always prefix our template name with movies slash. Well, that depends on the app we're currently working with. So all the templates for the movies app should be prefix with movies slash. Now save the changes back in the browser, refresh the page, problem is solved. So these are a table, but that looks pretty boring. In your next lecture, I'm going to show you how to install bootstrap and give this page a nice and modern look and feel. In this lecture, we're going to add bootstrap to our Vittling application. In case you're not familiar with bootstrap, it's basically a very popular CSS framework that gives our applications a modern look and feel. It's responsive a mobile friendly right out of the box, so we don't have to do any extra work. So head over to get bootstrap.com. Then go to the documentation page. Here we can find the instructions to add bootstrap to an existing website. So basically, we have to add a CSS file and here's the URL of that CSS file in the cloud. You can also download it and add it as a static file in your project, which will also load a bunch of JavaScript files. Now below that, you can see the starter template. So let's copy this template. Now back in our project, in the templates folder of our movies app, inside the movies folder, let's add a new file, we're going to call that base.html. So this is the basic template for all the pages in our movies app. Let's paste the starter template that we just copied. Okay. Now here on the top, let's change the title to Vittling. And in the body section, let's remove this H1. Instead, we want to define a placeholder for our other templates. So when we render the list of movies, that template is going to return an HTML table. We want to render that HTML table right here. So we need a placeholder for our views to render their templates in. And that is pretty easy to define. Here we can type block. Again, this is one of the code snippets that is available when using Django HTML as the language to edit this file. So let's press enter. Now here we have multicursor editing. So whatever we type comes after block and end block. We're going to give this block a name. Let's call it content. Now press the escape button and remove the second content here. We don't really need to add that to end block tag. So this is our content area. Save the changes. Now let's go back to our index template. We can open the file here or let me show you if you're on Mac, press command and P. If you're on Windows, press control and P. Here we can easily find the files in our project. So let's search for index.html. There you go. Now on the top, we need to use another template tag called extend. So with Django HTML selected as the language for this file, let's type extend press enter. What is the template that we're extending? That is base.html. Now where should we put this table? We should put it in the content block that we just defined. So one more time, we use the block template tag. As you can see, again, we have multiple cursors activated. So press the escape button a couple times. Now you have only a single cursor. So let's type content. That's the name of our block. Now we need to move our table in between the block tags. So I'm going to select this line and press alt and down arrow to move it down like this. There you go. Now let's also indent this table tag. That is better. Save the changes. Back in the browser. Let's refresh this page. We got a template load error because Django cannot find our base.html template. Once again, look here are the paths it's searching for. So it's looking for admin slash templates slash base HTML. Similarly, we have another path for auth app and one for the movies app. Now look at the path that is used for the movies app. That is movies, slash templates slash base that HTML. But as I told you as a best practice, we should name space our templates. So in this case, it's based on HTML. It doesn't really exist in this folder. It's under the movies folder inside the templates folder. So to fix this problem, we need to go back on the top and use our namespace that is movies slash save the changes back here, refresh the problem is gone and our page looks a little bit better. Now let's take this page to the next level. Let me show you how to add a boost trap navigation bar on the top. So on boost trap documentation on the left side, look at components. Here we have various components like alerts, badges and so on. In this list, you can find navbar. Okay. And on this page, we can see various examples of a boost trap navigation bar. So we can have a navigation bar with drop down lists. If you scroll down, you can see a very simple navigation bar called brand. And below that, you can see the HTML markup to render this navigation bar. So let's copy this. Now back to our base.html. Right after the body tag, let's paste this navigation bar and then change navbar to vitley. Save the changes. Back here, let's refresh. So here's our navigation bar. That is better. Now this table is currently taking the entire width of the page. Let's make it center. So back to base.html, we should wrap this content block inside of a main element with the container class. So in boost trap, you want to create a main tag with the class container. And then we want to put this block inside of the main tag. Save the changes. Back in the browser, refresh. There you go. That is better. Also, let's add the vertical borders to this table. So back to our template index.html. Here's our table. Let's add another class table dash bordered. Save back in the browser, refresh. So that looks better. Also, I'm going to add another class table dash hover. And with this, we get let's refresh. We get this nice effect here. So our application looks better now, but there is a problem. This base template that we defined that contains this navigation bar, exists in the movies app. What if we had several other apps in this project? We don't want to redefine this bootstrap template in every single app. So in the next lecture, I will show you how to share a base template across multiple apps. In this lecture, you're going to learn how to share a base template across multiple apps. So currently in our movies app, we have this base template. We want to take this out of this app and put it somewhere central. So let's collapse this folder. And create a new folder in the root. We're going to call that templates. Now let's go to the movies app and get this base template and move it into the new templates folder. So drag and drop, move, beautiful. Now let's go to the index template of the movies app. Currently, we're referencing the base template in the movies app, but this template is no longer there. So let's remove the prefix or namespace, save the changes back in the browser. Let's see what we get. So Django cannot find this base.html template. And if you scroll up, you can see the paths that Django searched for to find this template. As you can see in this list, Django by default only looks inside the installed apps. So currently the installed apps that have templates are admin, auth and movies. But this template's folder that we just created doesn't belong to any apps. So we need to tell Django to search in this folder as well. So let's open up our settings file that is inside the vitl app or we can press command and peon mac or control peon windows and search for settings pi. Now in this file, somewhere we have the templates settings. There you go. So look at these properties. The back end is set to Django.html.html.html.html. So this is the engine that comes with Django that processes our template files. This is the engine that is aware of those double curly braces syntax or the template tags. Okay. Now the second property here is the directories that Django should look for to find templates. This is set to an empty list by default. So we'll have to add our new templates folder here. Below that we have app directory set to true. And this is telling Django to search in the templates folder of the installed apps. And finally we have this context processors. So by default, we have four context processors. The first one debug adds debugging information to the context object that is passed from the view to the template. The second processor is called Request. And this adds the request object to our context. So we can access it in our templates. Similarly, we have another context processor, Oss. And this is used to bring information about the current user in our templates. And finally, we have messages. And this is used in scenarios where the user creates a new movie. And we want to display a message like the new movie was created successfully. So back to the business here. Here we need to add our new templates folder. So this is the code that we need to write. We need to go in the OS module from there we go to the past module. Here we have a function join for joining multiple paths. We want to get the base directory of this application. This is a known predefined variable in Django applications. Now we want to join this with the templates folder that we just created. Save the changes. So with this Django will start searching here. And if it can't find the template, then it will look at the installed applications. So back in the browser, let's refresh. There you go. Now we have a base template that can be shared across multiple applications. Now our video application currently only displays the list of movies. It would be nice if we could click on a movie and see its details. So the first thing we need to do is to define a URL that takes a parameter like movies slash one where one is the idea of a movie. So back in VSCode in our movies app, let's open up urls.py. Here we need to define a new URL pattern. So let's call the path function. As the first argument, you're going to pass a string like this. We use angle brackets to define a parameter. Let's call that movie on the line id. Now to refresh your memory, earlier I told you that the main urls module in our project hands off any urls that starts with movies slash to this urls module in the movies app. Let's take a look. So here in the vitley folder, let's open up urls.py. So here we define a url so we're telling Django that any url that starts with movies slash should be handed off to the urls module in the movies app. Now back to the movies app. When we add a parameter here, that represents a url that looks like this because all the urls we're working with in the small jule start with movies slash. Okay. Now we need to map this to a view function. So views, let's call that detail. Currently we don't have that, but we're going to create it soon. Now as a best practice, we should also give it a name. These names are useful in situations where we have multiple references to a url. Let's say slash movies slash one. Now for whatever reason, we decided to change this url to something like this. Let's say old system slash movies slash one. If you have multiple references, multiple hard coded references to a url like this, then we'll have to update all those references to the new url. So that's why we use names here. These names should uniquely identify urls. So in our 10 plays, instead of hard coding these urls, we reference them with their names. And then in the future, if you want to change the url, we can change it in a single place. I'm going to show you that later in the section. So back to the business, let's call this detail. And also as a best practice, it's better to name space this name, so movies on the line detail and movies on the line index. So this is our url pattern. Now let's go ahead and create this view function. So if you're on Mac press command and P, if you're on Windows press control P and search for views in the movies app. Okay. Now let's add a new view function. We call that detail. It takes a request and also a parameter called movie ID. Because in our url pattern, we use the keyword movie ID. So when we send a request to, let's say movies slash one, Django will automatically extract one. And then it will call this view function and pass one as an argument for movie ID. Okay. So for now, let's just return an HTTP response with this movie ID. Save the changes back in the browser. Let's head over to movies slash one. So we get one here. Let's change this to two beautiful. Everything is working. However, I can pass a non numeric value like a and that also gets passed as the movie ID. But as you know, in our model, our movie IDs are integers. Look, here's our movies table. The first column is ID and it's an integer. So by default Django uses an integer for primary keys, but we can always change that if you want to. So back to the url module. Here I'm going to use a type converter to convert this value to an integer. So we prefix that with int colon. Save the changes now, back in the browser, if we pass a as the movie ID, let's see what happens Django cannot find that page. So this is some level of protection. We can ensure that we only get numeric values for our movie ID parameter. Now let's change this back to one beautiful. So in the next lecture, we're going to get the movie object with this ID and render it on this page. So here's our detail view function. In this function, we get the movie ID. So we can use our movie model to get the movie with the given ID. So movie that objects earlier, you saw the all method for getting all the movies from the database. We also have another method for getting a single movie. I hear we pass a keyword argument like ID equals movie ID. We also have a known keyword PK, which is short for primary key. You can use either ID or PK. So we get a movie with this ID. Now we need to put this in a template, render it and return the result. So here we return render. We pass a request object. Then our template is going to be movies slash detail.html. See the convention I'm following. So I'm naming my templates based on their view functions. Okay. So back here finally, we need to pass our context object, which is a dictionary. Here we're going to have a key called movie and we set it to this movie object. Save the changes. Beautiful. Now let's create our template. So in the template folder inside the movies folder, let's add a new file, detail.html. In this template on the top, first we need to extend the base HTML template. Then we need to define a block. So block. The block we're going to use is the content block. So here I'm going to press the escape button a couple times to disable multi cursor editing and type content. Now in this block, I want to render a description list tag. So temporarily I want to change the language of this file from Django.html to HTML. We also have a shortcut for that. So you can press shift, command, and P on Mac or shift control P on Windows. Here type language. And the first item is change language mode. Enter. Let's change this to HTML. Okay. Now when we change the language to HTML, you can see we don't get the syntax highlighting. So these tags are not recognized. Now we want to create a DL tag inside this tag. We want to create a DT. And next to that, we want to have a DD. So in this case, DL is short for description list. In the description list, we have one or more pairs of DT and DD, which are short for term and description. Now we want three of these. So I'm going to wrap these in parentheses and multiply it by three tab. Beautiful. So the first term we want to add here is the title of the movie below that will render the actual value. So double curly braces, movie the title. The second term is genre. And similarly, we're going to define it here. Movie dot genre. And finally, let's add stock. So movie dot number in stock. Let's save the changes. Our formatting is completely messed up. So let's change the language back to Django HTML. One more time, change language to Django HTML. Now I have to manually fix this formatting like this. Okay, better. Now let's test our new view. So back in the browser, let's refresh this page. And here's how a description list is rendered. Now because also I'd these in a table, that's a matter of personal preference. So our application is working out to this point. But what if I pass an invalid movie ID here? Let's say 10. We get an exception of type does not exist. That is not good. So the common pattern to handle this situation is to return an HTTP 404 error. 404 is the standard HTTP error that says the page or the resource for looking for does not exist. So to fix this problem, we need to handle this exception and return an HTTP 404 error. So we wrap this in a tri-block and then catch the exception. So here we add except the exception is of type does not exist. And this exception class is part of our model. So movie dot does not exist. Let's have a quick look at this class one more time. So I'm going to go in the models module. Here's our movie class. We direct this from the model class in Django. This model class defines this exception does not exist. And that is why it's inherited in our movie class as well as any other models in our project. So we handle this exception. And here we'll return a 404 error. So on the top from Django dot HTTP module, we need to import HTTP 404 class. Now back to our view function. When we catch this exception, we should raise the HTTP 404 exception. So instead of returning, we're going to raise HTTP 404. Because this is an exception class that we need to raise. So save the changes back in the browser. Let's pass an invalid movie ID here. And we get a page not found with a status code 404. Now back to our view function. Every time we have to get a single object and render it, we'll have to follow this pattern. We have to add this tri statement, get the movie, render it, and then catch an exception of type does not exist and then raise an HTTP 404 exception. In a real application where you have a lot of view functions like this detail view function, this pattern ends up being so repetitive. So that's why we have a shortcut for that in Django. Because as I told you before, Django is focused on productivity. So we can build applications with less code. So on the top, here we have this module Django.shortcuts from this module. Let's import get object or 404. This is a function. This function implements this pattern. So we don't have to repeat it in every view function. So now we can simplify this view function like this. We remove try and accept statements. Now instead of getting a single object using the get method, we're going to use the shortcut function that we just imported. So let's delete these. We call get object or 404. We passed the primary key and this function will automatically raise a 404 exception if this movie doesn't exist. Now save the changes back in the browser, refresh. Oops, I missed the first argument. So here this function should know what kind of model to work with. So earlier we used the movie class, the movie model. But currently when calling this function, we haven't specified this model. So this function doesn't know what model it should query. So as the first argument, we need to pass our model class that is movie. Okay. Now save the changes and refresh this one more time. Now we get a page not found there. All right. Now let's modify this page and add a link to each movie. So we can navigate and see its details. So here on index.html, this is where we are rendering our movies. Here's our first column where we render the movie title. Let's add an HTML anchor here. So here we set a treff to slash movies slash. Now we want to render the idea of the movie dynamically. So once again, we use double curly braces movie dot ID. And then we move movie that title right in between the anchor tags. Save the changes back here. Let's go to the movies page, refresh. So now we have the links here, beautiful. We can click and see the detail for each movie. However, while this implementation works, it's not the best way to reference URLs. Because earlier, I told you that tomorrow, it is possible that we change all these URLs to something like this. All systems slash movies. Now technically, we should not change URLs because a URL is a contract of an application. So if we change URLs, any applications that depend on those URLs are going to break, but you know, the real world is unpredictable. So sometimes these things happen. So let me show you a better way to reference a URL back to our URLs module earlier. We assigned a name to each URL. Now we can reference these URLs using their names. So back in index at HTML, let's delete what we have in the href attribute. Here we're going to use the URL template tag. So we add curly braces, percent, and type URL. This is our URL template tag with this tag and we can get an actual URL like this. So first we pass the name of our URL. In this case, movies underline detail. And then optionally, we can pass any parameters if they exist. In this case, we want to pass movie.id. Save the changes. Back to the movies page, refresh. We still get the same result. Beautiful. Now let's take this to the next level. Back to the URLs module. Earlier, I told you that it's a good practice to prefix all these names with the name of our app like movies underline. We did that so Django with an accidentally picking your own with the same name from a different app, just like how we namespaced our views. So this was a good practice. However, let me show you a better way. Here we can set a known variable app underline name to the name of this app, let's say movies. Django is aware of this variable name. Now, when we set this app name here, we don't have to repeat movies underline in multiple places. Now here we have only two URL patterns. It's not a big deal, but if you have a large number of URLs, this is going to get a little bit messy. So let's delete this and also here. Now we go back to our index.html. And instead of using an underline, we use a colon. When Django sees this, it knows that we're talking about the movies app. And in that app, we should have a URL name detail. But this will only work if we set the app name variable to movies. So as you learn about Django, you realize that there are various ways to write less code, but of course, that means there are a lot of conventions that you have to learn about. So for sure, there is a learning curve at the beginning, but once you learn these conventions, you can quickly build applications and deliver a lot in less time. In this lecture, you're going to learn how to build an API or an application programming interface for our VIDLY application. With this API, other websites or mobile apps can work with our data. In practical terms, that means we're going to expose new endpoints that start with API. For example, API slash movies. So other websites or mobile apps can send an HTTP request to this end point and get the list of our movies in JSON format. That is pure data. There is no HTML markup. So they can get the list of our movies and do whatever they want with it. Pretty much most of the popular websites that you're familiar with like Facebook, Twitter, YouTube, Yelp and so on, all these websites have APIs. So you can work with their data in your apps. This is the benefit of publishing APIs. Now in this lecture, we're not going to look at consuming APIs. That's a different topic, but you're going to learn how to publish APIs so others can consume your APIs. Now, when it comes to building APIs in Django applications, there are basically two popular frameworks. One of them is Django Taste to Pie, which is currently at version 0.14. And surprisingly, it's beta, but it's been actively used in production on several websites. In fact, it's been around for a long time since 2010. I have personally worked, but it hasn't been really happy. It has a very nice design and that's the framework that I'm going to show you in this lecture. There is another framework that is called Django Rest Framework or DRF. This framework is a little bit more feature rich and you may want to use it in a large enterprise application, but compared to Taste to Pie, it's a little bit more complex to use. That's why in this lecture, I'm going to use Taste to Pie. So back in VS Code, on the terminal, let's install Django Dash Taste to Pie. All right. Now we need to create a new app in this project. So Python, manage.py, start app, and we're going to call that app API. So this app is purely responsible for exposing API endpoints. Let's go ahead. Done. Now we need to register this in the list of install apps. So let's go to settings.py. Here somewhere we should have the install apps. There you go. So we need to reference the config class in this app. That is API.apps.api config. Let's just quickly double check to make sure we got it right. So in the list of files, here's our API app. In this app, we have this apps module and here's the name of the class that we need to reference API config. Okay. So save the changes. Now in this app, we're going to add a new model. So let's open up the models module. In the world of APIs, we refer to our models as resources. You might have heard the term restful API. Rest stands for representational state transfer. It's a technical jargon for a bunch of conventions that define how applications should talk to each other over HTTP protocol. Now in the rest world, we have these URLs. URL stands for uniform resource locator. So with this URL, we can locate the movies. Movie here is a resource. So essentially in the rest world, we're exposing some of our resources using URLs or uniform resource locators. So back to the models module, we need to create a movie resource. So class, movie, resource. We could also call it movie, but it's better to add resource here to differentiate this from the movie model we have in the movies app. Because that movie class is part of our data model, we use that to get data from our database. But this is a movie resource, which is different from that. We use this to represent the concept of a movie in a restful API. You're going to see that shortly. So we should derive this class from the model resource class in Django TastyPie. So on the top, from tastypie.resources, we need to import the model resource class. And then at that here, model resource. Now, tastypie looks for an inner class in this class called meta. So here we add another class meta. This class defines some metadata about our movie resources. So there are a couple of attributes that we need to set here that tastypie looks for. And by the way, you don't have to memorize any of these. You can always come back to tastypie documentation. So the first attribute is query set. And we need to set this to the query for getting the list of all movies. So on the top, from our movies app dot models module, we need to import the movie class. And here we're going to say movie that objects that all now this all method simply returns a query. It's not going to go in a database and get the list of all movies. It simply returns a query. This query will be executed at some point in the future. This is what we call lazy loading. So this query object is a lazy object. Now, the second attribute that we need to set is resource on the line name. And we said this to movies. And this determines what our endpoint will look like. So we use movies here. And that means later, we'll have an API available at API slash movies. Okay. So we're done with our models. The next step is to generate our URL endpoints. So let's go to our main vitally app here and open up the URLs module. Currently, we have two URL patterns. Earlier, we told Django that any URLs that start with movies should be delegated to this module. We're going to take the same approach. So let's create another pass. Until Django that any URLs that start with API slash, we want to hand it off to a different module. What is that module? Well, here we need to import our movie resource model. So from API that models, let's import the movie resource model. Next, we need to create an instance of this class. So let's call it movie underlying resource. Now this object has a property called URLs. We don't see that here in IntelliSense, but this attribute returns the URLs for this movie resource based on the resource name that we said here. Okay. So let's delete line 21. Back to our include function. Here we pass movie resource dot URLs. Save the changes. That's all we had to do to create an API to expose our movie objects or more accurately movie resources. So to recap, we installed tasty pie. We created a new app called API in that app. We added a new model that represents our movie resources. And finally, we registered a new URL pattern in URLs.py. Now let's test our API. So back here, let's head over to API slash movies. There you go. So all our movie objects are serialized as JSON. Here in this JSON object, we have this property meta. This object has a few properties that is used for pagination. We can see currently we have a total of two movie objects in our database below that we have this object's property, which is set to an array of movie objects. And here are our movie objects that we retrieved from the database. So more accurately, refer to each of these objects as a movie resource. This is the public representation of a movie in our application. Now currently, this public representation looks exactly like our movie model in the movies app. So all the properties we had there also exist here. But this may not always be the case in real world application. For example, let's say in our API, we don't want to expose this property date created. Let's say this is purely used internally for our application. So back to our API app here in the meta class, we can set this attribute exclude. We set it to a list and in this list, we specify the properties or the fields that we want to exclude. In this case, date, underlying, created save the changes back here. Let's refresh now that property is gone. Beautiful. We also have this property resource URI that only exists in our movie resource objects. And this returns a URL that we can access to get more details about this movie. So that is set to slash API slash movies slash one where one is the idea of this movie. So if we head over to this address, we can see the properties of this movie object only. So in this lecture, we built a fully function API with only a few lines of code. All right, so we have done so much in this half. We have created our movies page. We added navigation. Here we can see the details about the movie. We also published an API. However, our home page is broken. So if we head over here, we get a page not found. So at the beginning of this section, just after we created our Django project, we had a beautiful homepage here. What happened to that? Well, Django displays that automatically until we register a new URL pattern. So here in our main URLs module, initially we only had this admin URL pattern. The moment we register a new URL pattern, Django stops displaying that default homepage. And the HTML for that homepage is not stored anywhere in this project. So we need to manually create a new homepage. And that's pretty easy. Let me show you. So here in our Vidl folder, let's add a new file, views.py. In this module, we're going to define a view function called home that takes a request. And here we simply render a template and return it. So on the top first, from Django.shortcuts, we need to import the render function. And then here we return render as the first argument we pass a request. Then as a template, we pass home that HTML. And here we don't need to pass a context object because we're not going to display any data on our homepage. So delete. Now we need to map this view function to a URL endpoint. So back to our URLs module. First, we need to import our views module. So from the current folder, let's import views. Next, we add a new URL pattern. So pass, we pass an empty string to represent the homepage. We map this to views.home. Okay. Now finally, we need to create the template. Here we have two options. One option is to add the templates folder in this Vidl folder, just like how we added templates to our movies app. But if we do so, we should also register this folder as an app in settings of pi because by default, this is not registered as an app. It kind of looks like an app, but it's not an app. So if you look at settings that pi here in the list of install apps, we don't have an app that represents Vidl. So if you want to register this as an app, we need to add a configuration class just like the movies and API apps. So we need to add a file called apps.py. And in that file, we need to create a class called Vidl config. After we install the Vidl app, Django will be able to find the templates in this app. Okay. So this is one option. The other option is to put all these general templates like homepage, about page, contact page and similar pages inside the main templates folder in this project. The approach to choose is one of a personal preference. I personally have tried both and sometimes I go back and forth between these two approaches, but there's really no practical differences between these two approaches. Yes, we can sit down and argue for one hour about the differences between these approaches at a theoretical level, but in practice, these arguments are useless. So to keep things simple, I'm going to add our home template in the main templates folder. So new file, home.html. Now here, first we need to extend our base.html template. Then we need to define a block called content. And in this block, I simply want to add a link to our movies app. So let's add an anchor with href set to. And here we're going to use the URL template tag. So URL enter. What is the URL that we want to render? Well, that is movies, colon, index. So once again, we are referencing a URL by its name. Save the changes. And it's better to end this to make it cleaner. And one last thing before we test the result, let's add a label here, movies. Now save the changes back in the browser. So here's our new homepage. I know it doesn't look fascinating, but it gets the job done. So we can navigate to the movies page and see the list of movies. This Fidley application we have built is useless if it's going to sit on our machine. So we should upload or deploy this somewhere where other people can use. So in this lecture, I'm going to show you how to deploy this application to a very popular cloud platform called Heroku. Heroku is not the only platform for deploying Django applications. You can also use Google Cloud Platform, Amazon Web Services, or AWS, Microsoft Azure, and so on. There are steps that I'm going to show you to deploy this application. Some of them are specific to Heroku. So if you want to deploy this application to a different cloud platform, some of these steps are going to be different. So the first thing I want you to do is to open up your browser and head over to Heroku.com. Now go ahead and create a new account. It's going to take only a few seconds and you don't need to provide a credit card to sign up. So you can try it first and if you like it, you can upgrade to get additional capacity. The next thing I want you to do is to install Heroku CLI. So search for Heroku CLI. CLI stands for command line interface and it's basically a program that we run on the command line, on the terminal. And with this program, we're going to perform some administrative tasks such as logging into our account, setting some configuration, looking at the logs and so on. On this page, you should be able to find Heroku CLI for your operating system. So you can see we have various implementations for Mac, Windows, Linux and so on. And the third thing I want you to install is Git, which is the most popular version control system. So with that, we can version our code. So we're going to check our code into a repository and every time we make changes to our code, we're going to commit that code to our repository. And with this, we can look at the history of changes to our code. We can see who has made what changes when it's really, really powerful. Now the explanation of Git is beyond the scope of this tutorial that really requires its own tutorial or course, but in this tutorial, we're going to learn the basics. So to download Git, head over to git-sm.com. Here, go to downloads and download Git installer for your operating system. So pause the video now. Do these three steps when you're done. Come back onto new watching. All right, first, let's make sure that you have installed all the prerequisite properly. So here on the terminal, let's run git-dashversion. So I have installed git version 2.19. And also Heroku-dashversion. Currently, I have Heroku version 6.13, but there is an update available. I'm not going to worry about that in this tutorial. So let's go ahead and prepare this application for deployment. Now, first, we need to install a package called Gunicorn, which is a popular web server for Python applications, because the web server that we have used so far is purely a simple, lightweight development server. We're not going to use that in a production environment. In case you're not familiar with the term production environment, that is basically the environment where our customers access our application. In this case, it's going to be our application in Heroku. We can also have a testing environment where we give our application to a limited number of users for testing. So back to the business. Let's install Gunicorn. So pip-nv install Gunicorn. Make sure to spell it properly. All right, next. In the root of our project, we need to add a new file. So here in the root, let's add a new file, proc file. Make sure to spell this properly. So P is capital, and this is really important. So proc, which is short for process file. This is a special file that Heroku looks at to start our application. In this file, we should write web, colon, Gunicorn, vitley.wsgi. What is going on here? Well, with this we're telling Heroku that we need a web process that is a kind of process used for web applications. And to start that process, we need to load Gunicorn. That is our web server. And here's the name of the module that Gunicorn should use to start our application. In this case, that is vitley.wsgi. So here's our vitley folder. That is our vitley package. In this package, we have this module. Wsgi, which is short for web server gateway interface. So save the changes. Now the next step is to prepare the static files for deployment. Static files are like CSS files, images, JavaScript files, and so on. Now in this application, we don't currently have any static files. But this admin interface that we have used so far has a number of static files that give this application this look and feel. So we need to bring those static files into our current project and deploy them to Heroku. So back in VS Code, first we need to go to vitley and open up the settings module. Now let's scroll to the bottom. Here we have a variable static URL. Next to that, I'm going to define another variable static underlying root. Now we could put this variable anywhere in this module. It doesn't have to be right after static URL. But to keep our code clean and will organize, I decided to put that here. Now we should set this variable to the past to the folder that contains our static files. Like currently, we don't have that folder here. So let's add that to the root of our project. So here a new folder static. Now we want to get the complete past to this folder and put it here. We don't want a hard code that like cDrive, backslash, whatever, because this can change on different machines where we deploy our application. So earlier we set the past to the templates folder. Let's scroll up. So here it is. Look at this template variable. Here we set the past to the templates folder using this expression. So using the join method of the past class in OS module, we're joining the base directory, which is the past to this project with the templates folder. So I want to copy this and then back here, paste it here and then change templates to static. All right. Now let's save the changes. Open up the terminal window. Run Python, manage.py, collect static. This command will look at all the installed apps. It will get all their static files and copy them into our static folder. Let me show you. So let's go ahead. As you can see, 119 static files were copied to our static folder. Let's have a quick look here. So here is our static folder. Let me close that and zoom in. So here we have this admin folder and inside this folder, we have all the static files for the admin app. So as you can see, we have quite a few number of CSS files, as well as fonts, images and JavaScript files. Now in our movies app, we could also have a bunch of CSS files, images, JavaScript files. And then when we run collect static, they will all end up inside the static folder. Okay. Now to serve these static files in Haruku, we should also install a package called white noise. This step is specific to Haruku. So if you want to use a different cloud platform, you may not necessarily have to do this. So one more time, open up the terminal and run pipn install white noise. Now here on pipi.org, let's search for white noise. Here's the package. So this package is used for serving static files. Let's go here and find their documentation. Now let's go to using white noise with Django. On this page, you can see the steps that you need to follow to use this package. So first is telling us to set the static root variable, which we already did. Now this documentation is suggesting to use the folder static files. We call it static. It doesn't really matter. Now the second step is to enable white noise by adding it in the list of middleware. So in our settings file, we have this variable middleware, which is set to a list of middleware objects. These middleware objects are used as part of processing the HTTP requests that we receive in our web server. So here we need to install this middleware white noise that middleware, that white noise middleware. With this middleware, we'll be able to serve static files. So when there is a request for a static file like a CSS file or an image, this middleware will kick in and do all the hard work. So basically, we need to copy this line and put it right below security middleware. So back to the settings module. Here's our middleware variable. The first middleware is for security. Right after that, we need to add the white noise middleware. So copy, also add a comma at the end, save the changes done. So with these changes, we have prepared our application for deployment. In the next lecture, I will show you how to deploy this application to Heroku. So to deploy our application to Heroku, we need to add it to a git repository. A git repository is basically a database that contains our source code and all its versions. So every time we change our code, we commit it to this repository. Now this repository is local on our machine. So as part of the deployment process, we need to set up another git repository in Heroku that mirrors our local repository. When we are ready to deploy, we push the changes from our local repository to the repository in Heroku. Now Heroku has a process that sits in the background. It's constantly watching this git repository. Whenever it detects changes in this repository, it will check out the latest source code from this repository and copy it to the right folders. That is a big picture. Now let's see this processing action. So the first step is to add our code to a git repository. So here on the terminal, run git in it. With this, we're initializing a git repository in the current folder. Now here you see this message, re-initialized existing git repository because I already created a git repository early on when I created this project. So this is a command that you run only once the very first time you want to initialize a git repository. Now every time you make changes to your code, you run git at period. This adds all the modified and new files in the current directory and all its sub-directories to the staging area and prepares them to be included in the next commit. So let's go ahead. Now all these files are in the staging area and they will be included in the next commit. So now to commit, we run git commit dash m for adding a message to this commit. We're going to say initial commit. Now next time we change our code, we make small changes and do it commit to git. In that commit, we should give a proper label to that commit so we know what changes we make. Did we fix a bug, did we add a new feature, what did we do? With this, we can build a history of changes to our code which is very valuable. So now we committed all these files and git. So our local git repository is now updated. Beautiful. Now we are done with all the git work. Next we need to create a Heroku app using Heroku CLI. So first we need to log in, so run Heroku login. Type your email, program with mosh at gmail.com. Obviously you're going to use your own not mine. Then enter your password. Okay, you can see I'm logged in as program with mosh at gmail.com. So next, we run Heroku create to create a new Heroku app. So Heroku created an app and it give it a random unique name. In this case, my app is limitless dash crag dash 337 whatever. On your mission, this is going to be different. We can also give a name while creating Heroku app. For example, Heroku create Vidly, but that name has to be unique. And here you can see the address of your app and the cloud. So currently if we head over to this address, we see this default page because we haven't deployed our application yet. Now when we run Heroku create three things happen. First, Heroku creates this app and this address. Second, it creates a git repository at this address. So it's git.heroku.com slash the name of our application dot git. And third, it tells our current local git repository in this folder about this new remote git repository. So now to deploy our application, all we have to do is to run git push Heroku master. This will push the changes in our local repository and the master branch to the Heroku repository. Now let's see what happens. So all our code is now pushed into Heroku. Heroku detects it a Python app. It's installing Python version 3.7.1. Then it detected the dependencies of our application from our pip file. In this case, we have a dependency to Django, white noise and a bunch of other packages. So Heroku is automatically downloading and installing them from PyPI. Next, it's installing our SQLite database. As I told you before, SQLite is a very simple and lightweight database. We shouldn't really use it in the cloud environment because it doesn't have security and it cannot serve multiple users. But for the purpose of this tutorial, it gets the job done. In a real application, you should use an enterprise database engine like mySQL, Postgres, Microsoft SQL Server and so on. But that's a topic for a different video. So now you can see our application is deployed to Heroku and here is the address of our application. Now for some reason that I don't know this address magically changed while recording this video. Let's not worry about that and go ahead. Next, we need to tell Heroku to allocate one web server to this application. So we run Heroku, PS, colon, scale, space, web equals one. So we're allocating one web server to this application. In the future, if you have a popular application with thousands or hundreds of thousands of users, you can simply come back and allocate more web servers by increasing this number. Okay, we are done. Now finally, we can open our application by running Heroku Open. This simply opens a web browser pointing to your application. Now, by default, you're going to get this error. This allowed host. This is to prevent a common security attack called HTTP host header attacks. The explanation of that goes beyond the scope of this tutorial. You can read about it on your own, but to fix this problem, we need to come back here, open up our settings file, and search for allowed hosts. Here in this list, we need to add the address of our website. That is this address here. So this web page is telling us you may need to add mighty voices, whatever that is on your machine. It's going to be different. So let's copy this string and add it here. So note that this is a string. Okay, save the changes. Now, as I told you before, every time you change your code, you need to commit your code to your local repository. And when you're ready to deploy, you need to push it to Heroku. So back in the terminal, to commit our code to our local repository, we type git, add, period, git, commit, give it a proper descriptive label, like add Heroku app to allow hosts. Now our local repository is updated. Before we get ready to deploy, you might have to make several changes. Different developers in our team might make tens or hundreds of commits. Now, when we're ready to commit, we simply run git push Heroku master. All right, Heroku went through all these steps one more time. Now, let's get back here and refresh this page. There you go. This is a riddle application in Heroku. Let's go to the list of movies. So our SQL Light Databases also deployed in my local database. I had two movies. That's why they also exist in the production environment. But these two databases are different. So here in our production environment, we can head over to admin and login with the same credentials. And then go to the list of movies and add a new movie here. We also have a fully working restful API that we can access at slash API slash movies. So here are the movies in our database represented as JSON. And that concludes our Django tutorial. I hope you learned a lot and thank you for watching. In this section, you're going to learn about machine learning, which is a subset of AI or artificial intelligence. It's one of the trending topics in the world these days and it's going to have a lot of applications in the future. Here's an example. Imagine I asked you to write a program to a scan an image until if it's a cat or a dog. If you want to build this program using traditional programming your program is going to get overly complex. You will have to come up with lots of rules to look for specific curves, edges and colors and an image to tell if it's a cat or a dog. But if I give you a black and white photo, your rules may not work. They may break. Then you'll have to rewrite them. Or I may give you a picture of a cat or a dog from a different angle that you did not predict before. So solving this problem using traditional programming techniques is going to get overly complex or sometimes impossible. Now to make them matter worse, what if in the future I ask you to extend this program such that it supports three kinds of animals, cats, dogs and horses. Once again, you'll have to rewrite all those rules. That's not going to work. So machine learning is a technique to solve these kind of problems and this is how it works. We build a model or an engine and give it lots and lots of data. For example, we give it thousands or tens of thousands of pictures of cats and dogs. Our model will then find and learn patterns in the input data. So we can give it a new picture of a cat that it hasn't seen before and ask it, is it a cat or a dog or a horse? And it will tell us with a certain level of accuracy. The more input data we give it, the more accurate our model is going to be. So that was a very basic example. But machine learning has other applications in self-driving cars, robotics, language processing, vision processing, forecasting things like stock market trends and the weather, games and so on. So that's a basic idea about machine learning. Next we'll look at machine learning in action. A machine learning project involves a number of steps. The first step is to import our data, which often comes in the form of a CSV file. It might have a database with lots of data, we can simply export that data and store it in a CSV file for the purpose of our machine learning project. So we import our data next, we need to clean it and this involves tasks such as removing duplicated data. If you have duplicates in the data, we don't want to feed this to our model, because otherwise our model will learn bad patterns in the data and it will produce the wrong result. So we should make sure that our input data is in a good and clean shape. If there are data that is irrelevant, we should remove them. If they're duplicated or incomplete, we can remove or modify them. If our data is text-based, like the name of countries or genres of music or cats and dogs, we need to convert them to numerical values. So this step really depends on the kind of data we're working with. Every project is different. Now that we have a clean data set, we need to split it into two segments. One for training our model and the other for testing it to make sure that our model produces the right result. For example, if you have a thousand pictures of cats and dogs, we can reserve 80% for training and the other 20% for testing. The next step is to create a model and this involves selecting an algorithm to analyze the data. There's so many different machine learning algorithms out there such as decision trees, neural networks and so on. Each algorithm has pros and cons in terms of accuracy and performance. So the algorithm you choose depends on the kind of problem you're trying to solve and your input data. Now the good news is that we don't have to explicitly program an algorithm. There are libraries out there that provide these algorithms. One of the most popular ones which we're going to look at in this tutorial is Scikit Learn. So we build a model using an algorithm. Next, we need to train our model. So we feed our training data. Our model will then look for the patterns in the data. So next we can ask it to make predictions. Back to our example of cats and dogs, we can ask our model, is this a cat or a dog and our model will make a prediction. Now the prediction is not always accurate. In fact, when you start out, it's very likely that your predictions are inaccurate. So we need to evaluate the predictions and measure their accuracy. Then we need to get back to our model and either select a different algorithm that is going to produce a more accurate result for the kind of problem we're trying to solve or fine tune the parameters of our model. So each algorithm has parameters that we can modify to optimize the accuracy. So these are the high level steps that you follow in a machine learning project. Next, we'll look at the libraries and tools for machine learning. In this lecture, we're going to look at the popular Python libraries that we use in machine learning projects. The first one is NumPy which provides a multi-dimensional array, very, very popular library. The second one is Pandas which is a data analysis library that provides a concept called data frame. A data frame is a two-dimensional data structure similar to an Excel spreadsheet. So we have rows and columns, we can select data in a row or a column or a range of rows and columns. Again, very, very popular in machine learning and data science projects. The third library is Matplotlib which is a two-dimensional plotting library for creating graphs and plots. The next library is PsychitLearn which is one of the most popular machine learning libraries that provides all these common algorithms like decision trees, neural networks and so on. Now, when working with machine learning projects, we use an environment called Jupiter for writing our code. Technically, we can still use VS code or any other code editors, but these editors are not ideal for machine learning projects because we frequently need to inspect the data and that is really hard in environments like VS code and terminal. If you're working with a table of 10 or 20 columns, visualizing this data in a terminal window is really, really difficult and messy. So that's why we use Jupiter. It makes it really easy to inspect our data. Now, to install Jupiter, we are going to use a platform called Anaconda. So head over to anaconda.com, slash download. On this page, we can download Anaconda distribution for your operating system. So we have distributions for Windows, Mac and Linux. So let's go ahead and install Anaconda for Python 3.7. Download. All right, so here's Anaconda downloaded on my machine. Let's double-click this. All right, first, it's going to run a program to determine if the software can be installed. So let's continue. And once again, continue, continue. Pretty easy. Continue one more time. I agree with the license agreement. Okay. We can use the default installation location. So don't worry about that. Just click install. Give it a few seconds. Now, the beautiful thing about Anaconda is that it will install Jupiter as well as all those popular data science libraries like Nampi, Pandas and so on. So we don't have to manually install this using PIP. All right, now as part of the next step Anaconda is suggesting to install Microsoft VS Code, we already have this on our machine. So we don't have to install it. We can go with continue and close the installation. Now, finally, we can move this to trash because we don't need this installer in the future. All right, now open up a terminal window and type Jupiter with a Y space notebook. This will start the notebook server on your machine. So enter there you go. This will start the notebook server on your machine. You can see these default messages here. Don't worry about them. Now it automatically opens a browser window pointing to local host port 8888. This is what we call Jupiter dashboard. On this dashboard, we have a few tabs. The first tab is the files tab and by default, this points to your home directory. So every user on your machine has a home directory. This is my home directory on Mac. You can see here we have a desktop folder as well as documents, downloads and so on. On your machine, you're going to see different folders. So someone on your machine, you need to create a Jupiter notebook. I'm going to go to desktop. Here's my desktop. I don't have anything here. And then click new. I want to create a notebook for Python 3. In this notebook, we can write Python code and execute it line by line. We can easily visualize our data as you will see over the next few videos. So let's go ahead with this. All right, here's our first notebook. You can see by default, it's called untitled. Let's change that to hello world. So this is going to be the hello world of our machine learning project. Let's rename this. Now, if you look at your desktop, you can see this file hello world that I pie NB. This is a Jupiter notebook. It's kind of similar to our py files where we write our Python code, but it includes additional data that Jupiter uses to execute our code. So back to our notebook, let's do a print hello world. And then click this run button here. And here's the result printed in Jupiter. So we don't have to navigate back and forth between the terminal window. We can see all the result right here. Next, I'm going to show you how to load a dataset from a CSV file in Jupiter. All right, in this lecture, we're going to download a dataset from a very popular website called Kaggle.com. Kaggle is basically a place to do data science projects. So the first thing you need to do is to create an account. You can sign up with Facebook, Google, or using a custom email and password. Once you sign up, then come back here on Kaggle.com here in the search bar, search for video game sales. This is the name of a very popular dataset that we're going to use in this lecture. So here in this list, you can see the first item with this kind of reddish icon. So let's go with that. As you can see, this data set includes the sales data for more than 16,000 video games. On this page, you can see the description of various columns in this dataset. We have rank, name, platform, year, and so on. So here's our data source. It's a CSV file called vg sales.csv. As you can see, there are over 16,000 rows and 11 columns in this dataset. Right below that, you can see the first few records of this dataset. So here's our first record. The ranking for this game is one. It's the Wii Sports game for Wii as the platform and it was released in year 2006. Now, what I want you to do is to go ahead and download this dataset. And as I told you before, you need to sign in before you can download this. So this will give you a zip file. As you can see here, here's our CSV file. Now, I want you to put this right next to your Jupyter notebook on my machine. That is on my desktop. So I want to drag and drop this onto the desktop folder. Now, if you look at the desktop, you can see here's my Jupyter Helloward notebook. And right next to that, we have vg sales.csv. With that, we go back to our Jupyter notebook. Let's remove the first line and instead, import pandas as pd. With this, we're importing pandas module and renaming it to pd. So we don't have to type pandas.seral times in this code. Now let's type pd.readOnline.csv and pass the name or CSV file. That is vg sales.csv. Now, because this CSV file is in the current folder, right next to our Jupyter notebook, we can easily load it. Otherwise, we'll have to supply the full path to this file. So this returns a data frame object, which is like an Excel spreadsheet. Let me show you. So we store it here. And then we can simply type df to inspect it. So one more time, let's run this program. Here's our data frame with these rows and columns. So we have frank, name, platform, and so on. Now, this data frame object has lots of attributes and methods that we're not going to cover in this tutorial. Let's read it beyond the scope of what we're going to do. So I leave it up to you to read pandas documentation or follow other tutorials to learn about pandas data frames. But in this lecture, I'm going to show you some of the most useful methods and attributes. The first one is shape. So shape, let's run this one more time. So here's the shape of this data set. We have over 16,000 records and 11 columns. Technically, this is a two-dimensional array of 16,000 and 11. Okay. Now, you can see here we have another segment for writing code. So we don't have to write all the code in the first segment. So here in the second segment, we can call one of the methods of the data frame that is df dot describe. Now, when we run this program, we can see the output for each segment right next to it. So here's our first segment. Here we have these three lines. And this is the output of the last line below that we have our second segment. Here we're calling the describe method. And right below that, we have the output of this segment. So this is the beauty of Jupiter. We can easily visualize our data. Doing this with VS code and terminal windows is really tedious and clunky. So what is this describe method returning? Basically, it's returning some basic information about each column in this data set. So as you saw earlier, we have columns like rank, year, and so on. These are the columns with numerical values. Now, for each column, we have the count, which is the number of records in that column. You can see our rank column has 16,598 records, whereas the year column has 16,327 records. So this shows that some of our records don't have the value for the year column. We have null values. So in a real data science or machine learning project, we'll have to use some techniques to clean up our data set. One option is to remove the records that don't have a value for the year column, or we can assign them at the default value. That really depends on the project. Another attribute for each column is mean. So this is the average of all the values. Now in the case of the rank column, this value doesn't really matter, but look at the year. So the average year, for all these video games in our data set is 2006. And this might be important in the problem we're trying to solve. We also have standard deviation, which is a measure to quantify the amount of variation in our set of values below that we have. Men as an example, the minimum value for the year column is 1980. So quite often when we work with a new data set, we call the describe method to get some basic statistics about our data. Let me show you another useful attribute. So in the next segment, let's type DF that values. Let's run this. As you can see, this returns a two-dimensional array. This square bracket indicates the outer array. And the second one represents the inner array. So the first element in our outer array is an array itself. These are the values in this array, which basically represent the first row in our data set. So the video game with ranking one, which is called Wii Sports. So this was a basic overview of Pandas data frames. In the next section, I'm going to show you some of the useful shortcuts of Jupyter. In this lecture, I'm going to show you some of the most useful shortcuts in Jupyter. Now, the first thing I want you to pay attention to is this green bar on the left. This indicates that this cell is currently in the edit mode. So we can write code here. Now, if we press the escape key, green turns to blue, and that means this cell is currently in the command mode. So basically, the activated cell can be either in the edit mode or the command mode. Depending on the mode, we have different shortcuts. So here, we're currently in the command mode. If we press H, we can see the list of all the keyboard shortcuts. Right above this list, we can see macOS modifier keys. These are the extra keys that we have on a mac keyboard. If you're a Windows user, you're not going to see this. So as an example, here is the shape of the command key. This is control. This is option and so on. With this guideline, you can easily understand the shortcut associated with each command. Let me show you. So here, we have all the commands when a cell is in the command mode. For example, we have this command open the command palette. This is exactly like the command palette that we have in VS Code. Here's a shortcut to execute this command. That is command shift and F. Okay. So here, we have lots of shortcuts. Of course, you're not going to use all of them all the time, but it's good to have a quick look here to see what is available for you. With this shortcut, you can write code much faster. So let me show you some of the most useful ones. I'm going to close this. Now, with our first cell in the command mode, I'm going to press B and this insert a new cell below this cell. We can also go back to our first cell, press escape. Now the cell is in the command mode. We can insert an empty cell above this cell by pressing A. So either A or B, A for above and B for below. Okay. Now, if you don't want this cell, you can press D twice to delete it like this. Now, in the cell, I'm going to print a hello word message. So print hello world. Now, to run the code in this cell, we can click on the run button here. So here's our print function and right below that, you can see the output of this function. But note that when you run a cell, this will only execute the code in that cell. In other words, the code in other cells will not be executed. Let me show you what I mean. So in the cell below this cell, I'm going to delete the call to the describe method. Instead, I'm going to print ocean. Now, I'm going to put the cursor back in this cell where we print the hello word message and run this cell. So you can see, hello world is displayed here. But the cell below is still displaying the describe table. So we don't see the changes here. Now, to solve this problem, we can go to the cell menu on the top and run all cells together. This can work for a small project, but sometimes you're working with a large data set. So if you want to run all these cells together, it's going to take a lot of time. That is the reason Jupiter saves the output of each cell. So we don't have to rerun that code if it hasn't changed. So this notebook file that we have here includes our source code organized in cells, as well as the output for each cell. That is why it's different from a regular pie file where we only have the source code. Here we also have auto completion and intelligence. So in the cell, let's call dfdatafram. Now, if you press tab, you can see all the attributes and methods in this object. So let's call describe. Now with the cursor on the name of the method, we can press shift and tap to see this tooltip that describes what this method does and what parameter it takes. So here in front of signature, you can see the describe method. These are the parameters and their default value. And right below that, you can see the description of what this method does. In this case, it generates descriptive statistics that summaries the central tendency and so on. Similar to VS Code, we can also convert a line to comment by pressing command and slash on Mac or controlled slash on Windows. Like this. Now this line is a comment. We can press the same shortcut one more time to remove the comment. So this is where some of the most useful shortcuts in Jupyter. Now over the next few lectures, we're going to work on a real machine learning project. But before we get there, let's delete all the cells here. So we start with only a single empty cell. So here in this cell, first I'm going to press the escape button. Now the cell is blue. So we are in the command mode and we can delete the cell by pressing D twice. There you go. Now the next cell is activated and it's in the command mode. So let's delete this as well. We have two more cells to delete. There you go. And the last one like this. So now we have an empty notebook with a single cell. Now over the next few lectures, we're going to work on a real machine learning project. Imagine we have an online music store. When our users sign up, we ask their age and gender and based on their profile, we recommend various music albums they are likely to buy. So in this project, we want to use machine learning to increase cells. So we want to build a model. We feed this model with some sample data based on the existing users. Our model will learn the patterns in our data so we can ask it to make predictions. When a new user signs up, we tell our model, hey, we have a new user with this profile. What is the kind of music that this user is interested in? Our model will say jazz or hip hop or whatever. And based on that, we can make suggestions to the user. So this is the problem we're going to solve. Now back to the list of steps and a machine learning project. First we need to import our data. Then we should prepare or clean it. Next, we select a machine learning algorithm to build a model. We train our model and ask it to make predictions. And finally, we evaluate our algorithm to see its accuracy. If it's not accurate, we either fine tune our model or select a different algorithm. So let's focus on the first step. Head over to bit.ly slash music.csv. This is a very basic csv that I've created for this project. It's just some random made-up data. It's not real. So we have a table with three columns. Age, gender, and genre. Gender can either be one which represents a male or zero which represents a female. Here I'll make in a few assumptions. I'm assuming that men between 20 and 25 like hip hop, men between 26 and 30 like jazz. And after the age of 30, they like classical music. For women, I'm assuming that if they're between 20 and 25, they like dance music. If they're between 26 and 30, they like acoustic music. And just like men after the age of 30, they like classical music. Once again, this is a made-up pattern. It's not the representation of the reality. So let's go ahead and download the csv. Click on this dot dot dot icon here and download this file. In my downloads folder, here we have this music.csv. I'm going to drag and drop this onto desktop because that's where I've stored this Hello Word notebook. So I want you to put the csv file right next to your Jupyter notebook. Now back to our notebook, we need to read the csv file. So just like before, first we need to import the Pandas module. So import Pandas as PD. And then we'll call PD that read analyze csv. And the name of our file is music dot csv. As you saw earlier, this returns a data frame, which is a two-dimensional array similar to an Excel spreadsheet. So let's call that music on the line data. Now let's inspect this music on the line data to make sure we loaded everything properly. So run. So here's our data frame, beautiful. Next we need to prepare or clean the data. And that's the topic for the next lecture. The second step with a machine learning project is cleaning or pre-preparing the data. And that involves tasks such as removing duplicates, null values, and so on. Now in this particular dataset, we don't have to do any kind of cleaning because we don't have any duplicates. And as you can see, all rows have values for all columns. So we don't have null values, but there is one thing we need to do. We should split this dataset into two separate datasets. One with the first two columns, which we refer to as the input set and the other with the last column, which we refer to as the output set. So when we train a model, we give it two separate datasets, the input set and the output set. The output set, which is in this case, the genre column contains the predictions. So we're telling our model that if we have a user who is 20 years old and is a male, they like hip hop. Once we train our model, then we give it a new input set. For example, we say, hey, we have a new user who is 21 years old and is a male. What is the genre of the music that this user probably likes? As you can see, in our input set, we don't have a sample for a 21 year old male. So we're going to ask our model to predict that. That is the reason we need to split this dataset into two separate sets, input and output. So back to our code, this data frame object has a method called drop. Now, if you put the cursor on the method name and press shift and tab, you can see this tool tape. So this is the signature of this drop method. These are the parameters that we can pass here. The parameter we're going to use in this lecture is columns, which is set to non-by default. With this parameter, we can specify the columns we want to drop. So, in this case, we set columns to n array with one string, genre. Now, this method doesn't actually modify the original dataset. In fact, it will create a new dataset, but without this column. So by convention, we use a capital to represent that dataset. So capital X equals this expression. Now, let's inspect X. So as you can see, our input set or X includes these two columns, age and gender. It doesn't have the output or predictions. Next we need to create our output set. So once again, we start with our data frame, music data. Using square brackets, we can get all the values in a given column. In this case, genre. Once again, this returns a new dataset. By convention, we use a lowercase Y to represent that. So that is our output dataset. Let's inspect that as well. So in this dataset, we only have the predictions or the answers. So we have prepared our data. Next, we need to create a model using an algorithm. The next step is to build a model using a machine learning algorithm. There's so many algorithms out there. Anish algorithm has its pros and cons in terms of the performance and accuracy. In this lecture, we're going to use a very simple algorithm called decision tree. Now, the good news is that we don't have to explicitly program these algorithms. They're already implemented for us in a library called scikit learn. So here on the top, from SK learn, the tree, let's import the decision tree classifier. So SK learn is the package that comes with scikit learn library. This is the most popular machine learning library in Python. In this package, we have a module called tree. And in this module, we have a class called decision tree classifier. This class implements the decision tree algorithm. Okay. So now we need to create a new instance of this class. So at the end, let's create an object called model and set it to a new instance of decision tree classifier like this. So now we have a model next, we need to train it so it learns patterns in the data. And that is pretty easy. We call model that fit. This method takes two datasets, the input set and the output set. So they are capital X and Y. Now finally, we need to ask our model to make a prediction. So we can ask it, what is the kind of music that a 21 year old male likes? Now, before we do that, let's temporarily inspect our initial data set. That is music data. So look what we got here. As I told you earlier, I've assumed that men between 20 and 25 like hip hop music. But here, we only have three samples for men aged 20, 23 and 25. We don't have a sample for a 21 year old male. So if you ask our model to predict the kind of music that a 21 year old male likes, we expect it to say hip hop. Similarly, I've assumed that women between 20 and 25 like dance music, but we don't have a sample for a 22 year old female. So once again, if you ask our model to predict the kind of music that a 22 year old woman likes, we expect it to say dance. So we did assumptions. Let's go ahead and ask our model to make predictions. So let's remove the last line. And instead, we're going to call model duck predict. This method takes a two dimensional array. So here's the outer array. In this array, each element is an array. So I'm going to pass another array here. And in this array, I'm going to pass a new input set at 21 year old male. So 21 comma one. That is like a new record in this table. Okay. So this is one input set. Let's pass another input set for a 22 year female. So here's another array. Here we add 22 comma zero. So we're asking our model to make two predictions at the same time. We get the result and store it in a variable called predictions. And finally, let's inspect that in our notebook. Run. Look what we got. Our model is saying that a 21 year old male likes hip hop and a 22 year old female likes dance music. So our model could successfully make predictions here. Beautiful. But wait a second, building a model that makes predictions accurate. It's not always that easy. As I told you earlier, after we build a model, we need to measure its accuracy. And if it's not accurate enough, we should either fine tune it or build a model using a different algorithm. So in the next lecture, I'm going to show you how to measure the accuracy of a model. In this lecture, I'm going to show you how to measure the accuracy of your models. Now, in order to do so, first, we need to split our data set into two sets, one for training and the other for testing. Because right now, we're passing the entire data set for training the model and we're using two samples for making predictions. That is not enough to calculate the accuracy of a model. A general rule of thumb is to allocate 70 to 80% of our data for training and the other 20 to 30% for testing. Then instead of passing only two samples for making predictions, we can pass the data set we have for testing, we'll get the predictions and then we can compare these predictions with the actual values in the test set. Based on that, we can calculate the accuracy. That's really easy. All we have to do is to import a couple of functions and call them in this code. Let me show you. So first on the top, from SK Learn. That model, underlying selection module, we import a function called train test split. With this function, we can easily split our data set into two sets for training and testing. Now, right here, after we define x and y sets, we call this function. So train test split. We give it three arguments x, y and a keyword argument that specifies the size of our test data set. So test on the line size, we set it to 0.2. So we are allocating 20% of our data for testing. Now, this function returns a topple. So we can unpack it into four variables right here. x, underlying train x, underlying test y, underlying train and y, underlying test. So the first two variables are the input sets for training and testing and the other are the output sets for training and testing. Now, when training our model, instead of passing the entire data set, we want to pass only the training data set. So x, underlying train and y, underlying train. Also, when making predictions, instead of passing these two samples, we pass x, underlying test. So that is the data set that contains input values for testing. Now we get the predictions to calculate the accuracy. We simply have to compare these predictions with the actual values we have in our output set for testing. That is very easy. First on the top, we need to import a function. So from sklearn.metrics, import, accuracy, underlying score. Now at the very end, we call this function, so accuracy score and give it two arguments. y, underlying test, which contains the expected values and predictions, which contains the actual values. Now this function returns an accuracy score between 0 to 1. So we can store it here and simply display it on the console. So let's go ahead and run this program. So the accuracy score is one or 100%. But if we run this one more time, we're going to see a different result because every time we split our data set into training and test sets, we'll have different data sets because this function randomly picks data for training and testing. Let me show you. So put the cursor in the cell. Now you can see this cell is activated. Note that if you click this button here, it will run this cell and also insert a new cell below this cell. Let me show you. So if I go to the second cell, press escape button. Now we are in the command mode. Press D twice. Okay. Now it's deleted. If we click the run button, you can see this code was executed and now we have a new cell. So if you want to run our first cell multiple times, every time we have to click this and then run it and then click again and run it. It's a little bit tedious. So I show you a shortcut. Activate the first cell and press control and enter. This runs the current cell without adding a new cell below it. So back here, let's try it multiple times. Okay. Now look, the accuracy dropped to 0.75. It's still good. So the accuracy score here is somewhere between 75% to 100%. But let me show you something. If I change the test size, from 0.2 to 0.8. So essentially, we're using only 20% of our data for training this model. And we're using the other 80% for testing. Now let's see what happens when we run this cell multiple times. So control and enter. Look, the accuracy immediately dropped to 0.4. One more time. Now 46%, 40%, 26%. It's really, really bad. The reason this is happening is because we are using very little data for training this model. This is one of the key concepts in machine learning. The more data we give to our model and the cleaner the data is, we get the better result. So if we have duplicates irrelevant data or incomplete values, our model will learn back patterns in our data. That is why it's really important to clean our data before training our model. Now let's change this back to 0.2. Run this one more time. Okay. Now the accuracy is one 75%. Now we drop to 50%. Again, the reason this is happening is because we don't have enough data. Some machine learning problems require thousands or even millions of samples to train a model. The more complex the problem is the more data we need. For example, here we're only dealing with a table of three columns. But if you want to build a model to tell if a picture is a cat or a dog or a horse or a lion will need millions of pictures. The more animals we want to support, the more pictures we need. In the next lecture, we're going to talk about model persistence. So this is a very basic implementation of building and training a model to make predictions. Now to simplify things, I have removed all the code that we wrote in the last lecture for calculating the accuracy because in this lecture, we're going to focus on a different topic. So basically, we import our dataset, create a model, train it, and then ask it to make predictions. Now this piece of code that you see here is not what we want to run every time we have a new user or every time we want to make recommendations to an existing user because training a model can sometimes be really time consuming. In this example, we're dealing with a very small data set that has only 20 records. But in real applications, we might have a dataset with thousands or millions of samples. Training a model for that might take seconds, minutes, or even hours. So that is why model persistence is important. Once in a while, we build and train our model and then we'll save it to a file. Now next time we want to make predictions, we simply load the model from the file and ask it to make predictions. That model is already trained. We don't need to retrain it. It's like an intelligent person. So let me show you how to do this. It's very, very easy. On the top, from SKLearn.external module, we import joblib. This joblib object has methods for saving and loading models. So after we train our model, we simply call joblib.dump and give it to our arguments. Our model and the name of the file in which we want to store this model. Let's call that music-recommender.joblib. That's all we have to do. Now temporarily, I'm going to comment out this line. We don't want to make any predictions. We just want to store our trained model in a file. So let's run this cell with control and slash. Okay, look in the output, we have an array that contains the name of our model file. So this is the return value of the dump method. Now back to our desktop. Right next to my notebook, you can see our joblib file. This is where our model is stored. It's simply a binary file. Now back to our Jupyter notebook. As I told you before, in a real application, we don't want to train a model every time. So let's comment out this few lines. So I've selected this few lines on Mac. We can press command and slash on Windows, Control slash. Okay, these lines are commented out. Now this time, instead of dumping our model, we're going to load it. So we call the load method. We don't have the model. We simply pass the name of our model file. This returns our trained model. Now with these two lines, we can simply make predictions. So earlier, we assume that men between 20 and 25 like hip-hop music. Let's print predictions and see if our model is behaving correctly or not. So control and enter. There you go. So this is how we persist and load models. Earlier in this section, I told you that decision trees are the easiest to understand. And that's why we started machine learning with decision trees. In this section, we're going to export our model in a visual format. So you will see how this model makes predictions. That is really, really cool. Let me show you. So once again, I've simplified this code. So we simply import our data set, create input and output sets, create a model and train it. That's all we are doing. Now I want you to follow along with me, type everything exactly as I show you in this lecture. Don't worry about what everything means. We're going to come back to it shortly. So on the top, from SKLearn, import tree. This object has a method for exporting our decision tree in a graphical format. So after we train our model, let's call tree that export on the line graph viz. Now here are a few arguments we need to pass. The first argument is our model. The second is the name of the output file. So here we're going to use keyword arguments because this method takes so many parameters. And we want to selectively pass keyword arguments without worrying about their order. So the parameter we're going to set is out on the line file. Let's set this to music dash recommender dot d o t. This is the dot format, which is a graph description language. You'll see that shortly. The other parameter we want to set is feature on the line names. We set this to an array of two strings, age and gender. These are the features or the columns of our data set. So they are the properties or features of our data. Okay. The other parameter is class names. So class on the line names. We should set this to the list of classes or labels we have in our output data set like hip hop, jazz, classical, and so on. So this Y data set includes all the genres or all the classes of our data, but they're repeated a few times in this data set. So here we call Y dot unique. This returns the unique list of classes. Now we should sort this alphabetically. So we call the sorted function and pass the result of Y dot unique. The next parameter is label. We set this to a string all. Once again, don't worry about the details of these parameters. We're going to come back to this shortly. So set label to all, then round it to true and finally filled to true. So this is the end result. Now let's run this cell using control and enter. Okay. Here we have a new file, music, recommender dot dot that's a little bit funny. So we want to open this file with VS code. So drag and drop this into VS code window. Okay. Here's a dot format. It's a textual language for describing graphs. Now to visualize this graph, we need to install an extension in VS code. So on the left side, click the extensions panel and search for dot d o t. Look at this second extension here. Graph is or dot language by a Stefan VS. Go ahead and install this extension and then reload VS code. Once you do that, you can visualize this dot file. So let me close this tab. All right. Look at this dot dot dot here on the right side. Click this. You should have a new menu. Open preview to the site. So click that. All right. Here's the visualization of our decision tree. Let's close the dot file. There you go. This is exactly how our model makes predictions. So we have this binary tree, which means every node can have a maximum of two children. On top of each node, we have a condition. If this condition is true, we go to the child node on the left side. Otherwise, we go to the child node on the right side. So let's see what's happening here. The first condition is age, less than or equal to 30.5. If this condition is false, that means that user is 30 years or older. So the genre of the music that they're interested in is classical. So here we're classifying people based on their profile. That is the reason we have the word class here. So a user who is 30 years or older belongs to the class of classical or people who like classical music. Now, what if this condition is true? That means that user is younger than 30. So now we check the gender. If it's less than 0.5, which basically means if it equals to 0, then we're dealing with a female. So we go to the child node here. Now, once again, we have another condition. So we're dealing with a female who's younger than 30. Once again, we need to check their age. So is the age less than 25.5? If that's the case, then that user likes dance music. Otherwise, they like acoustic music. So this is the decision tree that our model uses to make predictions. But if you're wondering why we have these floating point numbers, like 25.5, these are basically the rules that our model generates based on the patterns that it finds in our data set. As we give our model more data, these rules will change. So they're not always the same. Also, the more columns or more features we have, our decision tree is going to get more complex. Currently, we have only two features, age and gender. Now back to our code, let me quickly explain the meaning of all these parameters. We set fill to true. So each box or each node is filled with a color. We set rounded to true. So they have rounded corners. We set label to all. So every node has labels that we can read. We set class names to the unique list of genres. And that's for displaying the class for each node right here. And we set feature names to age and gender. So we can see the rules in our notes.