{"id":"system-lld","title":"ğŸ”§ Low-Level Design (LLD)","content":"# ğŸ—ï¸ Low-Level Design (LLD) Mastery - Senior Developer Edition\n\n**A comprehensive guide to Low-Level Design principles, patterns, and practices for technical interviews and career advancement.**\n\n## ğŸ¯ **What You'll Master**\n\n### **ğŸ”§ Core LLD Concepts:**\n- **SOLID Principles** - Foundation of good software design\n- **Design Patterns** - Gang of Four patterns with real implementations\n- **Object-Oriented Design** - Classes, inheritance, polymorphism\n- **System Architecture** - Clean architecture and dependency management\n- **Code Quality** - Maintainable, testable, and scalable code\n\n### **ğŸ’¼ Career Impact:**\n- âœ… **Senior Developer Positions** - Essential for L5+ roles\n- âœ… **Technical Lead Roles** - Code architecture and design leadership\n- âœ… **System Architect** - Foundation for high-level design\n- âœ… **FAANG Interviews** - Required for senior technical interviews\n- âœ… **Startup CTO** - Complete system design knowledge\n\n### **ğŸ›  Interview Preparation:**\n- **LLD Interview Questions** - Parking lot, elevator, chat system\n- **Design Pattern Recognition** - When and how to apply patterns\n- **Code Architecture** - Clean, maintainable, and extensible designs\n- **Trade-off Analysis** - Performance vs maintainability decisions\n- **Real-world Applications** - Production-ready design considerations\n\n---\n\n**ğŸ”¥ Pro Tip: LLD skills separate senior engineers from junior developers. Master these concepts to advance your career and lead technical teams!**\n\n## Chapter 1: SOLID Principles â­â­â­\n\n**âš¡ Interview Frequency: EXTREMELY HIGH** | **Career Impact: CRITICAL for Senior Roles**\n\n**The SOLID principles are the foundation of good software design. Master these to write maintainable, scalable, and testable code.**\n\n### **What is SOLID?**\n- **S** - Single Responsibility Principle\n- **O** - Open/Closed Principle  \n- **L** - Liskov Substitution Principle\n- **I** - Interface Segregation Principle\n- **D** - Dependency Inversion Principle\n\n**Why It Matters:** These principles guide you to write code that's easy to understand, modify, and extend - essential skills for senior developers!\n\n## ğŸ—ï¸ Object-Oriented Design - Complete Theory\n\n### **ğŸ“š SOLID Principles - Foundation of Good Design**\n\n---\n\n## 1ï¸âƒ£ **Single Responsibility Principle (SRP)**\n\n**Definition:** A class should have ONE and ONLY ONE reason to change.\n\n```\nâŒ BAD: God Class (Multiple Responsibilities)\n\nclass User:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n    \n    def save_to_database(self):\n        # Database logic - Responsibility 1\n        pass\n    \n    def send_email(self):\n        # Email logic - Responsibility 2\n        pass\n    \n    def generate_report(self):\n        # Report logic - Responsibility 3\n        pass\n\nProblems:\nâ€¢ Change DB? Modify User class\nâ€¢ Change email provider? Modify User class\nâ€¢ Change report format? Modify User class\nâ€¢ Hard to test (mock DB, email, report)\nâ€¢ Hard to reuse (tight coupling)\n\nâœ… GOOD: Single Responsibility per Class\n\nclass User:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\nclass UserRepository:\n    def save(self, user: User):\n        # Database logic only\n        pass\n\nclass EmailService:\n    def send_welcome_email(self, user: User):\n        # Email logic only\n        pass\n\nclass ReportGenerator:\n    def generate_user_report(self, user: User):\n        # Report logic only\n        pass\n\nBenefits:\nâœ… Change DB â†’ Modify only UserRepository\nâœ… Change email â†’ Modify only EmailService\nâœ… Easy to test (mock one service at a time)\nâœ… Reusable (EmailService for all emails)\n```\n\n**Interview Example:**\n\"Design a logger that writes to file and sends critical errors to monitoring service.\"\n\nâŒ Bad:\n```python\nclass Logger:\n    def log(self, message, level):\n        self.write_to_file(message)\n        if level == \"CRITICAL\":\n            self.send_to_monitoring(message)\n```\n\nâœ… Good:\n```python\nclass Logger:\n    def log(self, message, level):\n        pass\n\nclass FileLogger(Logger):\n    def log(self, message, level):\n        self.write_to_file(message)\n\nclass MonitoringLogger(Logger):\n    def log(self, message, level):\n        if level == \"CRITICAL\":\n            self.send_to_monitoring(message)\n\nclass CompositeLogger(Logger):\n    def __init__(self, loggers):\n        self.loggers = loggers\n    \n    def log(self, message, level):\n        for logger in self.loggers:\n            logger.log(message, level)\n```\n\n---\n\n## 2ï¸âƒ£ **Open/Closed Principle (OCP)**\n\n**Definition:** Software entities should be OPEN for extension but CLOSED for modification.\n\n```\nâŒ BAD: Modifying existing code for new features\n\nclass PaymentProcessor:\n    def process(self, payment_type, amount):\n        if payment_type == \"credit_card\":\n            # Process credit card\n            pass\n        elif payment_type == \"paypal\":\n            # Process PayPal\n            pass\n        elif payment_type == \"crypto\":  # New feature\n            # Process crypto\n            pass\n        # Every new payment type requires modifying this class!\n\nProblems:\nâ€¢ Violates OCP (modify existing code)\nâ€¢ Risk of breaking existing functionality\nâ€¢ Hard to test (many branches)\n\nâœ… GOOD: Extend through inheritance/composition\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process(self, amount):\n        pass\n\nclass CreditCardProcessor(PaymentProcessor):\n    def process(self, amount):\n        # Credit card logic\n        pass\n\nclass PayPalProcessor(PaymentProcessor):\n    def process(self, amount):\n        # PayPal logic\n        pass\n\nclass CryptoProcessor(PaymentProcessor):  # New feature\n    def process(self, amount):\n        # Crypto logic (NO modification to existing classes!)\n        pass\n\nclass PaymentService:\n    def __init__(self, processor: PaymentProcessor):\n        self.processor = processor\n    \n    def pay(self, amount):\n        self.processor.process(amount)\n\n# Usage\nservice = PaymentService(CreditCardProcessor())\nservice.pay(100)\n\nservice = PaymentService(CryptoProcessor())  # New processor, no code change!\nservice.pay(100)\n\nBenefits:\nâœ… Add new payment types without modifying existing code\nâœ… Existing tests don't need to change\nâœ… No risk to existing functionality\n```\n\n**Real-World Example: Django/Flask Middleware**\n```python\n# Open for extension (add middleware)\n# Closed for modification (framework code untouched)\n\napp.use(AuthenticationMiddleware())\napp.use(LoggingMiddleware())\napp.use(RateLimitingMiddleware())  # New feature, no framework change\n```\n\n---\n\n## 3ï¸âƒ£ **Liskov Substitution Principle (LSP)**\n\n**Definition:** Objects of a superclass should be replaceable with objects of a subclass without breaking the application.\n\n```\nâŒ BAD: Subclass violates parent contract\n\nclass Bird:\n    def fly(self):\n        pass\n\nclass Sparrow(Bird):\n    def fly(self):\n        # Can fly\n        pass\n\nclass Penguin(Bird):\n    def fly(self):\n        raise Exception(\"Penguins can't fly!\")  # Violates LSP!\n\n# Usage\ndef make_bird_fly(bird: Bird):\n    bird.fly()  # Expect all birds to fly\n\nmake_bird_fly(Sparrow())  # Works\nmake_bird_fly(Penguin())  # Crashes! Violated LSP\n\nProblem: Penguin is a Bird but can't substitute Bird behavior\n\nâœ… GOOD: Proper abstraction\n\nclass Bird:\n    def eat(self):\n        pass\n\nclass FlyingBird(Bird):\n    def fly(self):\n        pass\n\nclass Sparrow(FlyingBird):\n    def fly(self):\n        # Can fly\n        pass\n\nclass Penguin(Bird):  # Not a FlyingBird\n    def swim(self):\n        # Can swim\n        pass\n\n# Usage\ndef make_bird_fly(bird: FlyingBird):  # Specific contract\n    bird.fly()\n\nmake_bird_fly(Sparrow())  # Works\nmake_bird_fly(Penguin())  # Compile error (type safety)\n\nBenefits:\nâœ… Clear contracts\nâœ… No surprises at runtime\nâœ… Type-safe\n```\n\n**Interview Example: Rectangle-Square Problem**\n```python\nâŒ BAD:\n\nclass Rectangle:\n    def set_width(self, width):\n        self.width = width\n    \n    def set_height(self, height):\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\nclass Square(Rectangle):\n    def set_width(self, width):\n        self.width = width\n        self.height = width  # Maintain square property\n    \n    def set_height(self, height):\n        self.width = height\n        self.height = height\n\n# Usage\ndef test(rectangle: Rectangle):\n    rectangle.set_width(5)\n    rectangle.set_height(4)\n    assert rectangle.area() == 20  # Expect 20\n\ntest(Rectangle())  # Works (20)\ntest(Square())     # Fails! (16, not 20) - Violated LSP\n\nâœ… GOOD: Separate abstractions\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n    \n    def area(self):\n        return self.side * self.side\n```\n\n---\n\n## 4ï¸âƒ£ **Interface Segregation Principle (ISP)**\n\n**Definition:** Clients should not be forced to depend on interfaces they don't use.\n\n```\nâŒ BAD: Fat Interface\n\nclass Worker(ABC):\n    @abstractmethod\n    def work(self):\n        pass\n    \n    @abstractmethod\n    def eat(self):\n        pass\n\nclass HumanWorker(Worker):\n    def work(self):\n        # Humans work\n        pass\n    \n    def eat(self):\n        # Humans eat\n        pass\n\nclass RobotWorker(Worker):\n    def work(self):\n        # Robots work\n        pass\n    \n    def eat(self):\n        raise NotImplementedError(\"Robots don't eat!\")  # Forced to implement!\n\nProblem: RobotWorker forced to implement eat() even though it doesn't need it\n\nâœ… GOOD: Segregated Interfaces\n\nclass Workable(ABC):\n    @abstractmethod\n    def work(self):\n        pass\n\nclass Eatable(ABC):\n    @abstractmethod\n    def eat(self):\n        pass\n\nclass HumanWorker(Workable, Eatable):  # Implements both\n    def work(self):\n        pass\n    \n    def eat(self):\n        pass\n\nclass RobotWorker(Workable):  # Only implements what it needs\n    def work(self):\n        pass\n\n# Usage\ndef manage_work(worker: Workable):\n    worker.work()\n\ndef manage_break(worker: Eatable):\n    worker.eat()\n\nmanage_work(HumanWorker())  # Works\nmanage_work(RobotWorker())  # Works\n\nmanage_break(HumanWorker())  # Works\nmanage_break(RobotWorker())  # Type error (good!)\n\nBenefits:\nâœ… Classes only implement what they need\nâœ… No unnecessary dependencies\nâœ… Easier to maintain\n```\n\n**Real-World Example: Database Interfaces**\n```python\nâŒ BAD:\nclass Database(ABC):\n    @abstractmethod\n    def connect(self):\n        pass\n    \n    @abstractmethod\n    def execute_query(self):\n        pass\n    \n    @abstractmethod\n    def execute_transaction(self):\n        pass\n    \n    @abstractmethod\n    def execute_stored_procedure(self):\n        pass\n\n# NoSQL database forced to implement transactions/stored procedures!\n\nâœ… GOOD:\nclass Connectable(ABC):\n    @abstractmethod\n    def connect(self):\n        pass\n\nclass Queryable(ABC):\n    @abstractmethod\n    def execute_query(self):\n        pass\n\nclass Transactional(ABC):\n    @abstractmethod\n    def execute_transaction(self):\n        pass\n\nclass SQLDatabase(Connectable, Queryable, Transactional):\n    pass\n\nclass NoSQLDatabase(Connectable, Queryable):  # No transactions\n    pass\n```\n\n---\n\n## 5ï¸âƒ£ **Dependency Inversion Principle (DIP)**\n\n**Definition:** \n1. High-level modules should not depend on low-level modules. Both should depend on abstractions.\n2. Abstractions should not depend on details. Details should depend on abstractions.\n\n```\nâŒ BAD: High-level depends on low-level (tight coupling)\n\nclass MySQLDatabase:\n    def save(self, data):\n        # MySQL-specific code\n        pass\n\nclass UserService:  # High-level\n    def __init__(self):\n        self.db = MySQLDatabase()  # Depends on concrete implementation!\n    \n    def create_user(self, user):\n        self.db.save(user)\n\nProblems:\nâ€¢ Can't switch to PostgreSQL without changing UserService\nâ€¢ Hard to test (need real MySQL)\nâ€¢ Tight coupling\n\nâœ… GOOD: Both depend on abstraction\n\nclass Database(ABC):  # Abstraction\n    @abstractmethod\n    def save(self, data):\n        pass\n\nclass MySQLDatabase(Database):  # Low-level\n    def save(self, data):\n        # MySQL-specific code\n        pass\n\nclass PostgreSQLDatabase(Database):  # Low-level\n    def save(self, data):\n        # PostgreSQL-specific code\n        pass\n\nclass UserService:  # High-level\n    def __init__(self, db: Database):  # Depends on abstraction!\n        self.db = db\n    \n    def create_user(self, user):\n        self.db.save(user)\n\n# Usage\nservice = UserService(MySQLDatabase())  # Production\nservice = UserService(PostgreSQLDatabase())  # Easy switch\nservice = UserService(MockDatabase())  # Testing\n\nBenefits:\nâœ… Flexible (swap implementations)\nâœ… Testable (mock the abstraction)\nâœ… Loose coupling\n```\n\n**Dependency Injection (DI)**\n```python\n# Constructor Injection (preferred)\nclass OrderService:\n    def __init__(self, db: Database, email: EmailService):\n        self.db = db\n        self.email = email\n\n# Setter Injection\nclass OrderService:\n    def set_database(self, db: Database):\n        self.db = db\n\n# Method Injection\nclass OrderService:\n    def create_order(self, order, db: Database):\n        db.save(order)\n```\n\n**Real-World Example: Framework DI**\n```python\n# Spring Boot / FastAPI style\n\n@Injectable()\nclass UserService:\n    def __init__(self, db: Database, cache: Cache):\n        self.db = db  # Framework injects dependencies\n        self.cache = cache\n\n# Configuration\nContainer.bind(Database, PostgreSQLDatabase)\nContainer.bind(Cache, RedisCache)\n```\n\n---\n\n## ğŸ¨ **Design Patterns Overview**\n\n### **Creational Patterns** (Object creation)\n\n```\n1. Singleton - One instance only\n   class Database:\n       _instance = None\n       \n       def __new__(cls):\n           if cls._instance is None:\n               cls._instance = super().__new__(cls)\n           return cls._instance\n\n2. Factory - Create objects without specifying exact class\n   class ShapeFactory:\n       def create(self, type):\n           if type == \"circle\":\n               return Circle()\n           elif type == \"square\":\n               return Square()\n\n3. Builder - Construct complex objects step by step\n   Car().set_engine(\"V8\").set_color(\"red\").build()\n\n4. Prototype - Clone existing objects\n   new_object = existing_object.clone()\n```\n\n### **Structural Patterns** (Object composition)\n\n```\n1. Adapter - Make incompatible interfaces compatible\n   class LegacyAdapter:\n       def __init__(self, legacy_system):\n           self.legacy = legacy_system\n       \n       def new_method(self):\n           return self.legacy.old_method()\n\n2. Decorator - Add behavior without modifying class\n   @cache\n   @retry\n   @log\n   def expensive_function():\n       pass\n\n3. Proxy - Control access to object\n   class ImageProxy:\n       def __init__(self, filename):\n           self.filename = filename\n           self.image = None  # Lazy load\n       \n       def display(self):\n           if self.image is None:\n               self.image = Image(self.filename)\n           self.image.display()\n\n4. Facade - Simplified interface to complex system\n   class OrderFacade:\n       def place_order(self, order):\n           inventory.check()\n           payment.process()\n           shipping.schedule()\n           notification.send()\n```\n\n### **Behavioral Patterns** (Object interaction)\n\n```\n1. Strategy - Select algorithm at runtime\n   class PaymentContext:\n       def __init__(self, strategy):\n           self.strategy = strategy\n       \n       def pay(self, amount):\n           self.strategy.pay(amount)\n\n2. Observer - Notify dependents of state changes\n   class Subject:\n       def __init__(self):\n           self.observers = []\n       \n       def notify(self):\n           for observer in self.observers:\n               observer.update()\n\n3. Command - Encapsulate request as object\n   class Command:\n       def execute(self):\n           pass\n   \n   class CopyCommand(Command):\n       def execute(self):\n           # Copy logic\n\n4. Template Method - Define skeleton, subclasses fill steps\n   class DataProcessor:\n       def process(self):\n           self.read_data()\n           self.transform_data()  # Subclass implements\n           self.save_data()\n```\n\n---\n\n## ğŸ§© **OOP Concepts Review**\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ 1. Encapsulation                            â”‚\nâ”‚    Hide internal state, expose interface    â”‚\nâ”‚                                             â”‚\nâ”‚    class BankAccount:                       â”‚\nâ”‚        def __init__(self):                  â”‚\nâ”‚            self.__balance = 0  # Private    â”‚\nâ”‚                                             â”‚\nâ”‚        def deposit(self, amount):           â”‚\nâ”‚            if amount > 0:                   â”‚\nâ”‚                self.__balance += amount     â”‚\nâ”‚                                             â”‚\nâ”‚        def get_balance(self):               â”‚\nâ”‚            return self.__balance            â”‚\nâ”‚                                             â”‚\nâ”‚    âœ… Can't directly modify balance         â”‚\nâ”‚    âœ… Validation in deposit method          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ 2. Inheritance                              â”‚\nâ”‚    Reuse code from parent class             â”‚\nâ”‚                                             â”‚\nâ”‚    class Animal:                            â”‚\nâ”‚        def eat(self):                       â”‚\nâ”‚            pass                             â”‚\nâ”‚                                             â”‚\nâ”‚    class Dog(Animal):  # Inherits eat()    â”‚\nâ”‚        def bark(self):                      â”‚\nâ”‚            pass                             â”‚\nâ”‚                                             â”‚\nâ”‚    âœ… Code reuse                            â”‚\nâ”‚    âœ… \"is-a\" relationship                   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ 3. Polymorphism                             â”‚\nâ”‚    Same interface, different implementationsâ”‚\nâ”‚                                             â”‚\nâ”‚    class Shape:                             â”‚\nâ”‚        def area(self):                      â”‚\nâ”‚            pass                             â”‚\nâ”‚                                             â”‚\nâ”‚    class Circle(Shape):                     â”‚\nâ”‚        def area(self):                      â”‚\nâ”‚            return 3.14 * r * r              â”‚\nâ”‚                                             â”‚\nâ”‚    class Square(Shape):                     â”‚\nâ”‚        def area(self):                      â”‚\nâ”‚            return side * side               â”‚\nâ”‚                                             â”‚\nâ”‚    shapes = [Circle(), Square()]            â”‚\nâ”‚    for shape in shapes:                     â”‚\nâ”‚        print(shape.area())  # Polymorphism! â”‚\nâ”‚                                             â”‚\nâ”‚    âœ… Treat different types uniformly       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ 4. Abstraction                              â”‚\nâ”‚    Hide complexity, show only essentials    â”‚\nâ”‚                                             â”‚\nâ”‚    from abc import ABC, abstractmethod      â”‚\nâ”‚                                             â”‚\nâ”‚    class PaymentGateway(ABC):               â”‚\nâ”‚        @abstractmethod                      â”‚\nâ”‚        def process(self, amount):           â”‚\nâ”‚            pass                             â”‚\nâ”‚                                             â”‚\nâ”‚    class Stripe(PaymentGateway):            â”‚\nâ”‚        def process(self, amount):           â”‚\nâ”‚            # Stripe-specific implementation â”‚\nâ”‚            pass                             â”‚\nâ”‚                                             â”‚\nâ”‚    âœ… Focus on \"what\", not \"how\"            â”‚\nâ”‚    âœ… Enforce contracts                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## ğŸ¯ **Composition vs Inheritance**\n\n```\nâŒ Inheritance Overuse:\n\nclass Animal:\n    def move(self): pass\n\nclass FlyingAnimal(Animal):\n    def fly(self): pass\n\nclass SwimmingAnimal(Animal):\n    def swim(self): pass\n\nclass Duck(FlyingAnimal, SwimmingAnimal):  # Multiple inheritance mess\n    pass\n\nProblem: What about flying fish? Swimming birds?\n\nâœ… Composition (Preferred):\n\nclass Flyable:\n    def fly(self): pass\n\nclass Swimmable:\n    def swim(self): pass\n\nclass Duck:\n    def __init__(self):\n        self.flying = Flyable()  # Compose behaviors\n        self.swimming = Swimmable()\n    \n    def fly(self):\n        self.flying.fly()\n    \n    def swim(self):\n        self.swimming.swim()\n\nBenefits:\nâœ… Flexible (add/remove behaviors at runtime)\nâœ… No diamond problem (multiple inheritance)\nâœ… \"has-a\" relationship (more natural)\n\nRule of Thumb:\nâ€¢ Use Inheritance for \"is-a\" relationships (Dog is an Animal)\nâ€¢ Use Composition for \"has-a\" relationships (Car has an Engine)\n```\n\n---\n\n## ğŸ“‹ **Interview Preparation Checklist**\n\nWhen designing a class, ask:\n\n1. **SRP**: Does this class have one clear responsibility?\n2. **OCP**: Can I add features without modifying existing code?\n3. **LSP**: Can subclasses substitute the parent safely?\n4. **ISP**: Are interfaces focused (no fat interfaces)?\n5. **DIP**: Am I depending on abstractions, not concrete classes?\n\n**Example Interview Flow:**\n\nInterviewer: \"Design a notification system.\"\n\nYou:\n1. **Identify responsibilities**: NotificationSender, NotificationFormatter, NotificationLogger (SRP)\n2. **Define abstraction**: NotificationChannel interface (DIP)\n3. **Implement channels**: EmailChannel, SMSChannel, PushChannel (OCP - add new without modifying)\n4. **Use composition**: NotificationService has NotificationChannel (Composition over inheritance)\n5. **Apply patterns**: Strategy (channel selection), Observer (notify subscribers)\n\nCode:\n```python\nclass NotificationChannel(ABC):\n    @abstractmethod\n    def send(self, message):\n        pass\n\nclass EmailChannel(NotificationChannel):\n    def send(self, message):\n        # Send email\n\nclass SMSChannel(NotificationChannel):\n    def send(self, message):\n        # Send SMS\n\nclass NotificationService:\n    def __init__(self, channel: NotificationChannel):\n        self.channel = channel  # DIP\n    \n    def notify(self, user, message):\n        formatted = self.format(message)  # SRP (separate formatting)\n        self.channel.send(formatted)  # OCP (any channel)\n        self.log(user, formatted)  # SRP (separate logging)\n```\n\n**Remember: Explain WHY, not just HOW!**\n\n\"I'm using the Strategy pattern here because notification channels can change at runtime (email during business hours, SMS for urgent). This makes the system flexible and follows OCP - we can add Slack or WhatsApp channels without modifying existing code.\"\n\n---\n\n## ğŸ† **SOLID Principles Quick Reference**\n\n| Principle | Summary | Key Benefit |\n|-----------|---------|-------------|\n| **S**RP | One class = One responsibility | Easy to change |\n| **O**CP | Open extension, closed modification | Safe to extend |\n| **L**SP | Subclass = Substitute parent | No surprises |\n| **I**SP | Small, focused interfaces | No unused dependencies |\n| **D**IP | Depend on abstractions | Flexible, testable |\n\n**Mnemonic: \"SOLID code is SOLID (strong, reliable, maintainable)\"**\n\n## ğŸ¢ Top LLD Interview Questions (FAANG Companies)\n\n### **Most Asked LLD Problems by Company:**\n\n#### 1. **Design Parking Lot** (Amazon, Microsoft, Google)\n```\nğŸ¯ Requirements:\nâ€¢ Multiple floors\nâ€¢ Different spot sizes (Compact, Large, Handicapped)\nâ€¢ Entry/Exit gates\nâ€¢ Parking fee calculation\nâ€¢ Spot availability tracking\n\nğŸ—ï¸ Object-Oriented Design:\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ CLASS DIAGRAM                                    â”‚\nâ”‚                                                   â”‚\nâ”‚ ParkingLot                                       â”‚\nâ”‚ â”œâ”€â”€ floors: List[Floor]                          â”‚\nâ”‚ â”œâ”€â”€ entry_gates: List[Gate]                     â”‚\nâ”‚ â”œâ”€â”€ exit_gates: List[Gate]                      â”‚\nâ”‚ â””â”€â”€ methods:                                     â”‚\nâ”‚     â”œâ”€â”€ park_vehicle(vehicle)                    â”‚\nâ”‚     â”œâ”€â”€ unpark_vehicle(ticket)                   â”‚\nâ”‚     â””â”€â”€ calculate_fee(ticket)                    â”‚\nâ”‚                                                   â”‚\nâ”‚ Floor                                            â”‚\nâ”‚ â”œâ”€â”€ floor_number: int                            â”‚\nâ”‚ â”œâ”€â”€ spots: List[ParkingSpot]                     â”‚\nâ”‚ â””â”€â”€ methods:                                     â”‚\nâ”‚     â””â”€â”€ find_available_spot(vehicle_type)        â”‚\nâ”‚                                                   â”‚\nâ”‚ ParkingSpot (Abstract)                           â”‚\nâ”‚ â”œâ”€â”€ spot_id: str                                 â”‚\nâ”‚ â”œâ”€â”€ is_available: bool                           â”‚\nâ”‚ â”œâ”€â”€ vehicle: Vehicle                             â”‚\nâ”‚ â””â”€â”€ subclasses:                                  â”‚\nâ”‚     â”œâ”€â”€ CompactSpot                              â”‚\nâ”‚     â”œâ”€â”€ LargeSpot                                â”‚\nâ”‚     â””â”€â”€ HandicappedSpot                          â”‚\nâ”‚                                                   â”‚\nâ”‚ Vehicle (Abstract)                               â”‚\nâ”‚ â”œâ”€â”€ license_plate: str                           â”‚\nâ”‚ â”œâ”€â”€ vehicle_type: VehicleType                    â”‚\nâ”‚ â””â”€â”€ subclasses:                                  â”‚\nâ”‚     â”œâ”€â”€ Car                                      â”‚\nâ”‚     â”œâ”€â”€ Truck                                    â”‚\nâ”‚     â”œâ”€â”€ Motorcycle                               â”‚\nâ”‚     â””â”€â”€ Van                                      â”‚\nâ”‚                                                   â”‚\nâ”‚ Ticket                                           â”‚\nâ”‚ â”œâ”€â”€ ticket_id: str                               â”‚\nâ”‚ â”œâ”€â”€ entry_time: datetime                         â”‚\nâ”‚ â”œâ”€â”€ exit_time: datetime                          â”‚\nâ”‚ â”œâ”€â”€ spot: ParkingSpot                            â”‚\nâ”‚ â””â”€â”€ fee: float                                   â”‚\nâ”‚                                                   â”‚\nâ”‚ PaymentStrategy (Interface)                      â”‚\nâ”‚ â”œâ”€â”€ calculate_fee(ticket)                        â”‚\nâ”‚ â””â”€â”€ implementations:                             â”‚\nâ”‚     â”œâ”€â”€ HourlyPayment                            â”‚\nâ”‚     â”œâ”€â”€ DailyPayment                             â”‚\nâ”‚     â””â”€â”€ MonthlyPass                              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nğŸ¨ Design Patterns Used:\n1. **Singleton**: ParkingLot instance\n2. **Factory**: Create different vehicle types\n3. **Strategy**: Different payment strategies\n4. **Observer**: Notify when spots available\n\nğŸ”‘ Key Interview Points:\nâ€¢ Enum for VehicleType (COMPACT, LARGE, MOTORCYCLE)\nâ€¢ SOLID principles (Single Responsibility)\nâ€¢ Inheritance vs Composition trade-off\nâ€¢ Thread safety for concurrent parking\nâ€¢ Database schema design\n\nğŸ’¡ Follow-up Questions:\nQ: How to handle multiple floors efficiently?\nA: HashMap<VehicleType, List<Floor>> for O(1) lookup\n\nQ: What if parking lot is full?\nA: Priority queue for waiting vehicles\n\nQ: How to reserve spots in advance?\nA: Add reservation_time field, cron job to expire\n```\n\n#### 2. **Design Elevator System** (Google, Microsoft, Uber)\n```\nğŸ¯ Requirements:\nâ€¢ Multiple elevators\nâ€¢ Multiple floors (ground + n floors)\nâ€¢ Request from outside (up/down button)\nâ€¢ Request from inside (floor number)\nâ€¢ Optimize wait time\n\nğŸ—ï¸ Design:\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Elevator                                         â”‚\nâ”‚ â”œâ”€â”€ id: int                                      â”‚\nâ”‚ â”œâ”€â”€ current_floor: int                           â”‚\nâ”‚ â”œâ”€â”€ direction: Direction (UP/DOWN/IDLE)          â”‚\nâ”‚ â”œâ”€â”€ requests: PriorityQueue[Request]             â”‚\nâ”‚ â”œâ”€â”€ capacity: int                                â”‚\nâ”‚ â”œâ”€â”€ current_load: int                            â”‚\nâ”‚ â””â”€â”€ methods:                                     â”‚\nâ”‚     â”œâ”€â”€ move()                                   â”‚\nâ”‚     â”œâ”€â”€ open_door()                              â”‚\nâ”‚     â”œâ”€â”€ close_door()                             â”‚\nâ”‚     â””â”€â”€ add_request(request)                     â”‚\nâ”‚                                                   â”‚\nâ”‚ ElevatorController                               â”‚\nâ”‚ â”œâ”€â”€ elevators: List[Elevator]                    â”‚\nâ”‚ â”œâ”€â”€ strategy: SchedulingStrategy                 â”‚\nâ”‚ â””â”€â”€ methods:                                     â”‚\nâ”‚     â””â”€â”€ assign_elevator(request)                 â”‚\nâ”‚                                                   â”‚\nâ”‚ Request                                          â”‚\nâ”‚ â”œâ”€â”€ source_floor: int                            â”‚\nâ”‚ â”œâ”€â”€ destination_floor: int                       â”‚\nâ”‚ â”œâ”€â”€ direction: Direction                         â”‚\nâ”‚ â””â”€â”€ timestamp: datetime                          â”‚\nâ”‚                                                   â”‚\nâ”‚ SchedulingStrategy (Interface)                   â”‚\nâ”‚ â””â”€â”€ implementations:                             â”‚\nâ”‚     â”œâ”€â”€ NearestCarStrategy                       â”‚\nâ”‚     â”‚   â†’ Assign nearest elevator                â”‚\nâ”‚     â”œâ”€â”€ DirectionBasedStrategy                   â”‚\nâ”‚     â”‚   â†’ Assign elevator going same direction   â”‚\nâ”‚     â””â”€â”€ LoadBalancingStrategy                    â”‚\nâ”‚         â†’ Distribute load evenly                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nğŸ¯ Algorithm (SCAN/LOOK):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Elevator at Floor 5, going UP                    â”‚\nâ”‚ Requests: [7, 3, 10, 2, 8]                       â”‚\nâ”‚                                                   â”‚\nâ”‚ Step 1: Serve UP requests first                  â”‚\nâ”‚   Current: 5 â†’ Next: 7 (pick up)                â”‚\nâ”‚   â†’ 8 (pick up) â†’ 10 (pick up)                   â”‚\nâ”‚                                                   â”‚\nâ”‚ Step 2: Change direction to DOWN                 â”‚\nâ”‚   Current: 10 â†’ Next: 3 (pick up)                â”‚\nâ”‚   â†’ 2 (pick up)                                  â”‚\nâ”‚                                                   â”‚\nâ”‚ This minimizes reversals (efficient!)            â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nğŸ”‘ Key Interview Points:\nâ€¢ State machine (MOVING_UP, MOVING_DOWN, IDLE)\nâ€¢ Priority queue for requests\nâ€¢ Starvation prevention (max wait time)\nâ€¢ Thread safety (synchronized methods)\n\nğŸ’¡ Follow-up Questions:\nQ: How to handle emergency (fire alarm)?\nA: State pattern - EmergencyState (go to ground floor)\n\nQ: Optimize for peak hours (9am rush)?\nA: Pre-position elevators (3 at ground, 2 at top floors)\n\nQ: Power optimization?\nA: Idle timeout - turn off lights, reduce movement\n```\n\n#### 3. **Design Chess Game** (Amazon, Google)\n```\nğŸ¯ Requirements:\nâ€¢ Two players (White, Black)\nâ€¢ 8Ã—8 board\nâ€¢ Different pieces (King, Queen, Rook, etc.)\nâ€¢ Move validation\nâ€¢ Check/Checkmate detection\nâ€¢ Castling, En passant special moves\n\nğŸ—ï¸ Object-Oriented Design:\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ ChessGame                                        â”‚\nâ”‚ â”œâ”€â”€ board: Board                                 â”‚\nâ”‚ â”œâ”€â”€ players: [Player, Player]                    â”‚\nâ”‚ â”œâ”€â”€ current_turn: Player                         â”‚\nâ”‚ â”œâ”€â”€ status: GameStatus (ACTIVE/CHECK/CHECKMATE) â”‚\nâ”‚ â”œâ”€â”€ move_history: List[Move]                     â”‚\nâ”‚ â””â”€â”€ methods:                                     â”‚\nâ”‚     â”œâ”€â”€ make_move(from, to)                      â”‚\nâ”‚     â”œâ”€â”€ is_valid_move(move)                      â”‚\nâ”‚     â”œâ”€â”€ is_check()                               â”‚\nâ”‚     â”œâ”€â”€ is_checkmate()                           â”‚\nâ”‚     â””â”€â”€ undo_move()                              â”‚\nâ”‚                                                   â”‚\nâ”‚ Board                                            â”‚\nâ”‚ â”œâ”€â”€ cells: Cell[8][8]                            â”‚\nâ”‚ â””â”€â”€ methods:                                     â”‚\nâ”‚     â”œâ”€â”€ get_piece(row, col)                      â”‚\nâ”‚     â””â”€â”€ set_piece(row, col, piece)               â”‚\nâ”‚                                                   â”‚\nâ”‚ Cell                                             â”‚\nâ”‚ â”œâ”€â”€ row: int (0-7)                               â”‚\nâ”‚ â”œâ”€â”€ col: int (0-7)                               â”‚\nâ”‚ â”œâ”€â”€ piece: Piece | None                          â”‚\nâ”‚                                                   â”‚\nâ”‚ Piece (Abstract)                                 â”‚\nâ”‚ â”œâ”€â”€ color: Color (WHITE/BLACK)                   â”‚\nâ”‚ â”œâ”€â”€ is_killed: bool                              â”‚\nâ”‚ â”œâ”€â”€ get_possible_moves(board) â†’ List[Cell]      â”‚\nâ”‚ â””â”€â”€ subclasses:                                  â”‚\nâ”‚     â”œâ”€â”€ King (1 square any direction)            â”‚\nâ”‚     â”œâ”€â”€ Queen (any direction, any distance)      â”‚\nâ”‚     â”œâ”€â”€ Rook (horizontal/vertical)               â”‚\nâ”‚     â”œâ”€â”€ Bishop (diagonal)                        â”‚\nâ”‚     â”œâ”€â”€ Knight (L-shape)                         â”‚\nâ”‚     â””â”€â”€ Pawn (forward, capture diagonal)         â”‚\nâ”‚                                                   â”‚\nâ”‚ Move                                             â”‚\nâ”‚ â”œâ”€â”€ player: Player                               â”‚\nâ”‚ â”œâ”€â”€ piece: Piece                                 â”‚\nâ”‚ â”œâ”€â”€ from_cell: Cell                              â”‚\nâ”‚ â”œâ”€â”€ to_cell: Cell                                â”‚\nâ”‚ â”œâ”€â”€ piece_killed: Piece | None                   â”‚\nâ”‚ â””â”€â”€ timestamp: datetime                          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nğŸ¨ Design Patterns:\n1. **Command Pattern**: Move as command (undo/redo)\n2. **Template Method**: Piece validation logic\n3. **Factory**: Create pieces\n4. **Singleton**: ChessGame instance\n\nğŸ”‘ Move Validation (Example - Knight):\n```python\nclass Knight(Piece):\n    def get_possible_moves(self, board):\n        moves = []\n        row, col = self.current_cell.row, self.current_cell.col\n        \n        # L-shaped moves (8 possibilities)\n        offsets = [\n            (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n            (1, -2), (1, 2), (2, -1), (2, 1)\n        ]\n        \n        for dr, dc in offsets:\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < 8 and 0 <= new_col < 8:\n                target_cell = board.cells[new_row][new_col]\n                # Can move if empty or opponent's piece\n                if not target_cell.piece or \\\n                   target_cell.piece.color != self.color:\n                    moves.append(target_cell)\n        \n        return moves\n```\n\nğŸ’¡ Follow-up Questions:\nQ: How to detect checkmate?\nA: 1) King in check, 2) No valid moves for any piece\n\nQ: How to handle special moves (castling)?\nA: Special validation in King class, check if rook hasn't moved\n\nQ: Implement AI opponent?\nA: Minimax algorithm with alpha-beta pruning (depth 4-6)\n```\n\n#### 4. **Design LRU Cache** (Facebook, Amazon, Google)\n```\nğŸ¯ Requirements:\nâ€¢ get(key) - O(1)\nâ€¢ put(key, value) - O(1)\nâ€¢ Fixed capacity\nâ€¢ Evict least recently used when full\n\nğŸ—ï¸ Data Structure Design:\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ LRU Cache Architecture                           â”‚\nâ”‚                                                   â”‚\nâ”‚ HashMap + Doubly Linked List                     â”‚\nâ”‚                                                   â”‚\nâ”‚ HashMap: key â†’ Node                              â”‚\nâ”‚ â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”                                   â”‚\nâ”‚ â”‚ \"a\" â”‚ Node1â”‚ â”€â”                                â”‚\nâ”‚ â”‚ \"b\" â”‚ Node2â”‚ â”€â”¼â”€â”                              â”‚\nâ”‚ â”‚ \"c\" â”‚ Node3â”‚ â”€â”¼â”€â”¼â”€â”                            â”‚\nâ”‚ â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚ â”‚                            â”‚\nâ”‚                 â”‚ â”‚ â”‚                            â”‚\nâ”‚ Doubly Linked List: (Most â†’ Least recent)        â”‚\nâ”‚                 â–¼ â–¼ â–¼                            â”‚\nâ”‚ Head â†â†’ [Node1] â†â†’ [Node2] â†â†’ [Node3] â†â†’ Tail   â”‚\nâ”‚ (dummy)   \"a\":1     \"b\":2     \"c\":3   (dummy)   â”‚\nâ”‚                                                   â”‚\nâ”‚ Operations:                                      â”‚\nâ”‚ â€¢ get(\"b\"): Move Node2 to front                  â”‚\nâ”‚ â€¢ put(\"d\", 4): Add at front, remove Tail.prev    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nğŸ¨ Implementation (Python):\n```python\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}  # key â†’ Node\n        self.head = Node(0, 0)  # Dummy head\n        self.tail = Node(0, 0)  # Dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def _remove(self, node):\n        \"\"\"Remove node from linked list\"\"\"\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n    \n    def _add_to_front(self, node):\n        \"\"\"Add node right after head (most recent)\"\"\"\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            self._add_to_front(node)\n            return node.value\n        return -1\n    \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            # Update existing\n            node = self.cache[key]\n            node.value = value\n            self._remove(node)\n            self._add_to_front(node)\n        else:\n            # Add new\n            if len(self.cache) >= self.capacity:\n                # Remove least recently used (before tail)\n                lru = self.tail.prev\n                self._remove(lru)\n                del self.cache[lru.key]\n            \n            new_node = Node(key, value)\n            self.cache[key] = new_node\n            self._add_to_front(new_node)\n\n# Usage\ncache = LRUCache(2)\ncache.put(1, 1)  # cache: {1=1}\ncache.put(2, 2)  # cache: {1=1, 2=2}\ncache.get(1)     # returns 1, cache: {2=2, 1=1}\ncache.put(3, 3)  # evicts 2, cache: {1=1, 3=3}\ncache.get(2)     # returns -1 (not found)\n```\n\nğŸ’¡ Follow-up Questions:\nQ: Implement LFU (Least Frequently Used) cache?\nA: Add frequency counter, min heap for O(log n)\n\nQ: Thread-safe LRU cache?\nA: Add ReentrantLock, synchronized methods\n\nQ: Distributed LRU cache?\nA: Redis (server-side), consistent hashing for sharding\n```\n\n#### 5. **Design Rate Limiter** (Stripe, Twitter, Amazon API Gateway)\n```\nğŸ¯ Requirements:\nâ€¢ Limit API requests per user\nâ€¢ Different limits (100/min, 1000/hour)\nâ€¢ Distributed system support\nâ€¢ Minimal latency (<10ms)\n\nğŸ—ï¸ Algorithms:\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ 1. Token Bucket (Stripe's approach)             â”‚\nâ”‚                                                   â”‚\nâ”‚ Bucket: 100 tokens (capacity)                   â”‚\nâ”‚ Refill: 10 tokens/second                         â”‚\nâ”‚                                                   â”‚\nâ”‚ [ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™] (10 tokens)                â”‚\nâ”‚ â†“ Request arrives                                â”‚\nâ”‚ [ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™] (9 tokens left)               â”‚\nâ”‚                                                   â”‚\nâ”‚ Every second: Add 10 tokens (max 100)            â”‚\nâ”‚                                                   â”‚\nâ”‚ Pros:                                            â”‚\nâ”‚ âœ… Smooth traffic                                â”‚\nâ”‚ âœ… Burst allowed (consume all tokens)            â”‚\nâ”‚ âœ… Simple to implement                           â”‚\nâ”‚                                                   â”‚\nâ”‚ Cons:                                            â”‚\nâ”‚ âŒ Token count in memory (state)                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ 2. Sliding Window Log (Twitter's approach)       â”‚\nâ”‚                                                   â”‚\nâ”‚ Store timestamp of each request                  â”‚\nâ”‚ Window: Last 60 seconds                          â”‚\nâ”‚                                                   â”‚\nâ”‚ Request timestamps: [10:00:01, 10:00:05, ...]   â”‚\nâ”‚                                                   â”‚\nâ”‚ New request at 10:01:02:                         â”‚\nâ”‚ 1. Remove timestamps < 10:00:02                  â”‚\nâ”‚ 2. Count remaining (98 requests)                 â”‚\nâ”‚ 3. If count < 100: Allow                         â”‚\nâ”‚ 4. Else: Reject (429 Too Many Requests)          â”‚\nâ”‚                                                   â”‚\nâ”‚ Pros:                                            â”‚\nâ”‚ âœ… Accurate                                      â”‚\nâ”‚ âœ… No burst issues                               â”‚\nâ”‚                                                   â”‚\nâ”‚ Cons:                                            â”‚\nâ”‚ âŒ Memory intensive (store all timestamps)       â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ 3. Fixed Window Counter (Simple)                 â”‚\nâ”‚                                                   â”‚\nâ”‚ Window: 10:00:00 - 10:01:00                      â”‚\nâ”‚ Counter: 98/100 requests                         â”‚\nâ”‚                                                   â”‚\nâ”‚ At 10:01:00: Reset counter to 0                  â”‚\nâ”‚                                                   â”‚\nâ”‚ Problem: Edge case burst                         â”‚\nâ”‚ 10:00:59 â†’ 50 requests                           â”‚\nâ”‚ 10:01:01 â†’ 50 requests                           â”‚\nâ”‚ = 100 requests in 2 seconds! (should be 60s)     â”‚\nâ”‚                                                   â”‚\nâ”‚ Pros:                                            â”‚\nâ”‚ âœ… Memory efficient                              â”‚\nâ”‚ âœ… Simple                                        â”‚\nâ”‚                                                   â”‚\nâ”‚ Cons:                                            â”‚\nâ”‚ âŒ Burst at window boundaries                    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nğŸ¨ Implementation (Token Bucket in Redis):\n```python\nimport time\nimport redis\n\nclass TokenBucketRateLimiter:\n    def __init__(self, redis_client, capacity=100, refill_rate=10):\n        self.redis = redis_client\n        self.capacity = capacity\n        self.refill_rate = refill_rate  # tokens/second\n    \n    def allow_request(self, user_id):\n        key = f\"rate_limit:{user_id}\"\n        current_time = time.time()\n        \n        # Lua script for atomic operation\n        lua_script = \"\"\"\n        local key = KEYS[1]\n        local capacity = tonumber(ARGV[1])\n        local refill_rate = tonumber(ARGV[2])\n        local current_time = tonumber(ARGV[3])\n        \n        local token_data = redis.call('HMGET', key, 'tokens', 'last_refill')\n        local tokens = tonumber(token_data[1]) or capacity\n        local last_refill = tonumber(token_data[2]) or current_time\n        \n        -- Calculate new tokens\n        local time_passed = current_time - last_refill\n        local new_tokens = math.min(capacity, tokens + time_passed * refill_rate)\n        \n        if new_tokens >= 1 then\n            -- Allow request\n            new_tokens = new_tokens - 1\n            redis.call('HSET', key, 'tokens', new_tokens, 'last_refill', current_time)\n            redis.call('EXPIRE', key, 3600)  -- 1 hour TTL\n            return 1  -- Allowed\n        else\n            return 0  -- Rate limited\n        end\n        \"\"\"\n        \n        result = self.redis.eval(\n            lua_script, 1, key,\n            self.capacity, self.refill_rate, current_time\n        )\n        \n        return bool(result)\n\n# Usage\nredis_client = redis.Redis(host='localhost', port=6379)\nlimiter = TokenBucketRateLimiter(redis_client)\n\nif limiter.allow_request(\"user:123\"):\n    # Process request\n    print(\"Request allowed\")\nelse:\n    # Return 429 Too Many Requests\n    print(\"Rate limit exceeded\")\n```\n\nğŸ’¡ Distributed Rate Limiting:\nâ€¢ Use Redis (centralized counter)\nâ€¢ Or Cassandra (distributed counter)\nâ€¢ Consistent hashing for sharding\n\nğŸ”‘ Interview Tips:\nâ€¢ Discuss trade-offs (accuracy vs memory)\nâ€¢ Mention Redis Lua scripts (atomic)\nâ€¢ Talk about distributed systems challenges\nâ€¢ Explain 429 status code\n```\n\n#### 6. **Design Notification Service** (Facebook, LinkedIn)\n```\nğŸ¯ Requirements:\nâ€¢ Multiple channels (Email, SMS, Push)\nâ€¢ Priority levels (High, Medium, Low)\nâ€¢ Retry logic for failures\nâ€¢ Rate limiting (don't spam users)\nâ€¢ Template support\n\nğŸ—ï¸ Architecture:\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ NotificationService                              â”‚\nâ”‚ â”œâ”€â”€ send(notification)                           â”‚\nâ”‚ â”œâ”€â”€ retry_failed()                               â”‚\nâ”‚ â””â”€â”€ get_user_preferences(user_id)                â”‚\nâ”‚                                                   â”‚\nâ”‚ Notification                                     â”‚\nâ”‚ â”œâ”€â”€ id: UUID                                     â”‚\nâ”‚ â”œâ”€â”€ user_id: str                                 â”‚\nâ”‚ â”œâ”€â”€ type: NotificationType (EMAIL/SMS/PUSH)      â”‚\nâ”‚ â”œâ”€â”€ priority: Priority (HIGH/MEDIUM/LOW)         â”‚\nâ”‚ â”œâ”€â”€ template: Template                           â”‚\nâ”‚ â”œâ”€â”€ content: dict                                â”‚\nâ”‚ â””â”€â”€ retry_count: int                             â”‚\nâ”‚                                                   â”‚\nâ”‚ NotificationChannel (Interface)                  â”‚\nâ”‚ â”œâ”€â”€ send(notification)                           â”‚\nâ”‚ â””â”€â”€ implementations:                             â”‚\nâ”‚     â”œâ”€â”€ EmailChannel (SendGrid/SES)              â”‚\nâ”‚     â”œâ”€â”€ SMSChannel (Twilio)                      â”‚\nâ”‚     â””â”€â”€ PushChannel (FCM/APNs)                   â”‚\nâ”‚                                                   â”‚\nâ”‚ Template                                         â”‚\nâ”‚ â”œâ”€â”€ template_id: str                             â”‚\nâ”‚ â”œâ”€â”€ subject: str                                 â”‚\nâ”‚ â”œâ”€â”€ body: str (with placeholders)                â”‚\nâ”‚ â””â”€â”€ render(data) â†’ str                           â”‚\nâ”‚                                                   â”‚\nâ”‚ UserPreferences                                  â”‚\nâ”‚ â”œâ”€â”€ user_id: str                                 â”‚\nâ”‚ â”œâ”€â”€ enabled_channels: Set[NotificationType]      â”‚\nâ”‚ â”œâ”€â”€ quiet_hours: (start_time, end_time)          â”‚\nâ”‚ â””â”€â”€ frequency_limit: int (max per day)           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nğŸ¨ Design Patterns:\n1. **Strategy Pattern**: Different channels\n2. **Template Method**: Notification sending flow\n3. **Observer Pattern**: Subscribe to events\n4. **Queue Pattern**: Async processing\n\nğŸ”„ Flow with Retry Logic:\n```\n1. Event occurs (new follower)\n2. Create notification\n3. Add to priority queue (Kafka/RabbitMQ)\n4. Worker picks from queue\n5. Check user preferences (quiet hours?)\n6. Select channel (email, push, sms)\n7. Attempt send\n8. If success: Mark delivered\n9. If failure: Retry with exponential backoff\n   - Retry 1: After 1 minute\n   - Retry 2: After 5 minutes  \n   - Retry 3: After 30 minutes\n   - Max retries: 3\n10. After max retries: Move to dead letter queue\n```\n\nğŸ’¡ Interview Points:\nâ€¢ Discuss deduplication (don't send same notif twice)\nâ€¢ Rate limiting per user (max 10 emails/day)\nâ€¢ Priority queue (high priority first)\nâ€¢ Idempotency (handle duplicate events)\n```\n\n---\n\n## ğŸ“ Top 10 Design Patterns for Interviews\n\n### **Creational Patterns:**\n1. **Singleton** - One instance (Database connection pool)\n2. **Factory** - Create objects (Vehicle factory)\n3. **Builder** - Step-by-step construction (SQL query builder)\n\n### **Structural Patterns:**\n4. **Adapter** - Interface compatibility (Old API â†’ New API)\n5. **Decorator** - Add functionality (Logging decorator)\n6. **Facade** - Simplified interface (Payment facade)\n\n### **Behavioral Patterns:**\n7. **Strategy** - Interchangeable algorithms (Sorting, Payment)\n8. **Observer** - Event notification (Pub/Sub)\n9. **Command** - Encapsulate requests (Undo/Redo)\n10. **State** - State-based behavior (Order states)\n\n---\n\n## ğŸ“ LLD Interview Template\n\n```\nStep 1: Clarify Requirements (5 min)\nâ€¢ Functional requirements (what features?)\nâ€¢ Non-functional (scalability, performance)\nâ€¢ Constraints (single-threaded, distributed?)\n\nStep 2: Identify Objects/Classes (10 min)\nâ€¢ Nouns â†’ Classes (User, Product, Order)\nâ€¢ Verbs â†’ Methods (create, update, delete)\nâ€¢ Relationships (has-a, is-a)\n\nStep 3: Define Class Diagram (15 min)\nâ€¢ Attributes and methods\nâ€¢ Inheritance hierarchy\nâ€¢ Interfaces\nâ€¢ Design patterns\n\nStep 4: Implement Core Logic (15 min)\nâ€¢ Write pseudo-code or actual code\nâ€¢ Show SOLID principles\nâ€¢ Handle edge cases\n\nStep 5: Discuss Trade-offs (5 min)\nâ€¢ Performance vs Code simplicity\nâ€¢ Extensibility vs Complexity\nâ€¢ Memory vs CPU\n```\n\n---\n\n## ğŸ”¥ Practice Strategy\n\n### **Week 1-2: SOLID + Patterns**\n- Study all SOLID principles with examples\n- Implement 10 design patterns\n\n### **Week 3-4: Classic Problems**\n- Parking Lot\n- Elevator System\n- Chess Game\n- LRU Cache\n- Rate Limiter\n\n### **Week 5-6: Advanced Problems**\n- Design Amazon (e-commerce)\n- Design Uber (ride-sharing)\n- Design Splitwise (expense sharing)\n- Design BookMyShow (ticket booking)\n\n### **Pro Tips:**\nâœ… Think out loud during interviews\nâœ… Ask clarifying questions\nâœ… Draw class diagrams\nâœ… Code in preferred language (Python/Java/C++)\nâœ… Test with examples\nâœ… Discuss extensibility\n\n**Remember: LLD is about demonstrating clean code principles and design thinking, not perfect syntax!**\n\n```python\n# SOLID Principles Implementation - CAREER-DEFINING KNOWLEDGE!\n\nprint(\"ğŸ¯ SOLID PRINCIPLES - SOFTWARE ARCHITECTURE EXCELLENCE!\")\nprint(\"=\" * 60)\n\n# ===============================================================\n# 1. SINGLE RESPONSIBILITY PRINCIPLE (SRP)\n# ===============================================================\nprint(\"\\nğŸ”¥ 1. SINGLE RESPONSIBILITY PRINCIPLE\")\nprint(\"Each class should have only ONE reason to change\")\n\n# âŒ BAD EXAMPLE - Multiple responsibilities\nclass BadUser:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n    \n    def save_to_database(self):\n        \"\"\"Database logic - responsibility 1\"\"\"\n        print(f\"Saving {self.name} to database\")\n    \n    def send_email(self):\n        \"\"\"Email logic - responsibility 2\"\"\"\n        print(f\"Sending email to {self.email}\")\n    \n    def validate_email(self):\n        \"\"\"Validation logic - responsibility 3\"\"\"\n        return \"@\" in self.email\n\n# âœ… GOOD EXAMPLE - Single responsibility per class\nclass User:\n    \"\"\"Responsible ONLY for user data\"\"\"\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\nclass UserRepository:\n    \"\"\"Responsible ONLY for database operations\"\"\"\n    def save(self, user):\n        print(f\"Saving {user.name} to database\")\n    \n    def find_by_email(self, email):\n        print(f\"Finding user by email: {email}\")\n\nclass EmailService:\n    \"\"\"Responsible ONLY for email operations\"\"\"\n    def send_welcome_email(self, user):\n        print(f\"Sending welcome email to {user.email}\")\n\nclass EmailValidator:\n    \"\"\"Responsible ONLY for email validation\"\"\"\n    @staticmethod\n    def is_valid(email):\n        return \"@\" in email and \".\" in email\n\n# Demonstration\nuser = User(\"John Doe\", \"john@example.com\")\nrepository = UserRepository()\nemail_service = EmailService()\nvalidator = EmailValidator()\n\nprint(\"\\nSRP in action:\")\nprint(f\"User created: {user.name}\")\nprint(f\"Email valid: {validator.is_valid(user.email)}\")\nrepository.save(user)\nemail_service.send_welcome_email(user)\n\n# ===============================================================\n# 2. OPEN/CLOSED PRINCIPLE (OCP)\n# ===============================================================\nprint(\"\\n\\nğŸ”¥ 2. OPEN/CLOSED PRINCIPLE\")\nprint(\"Software entities should be OPEN for extension, CLOSED for modification\")\n\nfrom abc import ABC, abstractmethod\n\n# âœ… GOOD EXAMPLE - Extensible without modification\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14159 * self.radius ** 2\n\nclass Triangle(Shape):\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n    \n    def area(self):\n        return 0.5 * self.base * self.height\n\nclass AreaCalculator:\n    \"\"\"Can handle any Shape without modification!\"\"\"\n    def calculate_total_area(self, shapes):\n        return sum(shape.area() for shape in shapes)\n\n# Demonstration\nshapes = [\n    Rectangle(5, 10),\n    Circle(3),\n    Triangle(4, 6)\n]\n\ncalculator = AreaCalculator()\ntotal_area = calculator.calculate_total_area(shapes)\nprint(f\"\\nOCP in action:\")\nprint(f\"Total area of all shapes: {total_area:.2f}\")\n\n# ===============================================================\n# 3. LISKOV SUBSTITUTION PRINCIPLE (LSP)\n# ===============================================================\nprint(\"\\n\\nğŸ”¥ 3. LISKOV SUBSTITUTION PRINCIPLE\")\nprint(\"Objects of a superclass should be replaceable with objects of subclasses\")\n\nclass Bird(ABC):\n    @abstractmethod\n    def move(self):\n        pass\n\nclass FlyingBird(Bird):\n    @abstractmethod\n    def fly(self):\n        pass\n\nclass Eagle(FlyingBird):\n    def move(self):\n        return \"Flying high\"\n    \n    def fly(self):\n        return \"Soaring through the sky\"\n\nclass Penguin(Bird):\n    def move(self):\n        return \"Swimming gracefully\"\n\nclass BirdHandler:\n    def make_bird_move(self, bird: Bird):\n        return bird.move()\n\n# Demonstration\nbirds = [Eagle(), Penguin()]\nhandler = BirdHandler()\n\nprint(f\"\\nLSP in action:\")\nfor bird in birds:\n    print(f\"{bird.__class__.__name__}: {handler.make_bird_move(bird)}\")\n\n# ===============================================================\n# 4. INTERFACE SEGREGATION PRINCIPLE (ISP)\n# ===============================================================\nprint(\"\\n\\nğŸ”¥ 4. INTERFACE SEGREGATION PRINCIPLE\")\nprint(\"No client should be forced to depend on methods it does not use\")\n\n# âœ… GOOD EXAMPLE - Segregated interfaces\nclass Readable(ABC):\n    @abstractmethod\n    def read(self):\n        pass\n\nclass Writable(ABC):\n    @abstractmethod\n    def write(self, data):\n        pass\n\nclass Executable(ABC):\n    @abstractmethod\n    def execute(self):\n        pass\n\nclass ReadOnlyFile(Readable):\n    def __init__(self, filename):\n        self.filename = filename\n    \n    def read(self):\n        return f\"Reading from {self.filename}\"\n\nclass WriteableFile(Readable, Writable):\n    def __init__(self, filename):\n        self.filename = filename\n    \n    def read(self):\n        return f\"Reading from {self.filename}\"\n    \n    def write(self, data):\n        return f\"Writing '{data}' to {self.filename}\"\n\nclass ExecutableFile(Readable, Executable):\n    def __init__(self, filename):\n        self.filename = filename\n    \n    def read(self):\n        return f\"Reading from {self.filename}\"\n    \n    def execute(self):\n        return f\"Executing {self.filename}\"\n\n# Demonstration\nfiles = [\n    ReadOnlyFile(\"document.txt\"),\n    WriteableFile(\"notes.txt\"), \n    ExecutableFile(\"script.py\")\n]\n\nprint(f\"\\nISP in action:\")\nfor file in files:\n    print(f\"{file.__class__.__name__}: {file.read()}\")\n    if isinstance(file, Writable):\n        print(f\"  Can write: {file.write('sample data')}\")\n    if isinstance(file, Executable):\n        print(f\"  Can execute: {file.execute()}\")\n\n# ===============================================================\n# 5. DEPENDENCY INVERSION PRINCIPLE (DIP)\n# ===============================================================\nprint(\"\\n\\nğŸ”¥ 5. DEPENDENCY INVERSION PRINCIPLE\")\nprint(\"High-level modules should not depend on low-level modules. Both should depend on abstractions.\")\n\n# âœ… GOOD EXAMPLE - Depend on abstractions\nclass NotificationService(ABC):\n    @abstractmethod\n    def send(self, message, recipient):\n        pass\n\nclass EmailNotification(NotificationService):\n    def send(self, message, recipient):\n        return f\"Email sent to {recipient}: {message}\"\n\nclass SMSNotification(NotificationService):\n    def send(self, message, recipient):\n        return f\"SMS sent to {recipient}: {message}\"\n\nclass SlackNotification(NotificationService):\n    def send(self, message, recipient):\n        return f\"Slack message sent to {recipient}: {message}\"\n\nclass OrderService:\n    \"\"\"High-level module depends on abstraction, not concrete implementations\"\"\"\n    def __init__(self, notification_service: NotificationService):\n        self.notification_service = notification_service\n    \n    def process_order(self, order_id, customer):\n        # Process order logic here...\n        message = f\"Order {order_id} has been processed successfully!\"\n        return self.notification_service.send(message, customer)\n\n# Demonstration\nprint(f\"\\nDIP in action:\")\n\n# Can easily switch notification methods without changing OrderService\nemail_service = EmailNotification()\nsms_service = SMSNotification()\nslack_service = SlackNotification()\n\norder_services = [\n    OrderService(email_service),\n    OrderService(sms_service),\n    OrderService(slack_service)\n]\n\nfor i, service in enumerate(order_services, 1):\n    result = service.process_order(f\"ORD-{i:03d}\", \"customer@example.com\")\n    print(f\"  {result}\")\n\n# ===============================================================\n# SOLID PRINCIPLES SUMMARY\n# ===============================================================\nprint(\"\\n\" + \"=\" * 60)\nprint(\"ğŸ† SOLID PRINCIPLES MASTERY SUMMARY\")\nprint(\"=\" * 60)\n\nprinciples = {\n    \"SRP\": \"One class, one responsibility - easier to maintain\",\n    \"OCP\": \"Extend behavior without modifying existing code\",\n    \"LSP\": \"Subclasses must be substitutable for their base classes\",\n    \"ISP\": \"Many specific interfaces better than one general interface\",\n    \"DIP\": \"Depend on abstractions, not concrete implementations\"\n}\n\nfor principle, description in principles.items():\n    print(f\"âœ… {principle}: {description}\")\n\nprint(\"\\nğŸ’¼ CAREER IMPACT:\")\nprint(\"ğŸ† Essential for senior developer interviews\")\nprint(\"ğŸ† Foundation for system architecture\")\nprint(\"ğŸ† Demonstrates clean code expertise\")\nprint(\"ğŸ† Required for technical leadership roles\")\nprint(\"ğŸ† Gateway to software architect positions\")\n\nprint(\"\\nğŸš€ INTERVIEW TIP: Always explain WHY you're applying each principle!\")\nprint(\"Show the problems they solve and the benefits they provide.\")\nprint(\"=\" * 60)\n```\n\n## Chapter 2: Gang of Four Design Patterns â­â­â­\n> **System Design Interview Essential** - Master the 23 patterns that define software engineering excellence\n\n### ğŸ¯ Pattern Categories:\n- **Creational**: Object creation mechanisms\n- **Structural**: Object composition and relationships  \n- **Behavioral**: Communication between objects\n\n### ğŸš€ Career Impact:\n- Required for all senior+ engineering interviews\n- Foundation for system architecture decisions\n- Gateway to principal engineer roles\n- Essential for designing scalable systems\n\n```python\n# DESIGN PATTERNS - SOFTWARE ENGINEERING MASTERY!\n\nprint(\"ğŸ¯ GANG OF FOUR DESIGN PATTERNS - INTERVIEW GOLD!\")\nprint(\"=\" * 70)\n\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Any\nfrom enum import Enum\n\n# ===============================================================\n# CREATIONAL PATTERNS - Object Creation Excellence\n# ===============================================================\n\n# 1. SINGLETON PATTERN - One instance to rule them all!\nprint(\"\\nğŸ”¥ 1. SINGLETON PATTERN\")\nprint(\"Ensure a class has only one instance and provide global access\")\n\nclass DatabaseConnection:\n    _instance = None\n    _is_initialized = False\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n    \n    def __init__(self):\n        if not DatabaseConnection._is_initialized:\n            self.connection_string = \"mysql://localhost:3306/app\"\n            self.is_connected = False\n            DatabaseConnection._is_initialized = True\n    \n    def connect(self):\n        if not self.is_connected:\n            print(f\"Connecting to {self.connection_string}\")\n            self.is_connected = True\n        return \"Connected\"\n    \n    def disconnect(self):\n        if self.is_connected:\n            print(\"Disconnecting from database\")\n            self.is_connected = False\n\n# Test Singleton\ndb1 = DatabaseConnection()\ndb2 = DatabaseConnection()\nprint(f\"Same instance? {db1 is db2}\")  # True\nprint(f\"Connection: {db1.connect()}\")\n\n# 2. FACTORY PATTERN - Create objects without specifying exact classes\nprint(\"\\n\\nğŸ”¥ 2. FACTORY PATTERN\")\nprint(\"Create objects without specifying their exact classes\")\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process_payment(self, amount: float) -> str:\n        pass\n\nclass CreditCardProcessor(PaymentProcessor):\n    def process_payment(self, amount: float) -> str:\n        return f\"Processing ${amount:.2f} via Credit Card\"\n\nclass PayPalProcessor(PaymentProcessor):\n    def process_payment(self, amount: float) -> str:\n        return f\"Processing ${amount:.2f} via PayPal\"\n\nclass CryptoProcessor(PaymentProcessor):\n    def process_payment(self, amount: float) -> str:\n        return f\"Processing ${amount:.2f} via Cryptocurrency\"\n\nclass PaymentFactory:\n    @staticmethod\n    def create_processor(payment_type: str) -> PaymentProcessor:\n        processors = {\n            \"credit_card\": CreditCardProcessor,\n            \"paypal\": PayPalProcessor,\n            \"crypto\": CryptoProcessor\n        }\n        \n        processor_class = processors.get(payment_type.lower())\n        if not processor_class:\n            raise ValueError(f\"Unknown payment type: {payment_type}\")\n        \n        return processor_class()\n\n# Test Factory\npayment_types = [\"credit_card\", \"paypal\", \"crypto\"]\nfor payment_type in payment_types:\n    processor = PaymentFactory.create_processor(payment_type)\n    result = processor.process_payment(100.0)\n    print(f\"  {result}\")\n\n# 3. BUILDER PATTERN - Construct complex objects step by step\nprint(\"\\n\\nğŸ”¥ 3. BUILDER PATTERN\")\nprint(\"Construct complex objects step by step\")\n\nclass Computer:\n    def __init__(self):\n        self.cpu = None\n        self.ram = None\n        self.storage = None\n        self.gpu = None\n        self.os = None\n    \n    def __str__(self):\n        specs = [\n            f\"CPU: {self.cpu}\",\n            f\"RAM: {self.ram}\",\n            f\"Storage: {self.storage}\",\n            f\"GPU: {self.gpu}\",\n            f\"OS: {self.os}\"\n        ]\n        return \"Computer Specs:\\n\" + \"\\n\".join(f\"  {spec}\" for spec in specs)\n\nclass ComputerBuilder:\n    def __init__(self):\n        self.computer = Computer()\n    \n    def set_cpu(self, cpu: str):\n        self.computer.cpu = cpu\n        return self\n    \n    def set_ram(self, ram: str):\n        self.computer.ram = ram\n        return self\n    \n    def set_storage(self, storage: str):\n        self.computer.storage = storage\n        return self\n    \n    def set_gpu(self, gpu: str):\n        self.computer.gpu = gpu\n        return self\n    \n    def set_os(self, os: str):\n        self.computer.os = os\n        return self\n    \n    def build(self) -> Computer:\n        return self.computer\n\n# Test Builder\ngaming_pc = (ComputerBuilder()\n    .set_cpu(\"Intel i9-13900K\")\n    .set_ram(\"32GB DDR5\")\n    .set_storage(\"2TB NVMe SSD\")\n    .set_gpu(\"RTX 4080\")\n    .set_os(\"Windows 11\")\n    .build())\n\nprint(gaming_pc)\n\n# ===============================================================\n# STRUCTURAL PATTERNS - Object Composition Excellence\n# ===============================================================\n\n# 4. ADAPTER PATTERN - Make incompatible interfaces work together\nprint(\"\\n\\nğŸ”¥ 4. ADAPTER PATTERN\")\nprint(\"Allow incompatible interfaces to work together\")\n\nclass OldPrinter:\n    def old_print(self, text: str):\n        return f\"[OLD PRINTER] {text}\"\n\nclass ModernPrinter:\n    def print(self, text: str):\n        return f\"[MODERN PRINTER] {text}\"\n\nclass PrinterAdapter:\n    def __init__(self, old_printer: OldPrinter):\n        self.old_printer = old_printer\n    \n    def print(self, text: str):\n        return self.old_printer.old_print(text)\n\n# Test Adapter\nold_printer = OldPrinter()\nadapted_printer = PrinterAdapter(old_printer)\nmodern_printer = ModernPrinter()\n\nprinters = [adapted_printer, modern_printer]\nfor i, printer in enumerate(printers, 1):\n    result = printer.print(f\"Document {i}\")\n    print(f\"  {result}\")\n\n# 5. DECORATOR PATTERN - Add behavior to objects dynamically\nprint(\"\\n\\nğŸ”¥ 5. DECORATOR PATTERN\")\nprint(\"Add new functionality to objects without altering their structure\")\n\nclass Coffee(ABC):\n    @abstractmethod\n    def cost(self) -> float:\n        pass\n    \n    @abstractmethod\n    def description(self) -> str:\n        pass\n\nclass SimpleCoffee(Coffee):\n    def cost(self) -> float:\n        return 2.0\n    \n    def description(self) -> str:\n        return \"Simple coffee\"\n\nclass CoffeeDecorator(Coffee):\n    def __init__(self, coffee: Coffee):\n        self._coffee = coffee\n\nclass MilkDecorator(CoffeeDecorator):\n    def cost(self) -> float:\n        return self._coffee.cost() + 0.5\n    \n    def description(self) -> str:\n        return self._coffee.description() + \", milk\"\n\nclass SugarDecorator(CoffeeDecorator):\n    def cost(self) -> float:\n        return self._coffee.cost() + 0.2\n    \n    def description(self) -> str:\n        return self._coffee.description() + \", sugar\"\n\nclass WhipDecorator(CoffeeDecorator):\n    def cost(self) -> float:\n        return self._coffee.cost() + 0.7\n    \n    def description(self) -> str:\n        return self._coffee.description() + \", whipped cream\"\n\n# Test Decorator\ncoffee = SimpleCoffee()\ncoffee = MilkDecorator(coffee)\ncoffee = SugarDecorator(coffee)\ncoffee = WhipDecorator(coffee)\n\nprint(f\"  Order: {coffee.description()}\")\nprint(f\"  Total cost: ${coffee.cost():.2f}\")\n\n# ===============================================================\n# BEHAVIORAL PATTERNS - Object Communication Excellence\n# ===============================================================\n\n# 6. OBSERVER PATTERN - Define one-to-many dependency between objects\nprint(\"\\n\\nğŸ”¥ 6. OBSERVER PATTERN\")\nprint(\"Define a one-to-many dependency between objects\")\n\nclass Subject:\n    def __init__(self):\n        self._observers: List['Observer'] = []\n        self._state = None\n    \n    def attach(self, observer: 'Observer'):\n        self._observers.append(observer)\n    \n    def detach(self, observer: 'Observer'):\n        self._observers.remove(observer)\n    \n    def notify(self):\n        for observer in self._observers:\n            observer.update(self)\n    \n    def set_state(self, state):\n        self._state = state\n        self.notify()\n    \n    def get_state(self):\n        return self._state\n\nclass Observer(ABC):\n    @abstractmethod\n    def update(self, subject: Subject):\n        pass\n\nclass EmailNotifier(Observer):\n    def update(self, subject: Subject):\n        print(f\"  ğŸ“§ Email: Stock price changed to ${subject.get_state()}\")\n\nclass SMSNotifier(Observer):\n    def update(self, subject: Subject):\n        print(f\"  ğŸ“± SMS: Stock price updated to ${subject.get_state()}\")\n\nclass AppNotifier(Observer):\n    def update(self, subject: Subject):\n        print(f\"  ğŸ“² App: Push notification - Price is now ${subject.get_state()}\")\n\n# Test Observer\nstock = Subject()\nemail_notifier = EmailNotifier()\nsms_notifier = SMSNotifier()\napp_notifier = AppNotifier()\n\nstock.attach(email_notifier)\nstock.attach(sms_notifier)\nstock.attach(app_notifier)\n\nprint(\"  Stock price updates:\")\nstock.set_state(150.00)\nstock.set_state(155.50)\n\n# 7. STRATEGY PATTERN - Define family of algorithms\nprint(\"\\n\\nğŸ”¥ 7. STRATEGY PATTERN\")\nprint(\"Define a family of algorithms and make them interchangeable\")\n\nclass SortStrategy(ABC):\n    @abstractmethod\n    def sort(self, data: List[int]) -> List[int]:\n        pass\n\nclass BubbleSort(SortStrategy):\n    def sort(self, data: List[int]) -> List[int]:\n        arr = data.copy()\n        n = len(arr)\n        for i in range(n):\n            for j in range(0, n - i - 1):\n                if arr[j] > arr[j + 1]:\n                    arr[j], arr[j + 1] = arr[j + 1], arr[j]\n        return arr\n\nclass QuickSort(SortStrategy):\n    def sort(self, data: List[int]) -> List[int]:\n        arr = data.copy()\n        self._quick_sort(arr, 0, len(arr) - 1)\n        return arr\n    \n    def _quick_sort(self, arr, low, high):\n        if low < high:\n            pi = self._partition(arr, low, high)\n            self._quick_sort(arr, low, pi - 1)\n            self._quick_sort(arr, pi + 1, high)\n    \n    def _partition(self, arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\nclass SortContext:\n    def __init__(self, strategy: SortStrategy):\n        self._strategy = strategy\n    \n    def set_strategy(self, strategy: SortStrategy):\n        self._strategy = strategy\n    \n    def sort(self, data: List[int]) -> List[int]:\n        return self._strategy.sort(data)\n\n# Test Strategy\ndata = [64, 34, 25, 12, 22, 11, 90]\nprint(f\"  Original data: {data}\")\n\ncontext = SortContext(BubbleSort())\nresult1 = context.sort(data)\nprint(f\"  Bubble sort: {result1}\")\n\ncontext.set_strategy(QuickSort())\nresult2 = context.sort(data)\nprint(f\"  Quick sort: {result2}\")\n\n# 8. COMMAND PATTERN - Encapsulate requests as objects\nprint(\"\\n\\nğŸ”¥ 8. COMMAND PATTERN\")\nprint(\"Encapsulate a request as an object\")\n\nclass Command(ABC):\n    @abstractmethod\n    def execute(self):\n        pass\n    \n    @abstractmethod\n    def undo(self):\n        pass\n\nclass Light:\n    def __init__(self, location: str):\n        self.location = location\n        self.is_on = False\n    \n    def turn_on(self):\n        self.is_on = True\n        return f\"{self.location} light is ON\"\n    \n    def turn_off(self):\n        self.is_on = False\n        return f\"{self.location} light is OFF\"\n\nclass LightOnCommand(Command):\n    def __init__(self, light: Light):\n        self.light = light\n    \n    def execute(self):\n        return self.light.turn_on()\n    \n    def undo(self):\n        return self.light.turn_off()\n\nclass LightOffCommand(Command):\n    def __init__(self, light: Light):\n        self.light = light\n    \n    def execute(self):\n        return self.light.turn_off()\n    \n    def undo(self):\n        return self.light.turn_on()\n\nclass RemoteControl:\n    def __init__(self):\n        self.commands: List[Command] = []\n        self.last_command: Command = None\n    \n    def set_command(self, command: Command):\n        self.commands.append(command)\n    \n    def press_button(self, slot: int):\n        if 0 <= slot < len(self.commands):\n            self.last_command = self.commands[slot]\n            return self.last_command.execute()\n        return \"Invalid slot\"\n    \n    def press_undo(self):\n        if self.last_command:\n            return self.last_command.undo()\n        return \"No command to undo\"\n\n# Test Command\nliving_room_light = Light(\"Living Room\")\nkitchen_light = Light(\"Kitchen\")\n\nlight_on_cmd = LightOnCommand(living_room_light)\nlight_off_cmd = LightOffCommand(living_room_light)\n\nremote = RemoteControl()\nremote.set_command(light_on_cmd)\nremote.set_command(light_off_cmd)\n\nprint(f\"  {remote.press_button(0)}\")  # Turn on\nprint(f\"  {remote.press_button(1)}\")  # Turn off\nprint(f\"  {remote.press_undo()}\")     # Undo (turn on)\n\n# ===============================================================\n# DESIGN PATTERNS SUMMARY\n# ===============================================================\nprint(\"\\n\" + \"=\" * 70)\nprint(\"ğŸ† DESIGN PATTERNS MASTERY SUMMARY\")\nprint(\"=\" * 70)\n\npattern_benefits = {\n    \"Singleton\": \"Global access point, controlled instantiation\",\n    \"Factory\": \"Loose coupling, easy to extend new types\",\n    \"Builder\": \"Complex object construction, readable code\",\n    \"Adapter\": \"Legacy system integration, interface compatibility\",\n    \"Decorator\": \"Dynamic behavior addition, composition over inheritance\",\n    \"Observer\": \"Loose coupling, event-driven architecture\",\n    \"Strategy\": \"Algorithm interchangeability, runtime behavior change\",\n    \"Command\": \"Request queuing, undo/redo functionality\"\n}\n\nprint(\"\\nğŸ“š PATTERNS IMPLEMENTED:\")\nfor pattern, benefit in pattern_benefits.items():\n    print(f\"âœ… {pattern}: {benefit}\")\n\nprint(\"\\nğŸ’¼ CAREER IMPACT:\")\nprint(\"ğŸ† Senior engineer interview essential\")\nprint(\"ğŸ† System design foundation knowledge\")\nprint(\"ğŸ† Code review and architecture discussions\")\nprint(\"ğŸ† Team leadership and mentoring ability\")\nprint(\"ğŸ† Path to software architect role\")\n\nprint(\"\\nğŸš€ INTERVIEW TIP: Always explain the PROBLEM each pattern solves!\")\nprint(\"Show real-world scenarios where you'd use each pattern.\")\nprint(\"Demonstrate understanding of trade-offs and alternatives.\")\nprint(\"=\" * 70)\n```\n\n"}