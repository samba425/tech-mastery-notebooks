{"id":"javascript-guide","title":"âš¡ JavaScript Complete Guide","content":"# ðŸŸ¨ JavaScript Complete Mastery Guide\n\n> **Complete JavaScript Reference for Interview Preparation and Modern Development**  \n> From Beginner to Expert Level - All Concepts Covered\n\n---\n\n## ðŸ“š Table of Contents\n\n### Core JavaScript\n1. [JavaScript Fundamentals](#1-javascript-fundamentals)\n2. [Data Types and Variables](#2-data-types-and-variables)\n3. [Functions](#3-functions)\n4. [Objects and Arrays](#4-objects-and-arrays)\n5. [ES6+ Modern Features](#5-es6-modern-features)\n6. [Asynchronous JavaScript](#6-asynchronous-javascript)\n7. [DOM Manipulation](#7-dom-manipulation)\n8. [Object-Oriented Programming](#8-object-oriented-programming)\n9. [Functional Programming](#9-functional-programming)\n10. [Error Handling](#10-error-handling)\n\n### Backend & Testing\n11. [Node.js Backend Development](#11-nodejs-backend-development)\n12. [Testing Frameworks](#12-testing-frameworks)\n\n### Advanced Topics\n13. [Advanced Concepts](#13-advanced-concepts)\n14. [Performance Optimization](#14-performance-optimization)\n15. [Modern JavaScript Ecosystem](#15-modern-javascript-ecosystem)\n\n### Interview-Critical Topics â­\n16. [âš›ï¸ React Framework](#16-ï¸-react-framework-essential-for-interviews)\n17. [ï¿½ï¸ Angular Framework](#17-ï¸-angular-framework)\n18. [ï¿½ðŸŽ¨ Design Patterns](#18--design-patterns-in-javascript)\n19. [ðŸ”’ Security Best Practices](#19--security-best-practices)\n20. [ðŸ”Œ WebSockets & Real-time Communication](#20--websockets--real-time-communication)\n\n---\n\n## 1. JavaScript Fundamentals\n\n**JavaScript is a dynamic, weakly-typed programming language that runs in browsers and on servers (Node.js).** Understanding variables, data types, and type coercion is fundamental to writing effective JavaScript code. JavaScript uses hoisting, which moves declarations to the top of their scope during compilation.\n\n### Variables and Declarations\n\n```javascript\n// Variable declarations\nvar oldStyle = \"function-scoped variable\";\nlet modernBlock = \"block-scoped variable\";\nconst constant = \"immutable reference\";\n\n// Hoisting behavior\nconsole.log(hoistedVar); // undefined (not error)\nvar hoistedVar = \"I'm hoisted!\";\n\n// let and const are not hoisted\n// console.log(notHoisted); // ReferenceError\nlet notHoisted = \"Modern variable\";\n```\n\n### Data Types\n\n```javascript\n// Primitive types\nconst number = 42;\nconst string = \"Hello, JavaScript!\";\nconst boolean = true;\nconst undefinedValue = undefined;\nconst nullValue = null;\nconst symbol = Symbol('unique');\nconst bigint = BigInt(9007199254740991);\n\n// Type checking - typeof operator returns string type\nconsole.log(typeof number);    // \"number\"\nconsole.log(typeof string);    // \"string\"\nconsole.log(typeof boolean);   // \"boolean\"\nconsole.log(typeof undefinedValue); // \"undefined\"\nconsole.log(typeof nullValue); // \"object\" (historical quirk - bug in JS)\nconsole.log(typeof symbol);    // \"symbol\"\nconsole.log(typeof bigint);    // \"bigint\"\n\n// Reference types\nconst object = { name: \"Alice\", age: 30 };\nconst array = [1, 2, 3, 4, 5];\nconst func = function() { return \"I'm a function!\"; };\n\nconsole.log(Array.isArray(array)); // true\nconsole.log(object instanceof Object); // true\n```\n\n### Type Coercion\n\n```javascript\n// Automatic type conversion\nconsole.log(\"5\" + 3);      // \"53\" (string concatenation)\nconsole.log(\"5\" - 3);      // 2 (numeric subtraction)\nconsole.log(\"5\" * \"2\");    // 10 (numeric multiplication)\nconsole.log(true + 1);     // 2 (boolean to number)\n\n// Explicit conversion\nconst str = String(123);        // \"123\"\nconst num = Number(\"456\");      // 456\nconst bool = Boolean(1);        // true\n\n// Falsy values\nconsole.log(Boolean(0));        // false\nconsole.log(Boolean(\"\"));       // false\nconsole.log(Boolean(null));     // false\nconsole.log(Boolean(undefined)); // false\nconsole.log(Boolean(NaN));      // false\n```\n\n---\n\n## 2. Data Types and Variables\n\n**JavaScript has 7 primitive types (string, number, bigint, boolean, undefined, null, symbol) and reference types (objects, arrays, functions).** Primitives are immutable and passed by value, while objects are passed by reference. Understanding the difference is crucial for avoiding bugs and memory issues.\n\n### Strings\n\n```javascript\n// String creation\nconst singleQuotes = 'Hello, World!';\nconst doubleQuotes = \"Hello, JavaScript!\";\nconst templateLiteral = `Hello, ${name}!`;\n\n// String methods - powerful built-in operations\nconst text = \"JavaScript Programming\";\nconsole.log(text.length);              // 21 (number of characters)\nconsole.log(text.toUpperCase());       // \"JAVASCRIPT PROGRAMMING\"\nconsole.log(text.toLowerCase());       // \"javascript programming\"\nconsole.log(text.slice(0, 10));       // \"JavaScript\" (extract substring)\nconsole.log(text.substring(0, 10));    // \"JavaScript\" (similar to slice)\nconsole.log(text.indexOf(\"Script\"));   // 4 (position of substring)\nconsole.log(text.includes(\"Program\")); // true (checks if contains)\nconsole.log(text.split(\" \"));          // [\"JavaScript\", \"Programming\"] (array)\n\n// Template literals\nconst name = \"Alice\";\nconst age = 30;\nconst message = `Hello, my name is ${name} and I'm ${age} years old.`;\n\n// Multi-line strings\nconst multiLine = `\n    This is a\n    multi-line\n    string\n`;\n```\n\n### Numbers\n\n```javascript\n// Number operations\nconst integer = 42;\nconst float = 3.14159;\nconst exponential = 2.5e6; // 2500000\n\n// Math object\nconsole.log(Math.PI);           // 3.141592653589793\nconsole.log(Math.round(4.7));   // 5\nconsole.log(Math.ceil(4.1));    // 5\nconsole.log(Math.floor(4.9));   // 4\nconsole.log(Math.max(1, 5, 3)); // 5\nconsole.log(Math.min(1, 5, 3)); // 1\nconsole.log(Math.random());     // Random number 0-1\n\n// Number methods\nconst num = 123.456;\nconsole.log(num.toFixed(2));     // \"123.46\"\nconsole.log(num.toPrecision(4)); // \"123.5\"\nconsole.log(parseInt(\"123px\"));  // 123\nconsole.log(parseFloat(\"123.45px\")); // 123.45\n\n// Number validation\nconsole.log(Number.isNaN(NaN));      // true\nconsole.log(Number.isFinite(123));   // true\nconsole.log(Number.isInteger(123));  // true\n```\n\n---\n\n## 3. Functions\n\n**Functions are first-class citizens in JavaScript, meaning they can be assigned to variables, passed as arguments, and returned from other functions.** JavaScript supports multiple function syntaxes including declarations, expressions, and arrow functions. Understanding function scope, closures, and the 'this' keyword is essential for mastering JavaScript.\n\n### Function Declarations and Expressions\n\n```javascript\n// Function declaration\nfunction greet(name) {\n    return `Hello, ${name}!`;\n}\n\n// Function expression\nconst greetExpression = function(name) {\n    return `Hello, ${name}!`;\n};\n\n// Arrow function (ES6+)\nconst greetArrow = (name) => `Hello, ${name}!`;\nconst greetArrowBlock = (name) => {\n    return `Hello, ${name}!`;\n};\n\n// Single parameter (parentheses optional)\nconst square = x => x * x;\n\n// No parameters\nconst random = () => Math.random();\n```\n\n### Function Parameters\n\n```javascript\n// Default parameters\nfunction greet(name = \"World\", greeting = \"Hello\") {\n    return `${greeting}, ${name}!`;\n}\n\n// Rest parameters\nfunction sum(...numbers) {\n    return numbers.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum(1, 2, 3, 4, 5)); // 15\n\n// Destructuring parameters\nfunction createUser({name, age, email}) {\n    return {\n        id: Date.now(),\n        name,\n        age,\n        email,\n        created: new Date()\n    };\n}\n\nconst userData = {name: \"Alice\", age: 30, email: \"alice@example.com\"};\nconst user = createUser(userData);\n```\n\n### Higher-Order Functions\n\n```javascript\n// Function that takes another function as parameter\nfunction applyOperation(numbers, operation) {\n    return numbers.map(operation);\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nconst squared = applyOperation(numbers, x => x * x);\nconst doubled = applyOperation(numbers, x => x * 2);\n\n// Function that returns a function\nfunction createMultiplier(factor) {\n    return function(number) {\n        return number * factor;\n    };\n}\n\nconst double = createMultiplier(2);  // Returns function that multiplies by 2\nconst triple = createMultiplier(3);  // Returns function that multiplies by 3\n\nconsole.log(double(5)); // 10 (5 * 2)\nconsole.log(triple(5)); // 15 (5 * 3)\n\n// Currying\nconst curry = (fn) => {\n    return function curried(...args) {\n        if (args.length >= fn.length) {\n            return fn.apply(this, args);\n        } else {\n            return function(...args2) {\n                return curried.apply(this, args.concat(args2));\n            };\n        }\n    };\n};\n\nconst add = (a, b, c) => a + b + c;\nconst curriedAdd = curry(add);\nconsole.log(curriedAdd(1)(2)(3)); // 6\n```\n\n---\n\n## 4. Objects and Arrays\n\n**Objects are key-value collections and the foundation of JavaScript's data structures, while arrays are ordered lists with powerful iteration methods.** Objects use prototypal inheritance, and arrays come with rich built-in methods like map, filter, and reduce. Destructuring and spread operators provide modern syntax for working with these structures efficiently.\n\n### Objects\n\n```javascript\n// Object creation\nconst person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"New York\",\n    greet: function() {\n        return `Hello, I'm ${this.name}`;\n    }\n};\n\n// Accessing properties\nconsole.log(person.name);        // \"Alice\"\nconsole.log(person[\"age\"]);      // 30\n\n// Adding/modifying properties\nperson.email = \"alice@example.com\";\nperson.age = 31;\n\n// Object methods\nconst keys = Object.keys(person);\nconst values = Object.values(person);\nconst entries = Object.entries(person);\n\n// Object destructuring\nconst {name, age, city} = person;\nconst {name: personName, age: personAge} = person; // Rename variables\n\n// Nested destructuring\nconst user = {\n    id: 1,\n    profile: {\n        name: \"Alice\",\n        preferences: {\n            theme: \"dark\",\n            language: \"en\"\n        }\n    }\n};\n\nconst {profile: {name: userName, preferences: {theme}}} = user;\n```\n\n### Arrays\n\n```javascript\n// Array creation\nconst fruits = [\"apple\", \"banana\", \"cherry\"];\nconst numbers = [1, 2, 3, 4, 5];\nconst mixed = [1, \"hello\", true, {name: \"Alice\"}];\n\n// Array methods\nfruits.push(\"date\");           // Add to end\nfruits.unshift(\"avocado\");     // Add to beginning\nconst last = fruits.pop();     // Remove from end\nconst first = fruits.shift();  // Remove from beginning\n\n// Array iteration\nfruits.forEach((fruit, index) => {\n    console.log(`${index}: ${fruit}`);\n});\n\n// Array transformation - map/filter/reduce are essential\nconst doubled = numbers.map(n => n * 2);  // [2, 4, 6, 8, 10]\nconst evens = numbers.filter(n => n % 2 === 0);  // [2, 4]\nconst sum = numbers.reduce((total, n) => total + n, 0);  // 15\n\n// Array searching\nconst foundFruit = fruits.find(fruit => fruit.startsWith('a'));\nconst fruitIndex = fruits.findIndex(fruit => fruit === 'banana');\nconst hasApple = fruits.includes('apple');\n\n// Array destructuring\nconst [firstFruit, secondFruit, ...restFruits] = fruits;\n\n// Spread operator with arrays\nconst moreFruits = [\"grape\", \"orange\"];\nconst allFruits = [...fruits, ...moreFruits];\n```\n\n### Advanced Array Methods\n\n```javascript\n// Sorting\nconst words = [\"banana\", \"apple\", \"cherry\"];\nwords.sort(); // Alphabetical sort\n\nconst nums = [3, 1, 4, 1, 5, 9];\nnums.sort((a, b) => a - b); // Numerical sort ascending\nnums.sort((a, b) => b - a); // Numerical sort descending\n\n// Flattening\nconst nested = [[1, 2], [3, 4], [5, 6]];\nconst flattened = nested.flat();          // [1, 2, 3, 4, 5, 6]\nconst deepNested = [1, [2, [3, [4]]]];\nconst deepFlattened = deepNested.flat(3); // [1, 2, 3, 4]\n\n// Array.from and Array.of\nconst arrayFromString = Array.from(\"hello\"); // ['h', 'e', 'l', 'l', 'o']\nconst arrayFromRange = Array.from({length: 5}, (_, i) => i); // [0, 1, 2, 3, 4]\nconst arrayOf = Array.of(1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]\n```\n\n---\n\n## 5. ES6+ Modern Features\n\n**ES6 (ECMAScript 2015) and beyond introduced major improvements to JavaScript including let/const, arrow functions, classes, modules, and async/await.** These features make JavaScript more expressive, readable, and powerful. Modern JavaScript development relies heavily on these enhancements, making code cleaner and more maintainable.\n\n### Let, Const, and Block Scope\n\n```javascript\n// Block scope with let and const\n{\n    let blockScoped = \"I'm block scoped\";\n    const alsoBlockScoped = \"Me too\";\n    var functionScoped = \"I'm function scoped\";\n}\n\n// console.log(blockScoped); // ReferenceError\n// console.log(alsoBlockScoped); // ReferenceError\nconsole.log(functionScoped); // \"I'm function scoped\"\n\n// Temporal dead zone\n// console.log(temporalDeadZone); // ReferenceError\nlet temporalDeadZone = \"Now I exist\";\n```\n\n### Destructuring Assignment\n\n```javascript\n// Array destructuring\nconst colors = [\"red\", \"green\", \"blue\"];\nconst [primary, secondary, tertiary] = colors;\nconst [first, , third] = colors; // Skip middle element\nconst [head, ...tail] = colors;  // Rest elements\n\n// Object destructuring\nconst person = {name: \"Alice\", age: 30, city: \"NYC\"};\nconst {name, age} = person;\nconst {name: personName} = person; // Rename\nconst {country = \"USA\"} = person;  // Default value\n\n// Function parameter destructuring\nfunction displayUser({name, age, email = \"No email\"}) {\n    console.log(`${name}, ${age}, ${email}`);\n}\n\ndisplayUser({name: \"Bob\", age: 25});\n```\n\n### Template Literals\n\n```javascript\n// Basic template literals\nconst name = \"Alice\";\nconst greeting = `Hello, ${name}!`;\n\n// Multi-line strings\nconst html = `\n    <div>\n        <h1>${name}'s Profile</h1>\n        <p>Welcome to your dashboard</p>\n    </div>\n`;\n\n// Expression in template literals\nconst a = 5;\nconst b = 10;\nconst result = `The sum of ${a} and ${b} is ${a + b}`;\n\n// Tagged template literals\nfunction highlight(strings, ...values) {\n    return strings.reduce((result, string, i) => {\n        const value = values[i] ? `<mark>${values[i]}</mark>` : '';\n        return result + string + value;\n    }, '');\n}\n\nconst highlighted = highlight`Hello ${name}, you have ${5} messages`;\n```\n\n### Arrow Functions\n\n```javascript\n// Traditional function\nfunction traditional(x) {\n    return x * 2;\n}\n\n// Arrow function\nconst arrow = x => x * 2;\n\n// Multiple parameters\nconst add = (a, b) => a + b;\n\n// Block body\nconst complexOperation = (x, y) => {\n    const temp = x * 2;\n    const result = temp + y;\n    return result;\n};\n\n// Arrow functions and 'this' context\nconst object = {\n    name: \"Alice\",\n    traditional: function() {\n        return this.name; // 'this' refers to object\n    },\n    arrow: () => {\n        return this.name; // 'this' refers to global/window\n    }\n};\n```\n\n### Spread and Rest Operators\n\n```javascript\n// Spread with arrays\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]\n\n// Spread with objects\nconst obj1 = {a: 1, b: 2};\nconst obj2 = {c: 3, d: 4};\nconst merged = {...obj1, ...obj2}; // {a: 1, b: 2, c: 3, d: 4}\n\n// Rest parameters\nfunction sum(...numbers) {\n    return numbers.reduce((total, num) => total + num, 0);\n}\n\n// Rest in destructuring\nconst [first, second, ...rest] = [1, 2, 3, 4, 5];\nconst {name, ...otherProps} = {name: \"Alice\", age: 30, city: \"NYC\"};\n```\n\n---\n\n## 6. Asynchronous JavaScript\n\n**JavaScript is single-threaded but handles asynchronous operations through the event loop, callbacks, promises, and async/await.** Async programming is essential for handling API calls, file operations, and timers without blocking the main thread. Modern async/await syntax makes asynchronous code look and behave like synchronous code, improving readability.\n\n### Callbacks\n\n```javascript\n// Basic callback\nfunction fetchData(callback) {\n    setTimeout(() => {\n        const data = {id: 1, name: \"Alice\"};\n        callback(data);\n    }, 1000);\n}\n\nfetchData((data) => {\n    console.log(\"Received data:\", data);\n});\n\n// Callback hell example\ngetData(function(a) {\n    getMoreData(a, function(b) {\n        getEvenMoreData(b, function(c) {\n            getYetMoreData(c, function(d) {\n                // This is callback hell!\n            });\n        });\n    });\n});\n```\n\n### Promises\n\n```javascript\n// Creating a Promise\nconst fetchUserData = (userId) => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (userId > 0) {\n                resolve({id: userId, name: `User ${userId}`});\n            } else {\n                reject(new Error(\"Invalid user ID\"));\n            }\n        }, 1000);\n    });\n};\n\n// Using Promises\nfetchUserData(1)\n    .then(user => {\n        console.log(\"User:\", user);\n        return fetchUserData(2); // Chain another Promise\n    })\n    .then(anotherUser => {\n        console.log(\"Another user:\", anotherUser);\n    })\n    .catch(error => {\n        console.error(\"Error:\", error.message);\n    })\n    .finally(() => {\n        console.log(\"Operation completed\");\n    });\n\n// Promise.all - Wait for all promises\nconst promises = [\n    fetchUserData(1),\n    fetchUserData(2),\n    fetchUserData(3)\n];\n\nPromise.all(promises)\n    .then(users => {\n        console.log(\"All users:\", users);\n    })\n    .catch(error => {\n        console.error(\"One or more promises failed:\", error);\n    });\n\n// Promise.race - First promise to complete\nPromise.race(promises)\n    .then(firstUser => {\n        console.log(\"First user:\", firstUser);\n    });\n```\n\n### Async/Await\n\n```javascript\n// Async function declaration\nasync function fetchUser(userId) {\n    try {\n        const user = await fetchUserData(userId);\n        console.log(\"User:\", user);\n        return user;\n    } catch (error) {\n        console.error(\"Error fetching user:\", error.message);\n        throw error;\n    }\n}\n\n// Async arrow function\nconst fetchUserArrow = async (userId) => {\n    const user = await fetchUserData(userId);\n    return user;\n};\n\n// Using async/await with multiple operations\nasync function fetchMultipleUsers() {\n    try {\n        // Sequential execution\n        const user1 = await fetchUserData(1);\n        const user2 = await fetchUserData(2);\n        \n        // Parallel execution\n        const [user3, user4] = await Promise.all([\n            fetchUserData(3),\n            fetchUserData(4)\n        ]);\n        \n        return [user1, user2, user3, user4];\n    } catch (error) {\n        console.error(\"Error:\", error);\n    }\n}\n\n// Error handling with async/await\nasync function handleErrors() {\n    try {\n        await fetchUserData(-1); // This will throw an error\n    } catch (error) {\n        console.error(\"Caught error:\", error.message);\n    }\n}\n```\n\n---\n\n## 7. DOM Manipulation\n\n**The Document Object Model (DOM) is a tree-like representation of HTML that JavaScript can interact with to dynamically modify web pages.** DOM manipulation involves selecting elements, modifying content/styles, handling events, and creating/removing elements. Understanding event propagation (bubbling and capturing) and event delegation is crucial for building interactive web applications.\n\n### Selecting Elements\n\n```javascript\n// Single element selection\nconst elementById = document.getElementById('myId');\nconst elementByClass = document.querySelector('.myClass');\nconst elementByTag = document.querySelector('div');\n\n// Multiple element selection\nconst elementsByClass = document.querySelectorAll('.myClass');\nconst elementsByTag = document.getElementsByTagName('div');\n\n// Traversing the DOM\nconst parent = element.parentNode;\nconst children = element.children;\nconst siblings = element.nextElementSibling;\nconst firstChild = element.firstElementChild;\n```\n\n### Modifying Elements\n\n```javascript\n// Content manipulation\nelement.textContent = \"New text content\";\nelement.innerHTML = \"<strong>New HTML content</strong>\";\n\n// Attribute manipulation\nelement.setAttribute('data-id', '123');\nconst dataId = element.getAttribute('data-id');\nelement.removeAttribute('data-id');\n\n// Class manipulation\nelement.classList.add('new-class');\nelement.classList.remove('old-class');\nelement.classList.toggle('active');\nelement.classList.contains('existing-class');\n\n// Style manipulation\nelement.style.color = 'red';\nelement.style.backgroundColor = 'blue';\nelement.style.fontSize = '16px';\n```\n\n### Creating and Removing Elements\n\n```javascript\n// Creating elements\nconst newDiv = document.createElement('div');\nnewDiv.textContent = 'Hello, World!';\nnewDiv.className = 'greeting';\n\n// Appending elements\ndocument.body.appendChild(newDiv);\nparentElement.insertBefore(newDiv, existingChild);\n\n// Removing elements\nelement.remove(); // Modern way\nparentElement.removeChild(element); // Older way\n\n// Replacing elements\nparentElement.replaceChild(newElement, oldElement);\n```\n\n### Event Handling\n\n```javascript\n// Adding event listeners\nbutton.addEventListener('click', function(event) {\n    console.log('Button clicked!');\n    event.preventDefault(); // Prevent default behavior\n    event.stopPropagation(); // Stop event bubbling\n});\n\n// Arrow function event handler\nbutton.addEventListener('click', (event) => {\n    console.log('Button clicked with arrow function!');\n});\n\n// Event delegation\ndocument.addEventListener('click', function(event) {\n    if (event.target.matches('.dynamic-button')) {\n        console.log('Dynamic button clicked!');\n    }\n});\n\n// Removing event listeners\nfunction handleClick(event) {\n    console.log('Handled click');\n}\n\nbutton.addEventListener('click', handleClick);\nbutton.removeEventListener('click', handleClick);\n\n// Common events\nelement.addEventListener('mouseover', handleMouseOver);\nelement.addEventListener('mouseout', handleMouseOut);\nform.addEventListener('submit', handleFormSubmit);\ninput.addEventListener('input', handleInputChange);\nwindow.addEventListener('resize', handleWindowResize);\n```\n\n---\n\n## 8. Object-Oriented Programming\n\n**JavaScript uses prototypal inheritance but ES6 added class syntax for cleaner OOP code.** Classes support constructors, instance/static methods, getters/setters, and inheritance through extends. Understanding SOLID principles helps create maintainable, scalable object-oriented JavaScript applications.\n\n### ES6 Classes\n\n```javascript\n// Basic class\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Instance method\n    greet() {\n        return `Hello, I'm ${this.name} and I'm ${this.age} years old.`;\n    }\n    \n    // Static method\n    static getSpecies() {\n        return \"Homo sapiens\";\n    }\n    \n    // Getter\n    get info() {\n        return `${this.name} (${this.age})`;\n    }\n    \n    // Setter\n    set age(newAge) {\n        if (newAge >= 0) {\n            this._age = newAge;\n        }\n    }\n}\n\n// Creating instances\nconst person1 = new Person(\"Alice\", 30);\nconst person2 = new Person(\"Bob\", 25);\n\nconsole.log(person1.greet());\nconsole.log(Person.getSpecies());\n```\n\n### Inheritance\n\n```javascript\n// Base class\nclass Animal {\n    constructor(name, species) {\n        this.name = name;\n        this.species = species;\n    }\n    \n    speak() {\n        return `${this.name} makes a sound`;\n    }\n    \n    getInfo() {\n        return `${this.name} is a ${this.species}`;\n    }\n}\n\n// Derived class\nclass Dog extends Animal {\n    constructor(name, breed) {\n        super(name, \"Dog\"); // Call parent constructor\n        this.breed = breed;\n    }\n    \n    // Override parent method\n    speak() {\n        return `${this.name} barks loudly!`;\n    }\n    \n    // New method specific to Dog\n    fetch() {\n        return `${this.name} fetches the ball!`;\n    }\n    \n    // Call parent method\n    getInfo() {\n        return `${super.getInfo()} of breed ${this.breed}`;\n    }\n}\n\nconst dog = new Dog(\"Buddy\", \"Golden Retriever\");\nconsole.log(dog.speak());   // \"Buddy barks loudly!\"\nconsole.log(dog.fetch());   // \"Buddy fetches the ball!\"\nconsole.log(dog.getInfo()); // \"Buddy is a Dog of breed Golden Retriever\"\n```\n\n### Prototypes (Pre-ES6)\n\n```javascript\n// Constructor function\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\n// Adding methods to prototype\nPerson.prototype.greet = function() {\n    return `Hello, I'm ${this.name}`;\n};\n\nPerson.prototype.haveBirthday = function() {\n    this.age++;\n};\n\n// Creating instances\nconst person1 = new Person(\"Alice\", 30);\nconst person2 = new Person(\"Bob\", 25);\n\n// Inheritance with prototypes\nfunction Student(name, age, grade) {\n    Person.call(this, name, age); // Call parent constructor\n    this.grade = grade;\n}\n\n// Set up inheritance\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\n// Add Student-specific methods\nStudent.prototype.study = function() {\n    return `${this.name} is studying`;\n};\n\nconst student = new Student(\"Charlie\", 20, \"A\");\nconsole.log(student.greet()); // Inherited method\nconsole.log(student.study()); // Own method\n```\n\n### SOLID Principles in JavaScript\n\nThe SOLID principles help create maintainable and scalable JavaScript applications.\n\n#### 1. Single Responsibility Principle (SRP)\n\n```javascript\n// âŒ Bad - Multiple responsibilities\nclass User {\n    constructor(name, email) {\n        this.name = name;\n        this.email = email;\n    }\n    \n    saveToDatabase() {\n        // Database logic\n        console.log('Saving to database...');\n    }\n    \n    sendEmail() {\n        // Email logic\n        console.log('Sending email...');\n    }\n    \n    validateEmail() {\n        // Validation logic\n        return this.email.includes('@');\n    }\n}\n\n// âœ… Good - Single responsibility per class\nclass User {\n    constructor(name, email) {\n        this.name = name;\n        this.email = email;\n    }\n}\n\nclass UserRepository {\n    save(user) {\n        console.log(`Saving ${user.name} to database...`);\n    }\n}\n\nclass EmailService {\n    send(user, message) {\n        console.log(`Sending email to ${user.email}: ${message}`);\n    }\n}\n\nclass EmailValidator {\n    isValid(email) {\n        return email.includes('@') && email.includes('.');\n    }\n}\n```\n\n#### 2. Open/Closed Principle (OCP)\n\n```javascript\n// âœ… Good - Open for extension, closed for modification\nclass Shape {\n    area() {\n        throw new Error('area() method must be implemented');\n    }\n}\n\nclass Circle extends Shape {\n    constructor(radius) {\n        super();\n        this.radius = radius;\n    }\n    \n    area() {\n        return Math.PI * this.radius ** 2;\n    }\n}\n\nclass Rectangle extends Shape {\n    constructor(width, height) {\n        super();\n        this.width = width;\n        this.height = height;\n    }\n    \n    area() {\n        return this.width * this.height;\n    }\n}\n\nclass AreaCalculator {\n    calculateTotal(shapes) {\n        return shapes.reduce((total, shape) => total + shape.area(), 0);\n    }\n}\n\n// Adding new shapes doesn't modify existing code\nclass Triangle extends Shape {\n    constructor(base, height) {\n        super();\n        this.base = base;\n        this.height = height;\n    }\n    \n    area() {\n        return 0.5 * this.base * this.height;\n    }\n}\n```\n\n#### 3. Liskov Substitution Principle (LSP)\n\n```javascript\n// âœ… Good - Proper inheritance hierarchy\nclass Bird {\n    move() {\n        throw new Error('move() method must be implemented');\n    }\n}\n\nclass FlyingBird extends Bird {\n    move() {\n        return this.fly();\n    }\n    \n    fly() {\n        return 'Flying through the air';\n    }\n}\n\nclass WalkingBird extends Bird {\n    move() {\n        return this.walk();\n    }\n    \n    walk() {\n        return 'Walking on the ground';\n    }\n}\n\nclass Eagle extends FlyingBird {\n    fly() {\n        return 'Soaring majestically';\n    }\n}\n\nclass Penguin extends WalkingBird {\n    walk() {\n        return 'Waddling on ice';\n    }\n}\n\n// All birds can be used interchangeably\nfunction makeBirdMove(bird) {\n    return bird.move();\n}\n\nconst eagle = new Eagle();\nconst penguin = new Penguin();\nconsole.log(makeBirdMove(eagle));   // Works correctly\nconsole.log(makeBirdMove(penguin)); // Works correctly\n```\n\n#### 4. Interface Segregation Principle (ISP)\n\n```javascript\n// âŒ Bad - Fat interface\nclass Worker {\n    work() {\n        throw new Error('work() must be implemented');\n    }\n    \n    eat() {\n        throw new Error('eat() must be implemented');\n    }\n    \n    sleep() {\n        throw new Error('sleep() must be implemented');\n    }\n}\n\n// âœ… Good - Segregated interfaces (using mixins in JavaScript)\nconst Workable = {\n    work() {\n        throw new Error('work() must be implemented');\n    }\n};\n\nconst Eatable = {\n    eat() {\n        throw new Error('eat() must be implemented');\n    }\n};\n\nconst Sleepable = {\n    sleep() {\n        throw new Error('sleep() must be implemented');\n    }\n};\n\nclass Human {\n    constructor(name) {\n        this.name = name;\n        Object.assign(this, Workable, Eatable, Sleepable);\n    }\n    \n    work() {\n        return `${this.name} is working`;\n    }\n    \n    eat() {\n        return `${this.name} is eating`;\n    }\n    \n    sleep() {\n        return `${this.name} is sleeping`;\n    }\n}\n\nclass Robot {\n    constructor(model) {\n        this.model = model;\n        Object.assign(this, Workable);\n    }\n    \n    work() {\n        return `${this.model} robot is working`;\n    }\n    // Robot doesn't implement eat() or sleep()\n}\n```\n\n#### 5. Dependency Inversion Principle (DIP)\n\n```javascript\n// âŒ Bad - High-level module depends on low-level module\nclass FileLogger {\n    log(message) {\n        console.log(`File: ${message}`);\n    }\n}\n\nclass OrderService {\n    constructor() {\n        this.logger = new FileLogger(); // Direct dependency\n    }\n    \n    createOrder(order) {\n        // Create order logic\n        this.logger.log(`Order ${order.id} created`);\n    }\n}\n\n// âœ… Good - Depend on abstraction\nclass Logger {\n    log(message) {\n        throw new Error('log() method must be implemented');\n    }\n}\n\nclass FileLogger extends Logger {\n    log(message) {\n        console.log(`[FILE] ${new Date().toISOString()}: ${message}`);\n    }\n}\n\nclass DatabaseLogger extends Logger {\n    log(message) {\n        console.log(`[DB] ${new Date().toISOString()}: ${message}`);\n    }\n}\n\nclass ConsoleLogger extends Logger {\n    log(message) {\n        console.log(`[CONSOLE] ${message}`);\n    }\n}\n\nclass OrderService {\n    constructor(logger) {\n        this.logger = logger; // Depends on abstraction\n    }\n    \n    createOrder(order) {\n        // Create order logic\n        this.logger.log(`Order ${order.id} created successfully`);\n    }\n}\n\n// Usage with dependency injection\nconst fileLogger = new FileLogger();\nconst orderService = new OrderService(fileLogger);\n\n// Easy to switch implementations\nconst consoleLogger = new ConsoleLogger();\nconst orderServiceWithConsole = new OrderService(consoleLogger);\n```\n\n#### SOLID Principles in Practice\n\n```javascript\n// Real-world example combining all SOLID principles\n\n// Interfaces (using classes as contracts)\nclass PaymentProcessor {\n    process(amount) {\n        throw new Error('process() must be implemented');\n    }\n}\n\nclass NotificationService {\n    send(message, recipient) {\n        throw new Error('send() must be implemented');\n    }\n}\n\nclass Logger {\n    log(message) {\n        throw new Error('log() must be implemented');\n    }\n}\n\n// Concrete implementations (SRP)\nclass StripePaymentProcessor extends PaymentProcessor {\n    process(amount) {\n        return { success: true, transactionId: `stripe_${Date.now()}` };\n    }\n}\n\nclass PayPalPaymentProcessor extends PaymentProcessor {\n    process(amount) {\n        return { success: true, transactionId: `paypal_${Date.now()}` };\n    }\n}\n\nclass EmailNotificationService extends NotificationService {\n    send(message, recipient) {\n        console.log(`Email sent to ${recipient}: ${message}`);\n    }\n}\n\nclass SMSNotificationService extends NotificationService {\n    send(message, recipient) {\n        console.log(`SMS sent to ${recipient}: ${message}`);\n    }\n}\n\nclass ConsoleLogger extends Logger {\n    log(message) {\n        console.log(`[LOG] ${new Date().toISOString()}: ${message}`);\n    }\n}\n\n// High-level module (DIP)\nclass OrderProcessor {\n    constructor(paymentProcessor, notificationService, logger) {\n        this.paymentProcessor = paymentProcessor;\n        this.notificationService = notificationService;\n        this.logger = logger;\n    }\n    \n    processOrder(order) {\n        try {\n            this.logger.log(`Processing order ${order.id}`);\n            \n            const result = this.paymentProcessor.process(order.amount);\n            \n            if (result.success) {\n                this.notificationService.send(\n                    `Your order ${order.id} has been processed successfully!`,\n                    order.customerEmail\n                );\n                this.logger.log(`Order ${order.id} completed successfully`);\n                return { success: true, transactionId: result.transactionId };\n            }\n        } catch (error) {\n            this.logger.log(`Order ${order.id} failed: ${error.message}`);\n            return { success: false, error: error.message };\n        }\n    }\n}\n\n// Usage with dependency injection\nconst stripeProcessor = new StripePaymentProcessor();\nconst emailService = new EmailNotificationService();\nconst logger = new ConsoleLogger();\n\nconst orderProcessor = new OrderProcessor(stripeProcessor, emailService, logger);\n\nconst order = {\n    id: 'ORD-001',\n    amount: 99.99,\n    customerEmail: 'customer@example.com'\n};\n\norderProcessor.processOrder(order);\n```\n\n---\n\n## 9. Functional Programming\n\n**Functional programming treats computation as the evaluation of mathematical functions, avoiding state changes and mutable data.** Key concepts include pure functions (no side effects), immutability, higher-order functions, and function composition. Functional programming leads to more predictable, testable, and maintainable code.\n\n### Pure Functions\n\n```javascript\n// Pure function - no side effects, same input = same output\nfunction add(a, b) {\n    return a + b;\n}\n\n// Impure function - has side effects\nlet counter = 0;\nfunction impureIncrement() {\n    counter++; // Modifies external state\n    return counter;\n}\n\n// Pure function alternative\nfunction pureIncrement(value) {\n    return value + 1;\n}\n```\n\n### Array Methods for Functional Programming\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// Map - transform each element\nconst doubled = numbers.map(n => n * 2);\nconst words = numbers.map(n => `Number ${n}`);\n\n// Filter - select elements based on condition\nconst evens = numbers.filter(n => n % 2 === 0);\nconst greaterThanThree = numbers.filter(n => n > 3);\n\n// Reduce - accumulate values\nconst sum = numbers.reduce((total, n) => total + n, 0);\nconst product = numbers.reduce((total, n) => total * n, 1);\nconst max = numbers.reduce((max, n) => n > max ? n : max, -Infinity);\n\n// Chaining methods\nconst result = numbers\n    .filter(n => n % 2 === 0)  // Get even numbers\n    .map(n => n * n)           // Square them\n    .reduce((sum, n) => sum + n, 0); // Sum them up\n\n// Some and every\nconst hasEven = numbers.some(n => n % 2 === 0);    // true if any even\nconst allPositive = numbers.every(n => n > 0);     // true if all positive\n```\n\n### Function Composition\n\n```javascript\n// Simple function composition\nconst compose = (f, g) => (x) => f(g(x));\nconst pipe = (f, g) => (x) => g(f(x));\n\nconst addOne = x => x + 1;\nconst double = x => x * 2;\nconst square = x => x * x;\n\n// Using compose (right to left execution)\nconst addOneThenDouble = compose(double, addOne);\nconsole.log(addOneThenDouble(3)); // 8 - first addOne(3)=4, then double(4)=8\n\n// Using pipe (left to right execution)\nconst doubleThenAddOne = pipe(double, addOne);\nconsole.log(doubleThenAddOne(3)); // 7 - first double(3)=6, then addOne(6)=7\n\n// Multiple function composition\nconst multiCompose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);\nconst multiPipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);\n\nconst complexOperation = multiPipe(addOne, double, square);\nconsole.log(complexOperation(3)); // ((3 + 1) * 2) ^ 2 = 64\n```\n\n### Immutability\n\n```javascript\n// Immutable array operations\nconst originalArray = [1, 2, 3, 4, 5];\n\n// Adding elements (immutable)\nconst withNewElement = [...originalArray, 6];\nconst withElementAtStart = [0, ...originalArray];\n\n// Removing elements (immutable)\nconst withoutFirst = originalArray.slice(1);\nconst withoutLast = originalArray.slice(0, -1);\nconst withoutMiddle = originalArray.filter((_, index) => index !== 2);\n\n// Modifying elements (immutable)\nconst doubled = originalArray.map(n => n * 2);\nconst replacedAtIndex = originalArray.map((n, i) => i === 2 ? 99 : n);\n\n// Immutable object operations\nconst originalObject = {name: \"Alice\", age: 30, city: \"NYC\"};\n\n// Adding properties (immutable)\nconst withNewProperty = {...originalObject, email: \"alice@example.com\"};\n\n// Modifying properties (immutable)\nconst withModifiedAge = {...originalObject, age: 31};\n\n// Removing properties (immutable)\nconst {city, ...withoutCity} = originalObject;\n\n// Deep cloning for nested objects\nconst deepClone = obj => JSON.parse(JSON.stringify(obj));\nconst complexObject = {\n    user: {name: \"Alice\", preferences: {theme: \"dark\"}}\n};\nconst cloned = deepClone(complexObject);\n```\n\n---\n\n## 10. Error Handling\n\n**Proper error handling prevents application crashes and provides meaningful feedback when things go wrong.** JavaScript offers try-catch-finally blocks for synchronous code and .catch() for promises/async functions. Creating custom error classes helps categorize and handle different error types appropriately in production applications.\n\n### Try-Catch-Finally\n\n```javascript\n// Basic error handling\ntry {\n    const result = riskyOperation();\n    console.log(\"Success:\", result);\n} catch (error) {\n    console.error(\"Error occurred:\", error.message);\n} finally {\n    console.log(\"This always executes\");\n}\n\n// Specific error types\ntry {\n    JSON.parse(invalidJSON);\n} catch (error) {\n    if (error instanceof SyntaxError) {\n        console.error(\"Invalid JSON format\");\n    } else if (error instanceof TypeError) {\n        console.error(\"Type error occurred\");\n    } else {\n        console.error(\"Unknown error:\", error);\n    }\n}\n\n// Rethrowing errors\nfunction processData(data) {\n    try {\n        return JSON.parse(data);\n    } catch (error) {\n        console.error(\"Failed to parse data\");\n        throw error; // Rethrow for caller to handle\n    }\n}\n```\n\n### Custom Errors\n\n```javascript\n// Custom error class\nclass ValidationError extends Error {\n    constructor(message, field) {\n        super(message);\n        this.name = \"ValidationError\";\n        this.field = field;\n    }\n}\n\n// Using custom errors\nfunction validateAge(age) {\n    if (typeof age !== 'number') {\n        throw new ValidationError(\"Age must be a number\", \"age\");\n    }\n    if (age < 0) {\n        throw new ValidationError(\"Age cannot be negative\", \"age\");\n    }\n    if (age > 150) {\n        throw new ValidationError(\"Age seems unrealistic\", \"age\");\n    }\n}\n\n// Handling custom errors\ntry {\n    validateAge(-5);\n} catch (error) {\n    if (error instanceof ValidationError) {\n        console.error(`Validation error in ${error.field}: ${error.message}`);\n    } else {\n        console.error(\"Unexpected error:\", error);\n    }\n}\n```\n\n### Error Handling with Promises\n\n```javascript\n// Promise error handling\nfetchUserData(1)\n    .then(user => {\n        console.log(\"User:\", user);\n    })\n    .catch(error => {\n        console.error(\"Failed to fetch user:\", error);\n    });\n\n// Async/await error handling\nasync function fetchUserSafely(userId) {\n    try {\n        const user = await fetchUserData(userId);\n        return { success: true, data: user };\n    } catch (error) {\n        return { success: false, error: error.message };\n    }\n}\n\n// Error handling with Promise.all\nasync function fetchMultipleUsersSafely(userIds) {\n    try {\n        const users = await Promise.all(\n            userIds.map(id => fetchUserData(id))\n        );\n        return users;\n    } catch (error) {\n        console.error(\"One or more users failed to load:\", error);\n        \n        // Alternative: Handle individual failures\n        const results = await Promise.allSettled(\n            userIds.map(id => fetchUserData(id))\n        );\n        \n        const successful = results\n            .filter(result => result.status === 'fulfilled')\n            .map(result => result.value);\n            \n        const failed = results\n            .filter(result => result.status === 'rejected')\n            .map(result => result.reason);\n            \n        return { successful, failed };\n    }\n}\n```\n\n---\n\n## 11. Node.js Backend Development\n\n**Node.js enables JavaScript to run on servers, making it possible to use JavaScript for full-stack development.** Node.js uses an event-driven, non-blocking I/O model that makes it efficient for handling concurrent requests. Express.js is the most popular Node.js framework for building web servers and REST APIs.\n\n### Express.js Server\n\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(helmet()); // Security headers\napp.use(cors()); // Enable CORS\napp.use(express.json()); // Parse JSON bodies\napp.use(express.urlencoded({ extended: true })); // Parse URL-encoded bodies\n\n// Basic routes\napp.get('/', (req, res) => {\n    res.json({ message: 'Welcome to Node.js API!' });\n});\n\napp.get('/api/users', (req, res) => {\n    const users = [\n        { id: 1, name: 'Alice', email: 'alice@example.com' },\n        { id: 2, name: 'Bob', email: 'bob@example.com' }\n    ];\n    res.json({ users });\n});\n\napp.post('/api/users', (req, res) => {\n    const { name, email } = req.body;\n    \n    if (!name || !email) {\n        return res.status(400).json({ error: 'Name and email required' });\n    }\n    \n    const newUser = { id: Date.now(), name, email };\n    res.status(201).json({ user: newUser });\n});\n\napp.get('/api/users/:id', (req, res) => {\n    const userId = parseInt(req.params.id);\n    // Simulate database lookup\n    const user = { id: userId, name: 'Sample User', email: 'user@example.com' };\n    res.json(user);\n});\n\n// Error handling middleware\napp.use((err, req, res, next) => {\n    console.error(err.stack);\n    res.status(500).json({ error: 'Something went wrong!' });\n});\n\n// 404 handler\napp.use('*', (req, res) => {\n    res.status(404).json({ error: 'Route not found' });\n});\n\napp.listen(PORT, () => {\n    console.log(`Server running on port ${PORT}`);\n});\n```\n\n### File System Operations\n\n```javascript\nconst fs = require('fs').promises;\nconst path = require('path');\n\nclass FileManager {\n    async readFile(filePath) {\n        try {\n            const data = await fs.readFile(filePath, 'utf8');\n            return data;\n        } catch (error) {\n            throw new Error(`Failed to read file: ${error.message}`);\n        }\n    }\n    \n    async writeFile(filePath, data) {\n        try {\n            await fs.writeFile(filePath, data, 'utf8');\n            console.log(`File written successfully: ${filePath}`);\n        } catch (error) {\n            throw new Error(`Failed to write file: ${error.message}`);\n        }\n    }\n    \n    async listDirectory(dirPath) {\n        try {\n            const files = await fs.readdir(dirPath);\n            return files.filter(file => !file.startsWith('.'));\n        } catch (error) {\n            throw new Error(`Failed to list directory: ${error.message}`);\n        }\n    }\n    \n    async createDirectory(dirPath) {\n        try {\n            await fs.mkdir(dirPath, { recursive: true });\n            console.log(`Directory created: ${dirPath}`);\n        } catch (error) {\n            throw new Error(`Failed to create directory: ${error.message}`);\n        }\n    }\n    \n    async fileExists(filePath) {\n        try {\n            await fs.access(filePath);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n}\n\n// Usage\nconst fileManager = new FileManager();\n\nasync function exampleUsage() {\n    try {\n        await fileManager.writeFile('./example.txt', 'Hello, Node.js!');\n        const content = await fileManager.readFile('./example.txt');\n        console.log('File content:', content);\n        \n        const files = await fileManager.listDirectory('./');\n        console.log('Directory contents:', files);\n    } catch (error) {\n        console.error('Error:', error.message);\n    }\n}\n```\n\n### Express.js Middleware Patterns\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// Built-in middleware\napp.use(express.json());  // Parse JSON bodies\napp.use(express.urlencoded({ extended: true }));  // Parse URL-encoded bodies\napp.use(express.static('public'));  // Serve static files\n\n// Custom middleware - Logging\nconst requestLogger = (req, res, next) => {\n    console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);\n    console.log('Headers:', req.headers);\n    console.log('Body:', req.body);\n    next();  // Pass control to next middleware\n};\n\napp.use(requestLogger);\n\n// Authentication middleware\nconst authenticate = (req, res, next) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    \n    if (!token) {\n        return res.status(401).json({ error: 'No token provided' });\n    }\n    \n    try {\n        const decoded = verifyToken(token);\n        req.user = decoded;  // Attach user to request\n        next();\n    } catch (error) {\n        res.status(401).json({ error: 'Invalid token' });\n    }\n};\n\n// Role-based authorization middleware\nconst authorize = (...roles) => {\n    return (req, res, next) => {\n        if (!req.user) {\n            return res.status(401).json({ error: 'Not authenticated' });\n        }\n        \n        if (!roles.includes(req.user.role)) {\n            return res.status(403).json({ error: 'Insufficient permissions' });\n        }\n        \n        next();\n    };\n};\n\n// Validation middleware\nconst validateUser = (req, res, next) => {\n    const { name, email, age } = req.body;\n    const errors = [];\n    \n    if (!name || name.length < 2) {\n        errors.push('Name must be at least 2 characters');\n    }\n    \n    if (!email || !email.includes('@')) {\n        errors.push('Valid email is required');\n    }\n    \n    if (age && (age < 0 || age > 150)) {\n        errors.push('Age must be between 0 and 150');\n    }\n    \n    if (errors.length > 0) {\n        return res.status(400).json({ errors });\n    }\n    \n    next();\n};\n\n// Error handling middleware (must be last)\nconst errorHandler = (err, req, res, next) => {\n    console.error('Error:', err);\n    \n    if (err.name === 'ValidationError') {\n        return res.status(400).json({ error: err.message });\n    }\n    \n    if (err.name === 'UnauthorizedError') {\n        return res.status(401).json({ error: 'Unauthorized' });\n    }\n    \n    res.status(500).json({ error: 'Internal server error' });\n};\n\n// Using middleware in routes\napp.post('/api/users', validateUser, (req, res) => {\n    const user = createUser(req.body);\n    res.status(201).json({ user });\n});\n\napp.get('/api/admin', authenticate, authorize('admin'), (req, res) => {\n    res.json({ message: 'Admin access granted', user: req.user });\n});\n\napp.use(errorHandler);\n```\n\n### Express.js REST API Best Practices\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\n// RESTful routes structure\n// GET /api/users - Get all users\nrouter.get('/users', async (req, res, next) => {\n    try {\n        const { page = 1, limit = 10, sort = 'createdAt' } = req.query;\n        \n        const users = await User.find()\n            .limit(limit * 1)\n            .skip((page - 1) * limit)\n            .sort(sort)\n            .select('-password');  // Exclude password field\n        \n        const count = await User.countDocuments();\n        \n        res.json({\n            users,\n            totalPages: Math.ceil(count / limit),\n            currentPage: page,\n            total: count\n        });\n    } catch (error) {\n        next(error);  // Pass to error handler\n    }\n});\n\n// GET /api/users/:id - Get single user\nrouter.get('/users/:id', async (req, res, next) => {\n    try {\n        const user = await User.findById(req.params.id).select('-password');\n        \n        if (!user) {\n            return res.status(404).json({ error: 'User not found' });\n        }\n        \n        res.json({ user });\n    } catch (error) {\n        next(error);\n    }\n});\n\n// POST /api/users - Create user\nrouter.post('/users', validateUser, async (req, res, next) => {\n    try {\n        const user = await User.create(req.body);\n        res.status(201).json({ user: user.toJSON() });  // 201 = Created\n    } catch (error) {\n        if (error.code === 11000) {  // Duplicate key error\n            return res.status(409).json({ error: 'User already exists' });\n        }\n        next(error);\n    }\n});\n\n// PUT /api/users/:id - Update entire user\nrouter.put('/users/:id', authenticate, async (req, res, next) => {\n    try {\n        const user = await User.findByIdAndUpdate(\n            req.params.id,\n            req.body,\n            { new: true, runValidators: true }\n        );\n        \n        if (!user) {\n            return res.status(404).json({ error: 'User not found' });\n        }\n        \n        res.json({ user });\n    } catch (error) {\n        next(error);\n    }\n});\n\n// PATCH /api/users/:id - Partial update\nrouter.patch('/users/:id', authenticate, async (req, res, next) => {\n    try {\n        const updates = req.body;\n        const user = await User.findByIdAndUpdate(\n            req.params.id,\n            { $set: updates },\n            { new: true, runValidators: true }\n        );\n        \n        if (!user) {\n            return res.status(404).json({ error: 'User not found' });\n        }\n        \n        res.json({ user });\n    } catch (error) {\n        next(error);\n    }\n});\n\n// DELETE /api/users/:id - Delete user\nrouter.delete('/users/:id', authenticate, authorize('admin'), async (req, res, next) => {\n    try {\n        const user = await User.findByIdAndDelete(req.params.id);\n        \n        if (!user) {\n            return res.status(404).json({ error: 'User not found' });\n        }\n        \n        res.status(204).send();  // 204 = No Content\n    } catch (error) {\n        next(error);\n    }\n});\n\nmodule.exports = router;\n```\n\n### Node.js Event Loop & Async Patterns\n\n```javascript\n// Understanding the Event Loop\nconsole.log('1. Synchronous code');  // Executes first\n\nsetTimeout(() => {\n    console.log('2. setTimeout callback');  // Macrotask - executes after microtasks\n}, 0);\n\nPromise.resolve().then(() => {\n    console.log('3. Promise callback');  // Microtask - executes before macrotasks\n});\n\nprocess.nextTick(() => {\n    console.log('4. nextTick callback');  // Executes before promises\n});\n\nconsole.log('5. More synchronous code');  // Executes second\n\n// Output order:\n// 1. Synchronous code\n// 5. More synchronous code\n// 4. nextTick callback\n// 3. Promise callback\n// 2. setTimeout callback\n\n// Async patterns - Parallel execution\nasync function fetchAllData() {\n    const start = Date.now();\n    \n    // Sequential (slow) - takes 3 seconds\n    const user = await fetchUser(1);      // 1 second\n    const posts = await fetchPosts(1);    // 1 second\n    const comments = await fetchComments(1); // 1 second\n    \n    console.log(`Sequential: ${Date.now() - start}ms`);  // ~3000ms\n    \n    // Parallel (fast) - takes 1 second\n    const [user2, posts2, comments2] = await Promise.all([\n        fetchUser(2),\n        fetchPosts(2),\n        fetchComments(2)\n    ]);\n    \n    console.log(`Parallel: ${Date.now() - start}ms`);  // ~1000ms\n}\n\n// Promise.allSettled - Handle both success and failure\nasync function fetchMultipleUsers(userIds) {\n    const results = await Promise.allSettled(\n        userIds.map(id => fetchUser(id))\n    );\n    \n    const successful = results\n        .filter(r => r.status === 'fulfilled')\n        .map(r => r.value);\n    \n    const failed = results\n        .filter(r => r.status === 'rejected')\n        .map(r => ({ reason: r.reason.message }));\n    \n    return { successful, failed };\n}\n\n// Promise.race - First to complete wins\nasync function fetchWithTimeout(url, timeout = 5000) {\n    return Promise.race([\n        fetch(url),\n        new Promise((_, reject) => \n            setTimeout(() => reject(new Error('Request timeout')), timeout)\n        )\n    ]);\n}\n\n// Async iteration\nasync function processItems(items) {\n    for (const item of items) {\n        await processItem(item);  // Sequential processing\n    }\n}\n\nasync function processItemsConcurrent(items) {\n    await Promise.all(items.map(item => processItem(item)));  // Parallel\n}\n\n// Async generators for streaming data\nasync function* fetchPages(startPage, endPage) {\n    for (let page = startPage; page <= endPage; page++) {\n        const data = await fetch(`/api/data?page=${page}`);\n        yield data;\n    }\n}\n\nasync function processPages() {\n    for await (const pageData of fetchPages(1, 10)) {\n        console.log('Processing page:', pageData);\n    }\n}\n```\n\n### Node.js Worker Threads (Multithreading)\n\n```javascript\n// Node.js is single-threaded, but Worker Threads enable true parallelism\n// main.js - Main thread\nconst { Worker } = require('worker_threads');\nconst path = require('path');\n\n// Create a worker thread\nfunction runWorker(data) {\n    return new Promise((resolve, reject) => {\n        const worker = new Worker(path.join(__dirname, 'worker.js'), {\n            workerData: data\n        });\n        \n        worker.on('message', resolve);  // Worker sends result\n        worker.on('error', reject);     // Worker encounters error\n        worker.on('exit', (code) => {\n            if (code !== 0) {\n                reject(new Error(`Worker stopped with exit code ${code}`));\n            }\n        });\n    });\n}\n\n// Using worker for CPU-intensive task\nasync function calculatePrimes(max) {\n    console.log('Main thread: Starting calculation...');\n    const result = await runWorker({ task: 'calculatePrimes', max });\n    console.log('Main thread: Calculation complete');\n    return result;\n}\n\n// Using multiple workers for parallel processing\nasync function processDataParallel(dataChunks) {\n    const workers = dataChunks.map(chunk => runWorker({ task: 'process', data: chunk }));\n    return Promise.all(workers);\n}\n\n// Example usage\n(async () => {\n    const primes = await calculatePrimes(1000000);\n    console.log(`Found ${primes.length} prime numbers`);\n    \n    // Process 4 chunks in parallel\n    const chunks = [\n        [1, 100000],\n        [100001, 200000],\n        [200001, 300000],\n        [300001, 400000]\n    ];\n    const results = await processDataParallel(chunks);\n    console.log('Parallel processing complete:', results);\n})();\n\n// worker.js - Worker thread\nconst { parentPort, workerData } = require('worker_threads');\n\nfunction calculatePrimes(max) {\n    const primes = [];\n    for (let i = 2; i <= max; i++) {\n        let isPrime = true;\n        for (let j = 2; j <= Math.sqrt(i); j++) {\n            if (i % j === 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) primes.push(i);\n    }\n    return primes;\n}\n\nfunction processData(data) {\n    // CPU-intensive processing\n    return data.map(item => item * 2);\n}\n\n// Handle different tasks\nif (workerData.task === 'calculatePrimes') {\n    const result = calculatePrimes(workerData.max);\n    parentPort.postMessage(result);\n} else if (workerData.task === 'process') {\n    const result = processData(workerData.data);\n    parentPort.postMessage(result);\n}\n\n// Worker pool for reusable workers\nclass WorkerPool {\n    constructor(workerScript, poolSize = 4) {\n        this.workerScript = workerScript;\n        this.poolSize = poolSize;\n        this.workers = [];\n        this.queue = [];\n        \n        for (let i = 0; i < poolSize; i++) {\n            this.workers.push(this.createWorker());\n        }\n    }\n    \n    createWorker() {\n        return {\n            worker: null,\n            inUse: false\n        };\n    }\n    \n    async execute(data) {\n        return new Promise((resolve, reject) => {\n            const availableWorker = this.workers.find(w => !w.inUse);\n            \n            if (availableWorker) {\n                this.runTask(availableWorker, data, resolve, reject);\n            } else {\n                // Queue task if no workers available\n                this.queue.push({ data, resolve, reject });\n            }\n        });\n    }\n    \n    runTask(workerObj, data, resolve, reject) {\n        workerObj.inUse = true;\n        \n        const worker = new Worker(this.workerScript, { workerData: data });\n        workerObj.worker = worker;\n        \n        worker.on('message', (result) => {\n            workerObj.inUse = false;\n            worker.terminate();\n            resolve(result);\n            this.processQueue();\n        });\n        \n        worker.on('error', (error) => {\n            workerObj.inUse = false;\n            worker.terminate();\n            reject(error);\n            this.processQueue();\n        });\n    }\n    \n    processQueue() {\n        if (this.queue.length > 0) {\n            const { data, resolve, reject } = this.queue.shift();\n            const availableWorker = this.workers.find(w => !w.inUse);\n            if (availableWorker) {\n                this.runTask(availableWorker, data, resolve, reject);\n            }\n        }\n    }\n}\n\n// Usage\nconst pool = new WorkerPool('./worker.js', 4);\n\nasync function processManyTasks() {\n    const tasks = Array.from({ length: 100 }, (_, i) => ({ task: 'process', id: i }));\n    const results = await Promise.all(tasks.map(task => pool.execute(task)));\n    console.log('All tasks completed:', results.length);\n}\n```\n\n### Node.js Streams for Large Data\n\n```javascript\nconst fs = require('fs');\nconst { pipeline, Transform } = require('stream');\nconst zlib = require('zlib');\n\n// Reading large files with streams (memory efficient)\nconst readStream = fs.createReadStream('large-file.txt', { \n    encoding: 'utf8',\n    highWaterMark: 64 * 1024  // 64KB chunks\n});\n\nreadStream.on('data', (chunk) => {\n    console.log(`Received ${chunk.length} bytes`);\n});\n\nreadStream.on('end', () => {\n    console.log('Finished reading file');\n});\n\nreadStream.on('error', (error) => {\n    console.error('Error reading file:', error);\n});\n\n// Writing with streams\nconst writeStream = fs.createWriteStream('output.txt');\nwriteStream.write('Hello, ');\nwriteStream.write('World!\\n');\nwriteStream.end();\n\n// Pipe streams together\nfs.createReadStream('input.txt')\n    .pipe(fs.createWriteStream('output.txt'));\n\n// Transform stream - process data as it flows\nclass UpperCaseTransform extends Transform {\n    _transform(chunk, encoding, callback) {\n        const upperCased = chunk.toString().toUpperCase();\n        this.push(upperCased);\n        callback();\n    }\n}\n\n// Pipeline with error handling (recommended)\npipeline(\n    fs.createReadStream('input.txt'),\n    new UpperCaseTransform(),\n    zlib.createGzip(),  // Compress\n    fs.createWriteStream('output.txt.gz'),\n    (error) => {\n        if (error) {\n            console.error('Pipeline failed:', error);\n        } else {\n            console.log('Pipeline succeeded');\n        }\n    }\n);\n\n// Backpressure handling\nconst readable = fs.createReadStream('large-file.txt');\nconst writable = fs.createWriteStream('output.txt');\n\nreadable.on('data', (chunk) => {\n    const canContinue = writable.write(chunk);\n    \n    if (!canContinue) {\n        // Backpressure - pause reading\n        readable.pause();\n    }\n});\n\nwritable.on('drain', () => {\n    // Buffer cleared - resume reading\n    readable.resume();\n});\n\n// Async iteration over streams (Node.js 10+)\nasync function processFile(filePath) {\n    const stream = fs.createReadStream(filePath, { encoding: 'utf8' });\n    \n    for await (const chunk of stream) {\n        console.log('Processing chunk:', chunk.length);\n        await processChunk(chunk);\n    }\n}\n```\n\n---\n\n## 12. Testing Frameworks\n\n**Automated testing ensures code reliability and makes refactoring safer by catching bugs early in development.** Jest is the most popular JavaScript testing framework, offering features like snapshot testing, mocking, and code coverage. Test-Driven Development (TDD) involves writing tests before implementing features, leading to better-designed code.\n\n### Jest Testing Framework\n\n```javascript\n// calculator.js\nclass Calculator {\n    add(a, b) {\n        return a + b;\n    }\n    \n    subtract(a, b) {\n        return a - b;\n    }\n    \n    multiply(a, b) {\n        return a * b;\n    }\n    \n    divide(a, b) {\n        if (b === 0) {\n            throw new Error('Division by zero');\n        }\n        return a / b;\n    }\n    \n    async fetchData(url) {\n        // Simulate API call\n        return new Promise(resolve => {\n            setTimeout(() => resolve(`Data from ${url}`), 100);\n        });\n    }\n}\n\nmodule.exports = Calculator;\n\n// calculator.test.js\nconst Calculator = require('./calculator');\n\ndescribe('Calculator', () => {\n    let calculator;\n    \n    beforeEach(() => {\n        calculator = new Calculator();\n    });\n    \n    describe('Basic Operations', () => {\n        test('should add two numbers correctly', () => {\n            expect(calculator.add(2, 3)).toBe(5);\n            expect(calculator.add(-1, 1)).toBe(0);\n        });\n        \n        test('should subtract two numbers correctly', () => {\n            expect(calculator.subtract(5, 3)).toBe(2);\n            expect(calculator.subtract(0, 5)).toBe(-5);\n        });\n        \n        test('should multiply two numbers correctly', () => {\n            expect(calculator.multiply(3, 4)).toBe(12);\n            expect(calculator.multiply(-2, 3)).toBe(-6);\n        });\n        \n        test('should divide two numbers correctly', () => {\n            expect(calculator.divide(8, 2)).toBe(4);\n            expect(calculator.divide(7, 2)).toBe(3.5);\n        });\n        \n        test('should throw error when dividing by zero', () => {\n            expect(() => calculator.divide(5, 0)).toThrow('Division by zero');\n        });\n    });\n    \n    describe('Async Operations', () => {\n        test('should fetch data successfully', async () => {\n            const result = await calculator.fetchData('https://api.example.com');\n            expect(result).toBe('Data from https://api.example.com');\n        });\n        \n        test('should handle multiple async calls', async () => {\n            const promises = [\n                calculator.fetchData('url1'),\n                calculator.fetchData('url2')\n            ];\n            const results = await Promise.all(promises);\n            expect(results).toHaveLength(2);\n        });\n    });\n    \n    describe('Edge Cases', () => {\n        test('should handle floating point precision', () => {\n            expect(calculator.add(0.1, 0.2)).toBeCloseTo(0.3);\n        });\n        \n        test('should handle large numbers', () => {\n            const largeNum = Number.MAX_SAFE_INTEGER;\n            expect(calculator.add(largeNum, 1)).toBe(largeNum + 1);\n        });\n    });\n});\n\n// Mocking example\njest.mock('./external-service');\nconst externalService = require('./external-service');\n\ntest('should use mocked service', async () => {\n    externalService.getData.mockResolvedValue({ id: 1, name: 'Test' });\n    \n    const result = await someFunction();\n    expect(result).toEqual({ id: 1, name: 'Test' });\n    expect(externalService.getData).toHaveBeenCalledTimes(1);\n});\n```\n\n### Test-Driven Development (TDD)\n\n```javascript\n// 1. Write failing test first\ndescribe('UserService', () => {\n    test('should create user with valid data', () => {\n        const userService = new UserService();\n        const userData = { name: 'Alice', email: 'alice@example.com' };\n        \n        const user = userService.createUser(userData);\n        \n        expect(user.id).toBeDefined();\n        expect(user.name).toBe('Alice');\n        expect(user.email).toBe('alice@example.com');\n        expect(user.createdAt).toBeInstanceOf(Date);\n    });\n    \n    test('should throw error for invalid email', () => {\n        const userService = new UserService();\n        const userData = { name: 'Alice', email: 'invalid-email' };\n        \n        expect(() => userService.createUser(userData)).toThrow('Invalid email');\n    });\n});\n\n// 2. Write minimal code to make test pass\nclass UserService {\n    createUser(userData) {\n        if (!this.isValidEmail(userData.email)) {\n            throw new Error('Invalid email');\n        }\n        \n        return {\n            id: Date.now(),\n            name: userData.name,\n            email: userData.email,\n            createdAt: new Date()\n        };\n    }\n    \n    isValidEmail(email) {\n        return email.includes('@') && email.includes('.');\n    }\n}\n\n// 3. Refactor code while keeping tests green\n```\n\n---\n\n## 13. Advanced Concepts\n\n**Advanced JavaScript concepts include closures, prototypes, symbols, generators, and iterators that enable powerful programming patterns.** Closures allow functions to remember their lexical scope even when executed outside of it. Generators provide a way to create iterators with pause/resume functionality using yield.\n\n### Closures\n\n```javascript\n// Basic closure\nfunction outerFunction(x) {\n    // Variable in outer scope\n    return function innerFunction(y) {\n        return x + y; // Accesses variable from outer scope\n    };\n}\n\nconst addFive = outerFunction(5);  // Returns inner function with x=5\nconsole.log(addFive(3)); // 8 (5 + 3, closure remembers x=5)\n\n// Practical closure example - Module pattern\nconst counterModule = (function() {\n    let count = 0; // Private variable\n    \n    return {\n        increment: function() {\n            count++;\n            return count;\n        },\n        decrement: function() {\n            count--;\n            return count;\n        },\n        getCount: function() {\n            return count;\n        }\n    };\n})();\n\nconsole.log(counterModule.increment()); // 1 (count is now 1)\nconsole.log(counterModule.increment()); // 2 (count is now 2)\nconsole.log(counterModule.getCount()); // 2 (returns private count)\n// console.log(count); // ReferenceError - count is private (not accessible)\n```\n\n### Prototypal Inheritance\n\n```javascript\n// Creating objects with Object.create\nconst animalPrototype = {\n    speak() {\n        return `${this.name} makes a sound`;\n    },\n    eat() {\n        return `${this.name} is eating`;\n    }\n};\n\nconst dog = Object.create(animalPrototype);\ndog.name = \"Buddy\";\ndog.speak = function() {\n    return `${this.name} barks!`;\n};\n\nconsole.log(dog.speak()); // \"Buddy barks!\"\nconsole.log(dog.eat());   // \"Buddy is eating\"\n\n// Prototype chain\nconsole.log(dog.__proto__ === animalPrototype); // true\nconsole.log(animalPrototype.__proto__ === Object.prototype); // true\n```\n\n### Symbols\n\n```javascript\n// Creating symbols\nconst sym1 = Symbol('description');\nconst sym2 = Symbol('description');\nconsole.log(sym1 === sym2); // false - each symbol is unique\n\n// Using symbols as object properties\nconst SECRET_PROPERTY = Symbol('secret');\nconst obj = {\n    name: 'Alice',\n    [SECRET_PROPERTY]: 'This is secret'\n};\n\nconsole.log(obj.name); // 'Alice'\nconsole.log(obj[SECRET_PROPERTY]); // 'This is secret'\n\n// Symbols are not enumerable\nconsole.log(Object.keys(obj)); // ['name'] - symbol property not included\n\n// Well-known symbols\nconst customIterable = {\n    data: [1, 2, 3],\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.data.length) {\n                    return { value: this.data[index++], done: false };\n                } else {\n                    return { done: true };\n                }\n            }\n        };\n    }\n};\n\nfor (const value of customIterable) {\n    console.log(value); // 1, 2, 3\n}\n```\n\n### Iterators and Generators\n\n```javascript\n// Generator function\nfunction* numberGenerator() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nconst gen = numberGenerator();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: false }\nconsole.log(gen.next()); // { value: undefined, done: true }\n\n// Infinite generator\nfunction* fibonacci() {\n    let a = 0, b = 1;\n    while (true) {\n        yield a;\n        [a, b] = [b, a + b];\n    }\n}\n\nconst fib = fibonacci();\nconsole.log([fib.next().value, fib.next().value, fib.next().value]); // [0, 1, 1]\n\n// Generator with parameters\nfunction* range(start, end, step = 1) {\n    for (let i = start; i < end; i += step) {\n        yield i;\n    }\n}\n\nconsole.log([...range(0, 10, 2)]); // [0, 2, 4, 6, 8]\n\n// Async generators\nasync function* asyncNumberGenerator() {\n    for (let i = 0; i < 3; i++) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        yield i;\n    }\n}\n\nasync function useAsyncGenerator() {\n    for await (const num of asyncNumberGenerator()) {\n        console.log(num); // 0, 1, 2 (with delays)\n    }\n}\n```\n\n---\n\n## 14. Performance Optimization\n\n**Performance optimization involves reducing memory usage, improving execution speed, and ensuring smooth user experiences.** Techniques like debouncing/throttling prevent excessive function calls, while proper memory management avoids leaks. Object pooling and lazy loading help manage resources efficiently in large applications.\n\n### Memory Management\n\n```javascript\n// Avoiding memory leaks\n// 1. Remove event listeners\nfunction addListener() {\n    const button = document.getElementById('myButton');\n    const handler = () => console.log('Clicked');\n    \n    button.addEventListener('click', handler);\n    \n    // Remember to remove listener when done\n    return () => button.removeEventListener('click', handler);\n}\n\n// 2. Clear timers\nconst timerId = setTimeout(() => {\n    console.log('Timer executed');\n}, 1000);\n\n// Clear timer if needed\nclearTimeout(timerId);\n\n// 3. Weak references for caches\nconst cache = new WeakMap();\n\nfunction expensiveOperation(obj) {\n    if (cache.has(obj)) {\n        return cache.get(obj);\n    }\n    \n    const result = /* expensive computation */ obj.value * 2;\n    cache.set(obj, result);\n    return result;\n}\n```\n\n### Debouncing and Throttling\n\n```javascript\n// Debouncing - delay execution until after calls have stopped\nfunction debounce(func, delay) {\n    let timeoutId;\n    return function(...args) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => func.apply(this, args), delay);\n    };\n}\n\n// Usage: Search input\nconst searchInput = document.getElementById('search');\nconst debouncedSearch = debounce((event) => {\n    console.log('Searching for:', event.target.value);\n    // Perform search API call\n}, 300);\n\nsearchInput.addEventListener('input', debouncedSearch);\n\n// Throttling - limit execution to once per time period\nfunction throttle(func, limit) {\n    let inThrottle;\n    return function(...args) {\n        if (!inThrottle) {\n            func.apply(this, args);\n            inThrottle = true;\n            setTimeout(() => inThrottle = false, limit);\n        }\n    };\n}\n\n// Usage: Scroll event\nconst throttledScroll = throttle(() => {\n    console.log('Scroll event handled');\n}, 100);\n\nwindow.addEventListener('scroll', throttledScroll);\n```\n\n### Object Pooling\n\n```javascript\n// Object pooling for performance\nclass ObjectPool {\n    constructor(createFn, resetFn, maxSize = 10) {\n        this.createFn = createFn;\n        this.resetFn = resetFn;\n        this.maxSize = maxSize;\n        this.pool = [];\n    }\n    \n    acquire() {\n        if (this.pool.length > 0) {\n            return this.pool.pop();\n        }\n        return this.createFn();\n    }\n    \n    release(obj) {\n        if (this.pool.length < this.maxSize) {\n            this.resetFn(obj);\n            this.pool.push(obj);\n        }\n    }\n}\n\n// Example: Vector pool for game development\nconst vectorPool = new ObjectPool(\n    () => ({ x: 0, y: 0 }),\n    (vector) => { vector.x = 0; vector.y = 0; }\n);\n\nfunction gameLoop() {\n    const velocity = vectorPool.acquire();\n    velocity.x = 10;\n    velocity.y = 5;\n    \n    // Use velocity for calculations\n    \n    vectorPool.release(velocity); // Return to pool\n}\n```\n\n---\n\n## 15. Modern JavaScript Ecosystem\n\n**The modern JavaScript ecosystem includes package managers (npm/yarn), module bundlers (Webpack/Vite), transpilers (Babel), and development tools.** Package.json defines project dependencies and scripts, while build tools optimize code for production. Understanding the ecosystem is essential for professional JavaScript development.\n\n### Package.json and NPM\n\n```json\n{\n  \"name\": \"modern-js-project\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"lint\": \"eslint src/\",\n    \"format\": \"prettier --write src/\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.0.0\",\n    \"react-dom\": \"^18.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"^18.0.0\",\n    \"@vitejs/plugin-react\": \"^4.0.0\",\n    \"eslint\": \"^8.0.0\",\n    \"jest\": \"^29.0.0\",\n    \"prettier\": \"^3.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"vite\": \"^4.0.0\"\n  }\n}\n```\n\n### Vite Configuration\n\n```javascript\n// vite.config.js\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 3000,\n    hot: true\n  },\n  build: {\n    outDir: 'dist',\n    sourcemap: true,\n    minify: 'terser'\n  },\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, 'src')\n    }\n  }\n});\n```\n\n### ESLint Configuration\n\n```javascript\n// .eslintrc.js\nmodule.exports = {\n  extends: [\n    'eslint:recommended',\n    '@typescript-eslint/recommended',\n    'prettier'\n  ],\n  rules: {\n    'no-console': 'warn',\n    'prefer-const': 'error',\n    'no-var': 'error'\n  }\n};\n```\n\n### Modern Module System\n\n```javascript\n// ES Modules (modern)\n// math.js\nexport const PI = 3.14159;\nexport function add(a, b) {\n    return a + b;\n}\nexport default function multiply(a, b) {\n    return a * b;\n}\n\n// main.js\nimport multiply, { add, PI } from './math.js';\nimport * as math from './math.js';\n\nconsole.log(add(2, 3));        // 5\nconsole.log(multiply(2, 3));   // 6\nconsole.log(math.PI);          // 3.14159\n\n// Dynamic imports\nasync function loadModule() {\n    const { add } = await import('./math.js');\n    return add(5, 3);\n}\n\n// CommonJS (Node.js)\n// math.js\nconst PI = 3.14159;\nfunction add(a, b) {\n    return a + b;\n}\nmodule.exports = { PI, add };\n\n// main.js\nconst { PI, add } = require('./math');\n```\n\n---\n\n## 16. âš›ï¸ React Framework (Essential for Interviews)\n\n**React is the most popular JavaScript library for building user interfaces, using a component-based architecture and virtual DOM for efficient rendering.** React's declarative approach makes it easy to create interactive UIs. Understanding hooks, state management, and component lifecycle is crucial for modern React development.\n\n### React Basics and JSX\n\n```javascript\n// React component with JSX\nimport React from 'react';\n\n// Functional component\nfunction Welcome(props) {\n    return <h1>Hello, {props.name}!</h1>;  // JSX - looks like HTML but is JavaScript\n}\n\n// Component with multiple elements\nfunction App() {\n    return (\n        <div className=\"app\">\n            <Welcome name=\"Alice\" />\n            <Welcome name=\"Bob\" />\n        </div>\n    );\n}\n\n// Component with props destructuring\nconst UserCard = ({ name, age, email }) => {\n    return (\n        <div className=\"user-card\">\n            <h2>{name}</h2>\n            <p>Age: {age}</p>\n            <p>Email: {email}</p>\n        </div>\n    );\n};\n```\n\n### React Hooks - useState\n\n```javascript\nimport React, { useState } from 'react';\n\n// Simple counter with useState\nfunction Counter() {\n    const [count, setCount] = useState(0);  // Initial state = 0\n    \n    return (\n        <div>\n            <p>Count: {count}</p>\n            <button onClick={() => setCount(count + 1)}>Increment</button>\n            <button onClick={() => setCount(count - 1)}>Decrement</button>\n            <button onClick={() => setCount(0)}>Reset</button>\n        </div>\n    );\n}\n\n// Multiple state variables\nfunction UserForm() {\n    const [name, setName] = useState('');\n    const [email, setEmail] = useState('');\n    const [age, setAge] = useState(0);\n    \n    const handleSubmit = (e) => {\n        e.preventDefault();\n        console.log({ name, email, age });\n    };\n    \n    return (\n        <form onSubmit={handleSubmit}>\n            <input \n                value={name} \n                onChange={(e) => setName(e.target.value)}\n                placeholder=\"Name\"\n            />\n            <input \n                value={email} \n                onChange={(e) => setEmail(e.target.value)}\n                placeholder=\"Email\"\n                type=\"email\"\n            />\n            <input \n                value={age} \n                onChange={(e) => setAge(Number(e.target.value))}\n                placeholder=\"Age\"\n                type=\"number\"\n            />\n            <button type=\"submit\">Submit</button>\n        </form>\n    );\n}\n\n// State with objects\nfunction UserProfile() {\n    const [user, setUser] = useState({\n        name: 'Alice',\n        age: 30,\n        preferences: { theme: 'dark', language: 'en' }\n    });\n    \n    // Update nested state immutably\n    const updateTheme = (newTheme) => {\n        setUser(prevUser => ({\n            ...prevUser,\n            preferences: {\n                ...prevUser.preferences,\n                theme: newTheme\n            }\n        }));\n    };\n    \n    return (\n        <div>\n            <h2>{user.name} - {user.age} years old</h2>\n            <p>Theme: {user.preferences.theme}</p>\n            <button onClick={() => updateTheme('light')}>Light Theme</button>\n            <button onClick={() => updateTheme('dark')}>Dark Theme</button>\n        </div>\n    );\n}\n```\n\n### React Hooks - useEffect\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\n// Fetch data on component mount\nfunction UserList() {\n    const [users, setUsers] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n    \n    useEffect(() => {\n        // This runs after component mounts\n        const fetchUsers = async () => {\n            try {\n                const response = await fetch('https://api.example.com/users');\n                const data = await response.json();\n                setUsers(data);\n                setLoading(false);\n            } catch (err) {\n                setError(err.message);\n                setLoading(false);\n            }\n        };\n        \n        fetchUsers();\n    }, []); // Empty dependency array = run once on mount\n    \n    if (loading) return <div>Loading...</div>;\n    if (error) return <div>Error: {error}</div>;\n    \n    return (\n        <ul>\n            {users.map(user => (\n                <li key={user.id}>{user.name}</li>\n            ))}\n        </ul>\n    );\n}\n\n// useEffect with dependencies\nfunction SearchBar() {\n    const [query, setQuery] = useState('');\n    const [results, setResults] = useState([]);\n    \n    useEffect(() => {\n        // This runs every time 'query' changes\n        if (query.length > 2) {\n            const fetchResults = async () => {\n                const response = await fetch(`/api/search?q=${query}`);\n                const data = await response.json();\n                setResults(data);\n            };\n            \n            // Debounce: delay search until user stops typing\n            const timeoutId = setTimeout(fetchResults, 300);\n            \n            // Cleanup function\n            return () => clearTimeout(timeoutId);\n        }\n    }, [query]); // Runs when query changes\n    \n    return (\n        <div>\n            <input \n                value={query}\n                onChange={(e) => setQuery(e.target.value)}\n                placeholder=\"Search...\"\n            />\n            <ul>\n                {results.map(result => (\n                    <li key={result.id}>{result.title}</li>\n                ))}\n            </ul>\n        </div>\n    );\n}\n\n// Cleanup with useEffect\nfunction Timer() {\n    const [seconds, setSeconds] = useState(0);\n    \n    useEffect(() => {\n        const intervalId = setInterval(() => {\n            setSeconds(s => s + 1);\n        }, 1000);\n        \n        // Cleanup function - runs on unmount\n        return () => clearInterval(intervalId);\n    }, []);\n    \n    return <div>Seconds: {seconds}</div>;\n}\n```\n\n### React Hooks - useContext\n\n```javascript\nimport React, { createContext, useContext, useState } from 'react';\n\n// Create context\nconst ThemeContext = createContext();\nconst UserContext = createContext();\n\n// Theme provider component\nfunction ThemeProvider({ children }) {\n    const [theme, setTheme] = useState('light');\n    \n    const toggleTheme = () => {\n        setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');\n    };\n    \n    return (\n        <ThemeContext.Provider value={{ theme, toggleTheme }}>\n            {children}\n        </ThemeContext.Provider>\n    );\n}\n\n// Component using context\nfunction ThemedButton() {\n    const { theme, toggleTheme } = useContext(ThemeContext);\n    \n    return (\n        <button \n            onClick={toggleTheme}\n            style={{\n                background: theme === 'light' ? '#fff' : '#333',\n                color: theme === 'light' ? '#000' : '#fff'\n            }}\n        >\n            Current theme: {theme}\n        </button>\n    );\n}\n\n// App with multiple contexts\nfunction App() {\n    const [user, setUser] = useState({ name: 'Alice', role: 'admin' });\n    \n    return (\n        <UserContext.Provider value={{ user, setUser }}>\n            <ThemeProvider>\n                <div>\n                    <ThemedButton />\n                    <UserProfile />\n                </div>\n            </ThemeProvider>\n        </UserContext.Provider>\n    );\n}\n\nfunction UserProfile() {\n    const { user } = useContext(UserContext);\n    const { theme } = useContext(ThemeContext);\n    \n    return (\n        <div style={{ background: theme === 'light' ? '#f0f0f0' : '#222' }}>\n            <h2>{user.name}</h2>\n            <p>Role: {user.role}</p>\n        </div>\n    );\n}\n```\n\n### Custom Hooks\n\n```javascript\nimport { useState, useEffect } from 'react';\n\n// Custom hook for API fetching\nfunction useFetch(url) {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n    \n    useEffect(() => {\n        const fetchData = async () => {\n            try {\n                const response = await fetch(url);\n                const result = await response.json();\n                setData(result);\n                setLoading(false);\n            } catch (err) {\n                setError(err.message);\n                setLoading(false);\n            }\n        };\n        \n        fetchData();\n    }, [url]);\n    \n    return { data, loading, error };\n}\n\n// Using custom hook\nfunction UserList() {\n    const { data: users, loading, error } = useFetch('/api/users');\n    \n    if (loading) return <div>Loading...</div>;\n    if (error) return <div>Error: {error}</div>;\n    \n    return (\n        <ul>\n            {users.map(user => <li key={user.id}>{user.name}</li>)}\n        </ul>\n    );\n}\n\n// Custom hook for local storage\nfunction useLocalStorage(key, initialValue) {\n    const [value, setValue] = useState(() => {\n        try {\n            const item = window.localStorage.getItem(key);\n            return item ? JSON.parse(item) : initialValue;\n        } catch (error) {\n            return initialValue;\n        }\n    });\n    \n    const setStoredValue = (newValue) => {\n        try {\n            setValue(newValue);\n            window.localStorage.setItem(key, JSON.stringify(newValue));\n        } catch (error) {\n            console.error(error);\n        }\n    };\n    \n    return [value, setStoredValue];\n}\n\n// Using local storage hook\nfunction TodoApp() {\n    const [todos, setTodos] = useLocalStorage('todos', []);\n    \n    const addTodo = (text) => {\n        setTodos([...todos, { id: Date.now(), text, completed: false }]);\n    };\n    \n    return (\n        <div>\n            {/* Todo list UI */}\n        </div>\n    );\n}\n\n// Custom hook for window size\nfunction useWindowSize() {\n    const [size, setSize] = useState({\n        width: window.innerWidth,\n        height: window.innerHeight\n    });\n    \n    useEffect(() => {\n        const handleResize = () => {\n            setSize({\n                width: window.innerWidth,\n                height: window.innerHeight\n            });\n        };\n        \n        window.addEventListener('resize', handleResize);\n        return () => window.removeEventListener('resize', handleResize);\n    }, []);\n    \n    return size;\n}\n```\n\n### React Router\n\n```javascript\nimport { BrowserRouter, Routes, Route, Link, useNavigate, useParams } from 'react-router-dom';\n\n// Main app with routes\nfunction App() {\n    return (\n        <BrowserRouter>\n            <nav>\n                <Link to=\"/\">Home</Link>\n                <Link to=\"/about\">About</Link>\n                <Link to=\"/users\">Users</Link>\n            </nav>\n            \n            <Routes>\n                <Route path=\"/\" element={<Home />} />\n                <Route path=\"/about\" element={<About />} />\n                <Route path=\"/users\" element={<Users />} />\n                <Route path=\"/users/:id\" element={<UserDetail />} />\n                <Route path=\"*\" element={<NotFound />} />\n            </Routes>\n        </BrowserRouter>\n    );\n}\n\n// Component with URL parameters\nfunction UserDetail() {\n    const { id } = useParams();  // Get URL parameter\n    const navigate = useNavigate();  // Programmatic navigation\n    \n    return (\n        <div>\n            <h2>User ID: {id}</h2>\n            <button onClick={() => navigate('/users')}>Back to Users</button>\n        </div>\n    );\n}\n\n// Protected route example\nfunction ProtectedRoute({ children }) {\n    const isAuthenticated = useAuth();\n    \n    if (!isAuthenticated) {\n        return <Navigate to=\"/login\" />;\n    }\n    \n    return children;\n}\n```\n\n### State Management with Redux Toolkit\n\n```javascript\n// Redux Toolkit slice\nimport { createSlice, configureStore } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n    name: 'counter',\n    initialState: { value: 0 },\n    reducers: {\n        increment: (state) => {\n            state.value += 1;  // Redux Toolkit uses Immer for mutations\n        },\n        decrement: (state) => {\n            state.value -= 1;\n        },\n        incrementByAmount: (state, action) => {\n            state.value += action.payload;\n        }\n    }\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// Configure store\nconst store = configureStore({\n    reducer: {\n        counter: counterSlice.reducer\n    }\n});\n\n// React component using Redux\nimport { useSelector, useDispatch } from 'react-redux';\n\nfunction Counter() {\n    const count = useSelector((state) => state.counter.value);\n    const dispatch = useDispatch();\n    \n    return (\n        <div>\n            <h2>Count: {count}</h2>\n            <button onClick={() => dispatch(increment())}>+</button>\n            <button onClick={() => dispatch(decrement())}>-</button>\n            <button onClick={() => dispatch(incrementByAmount(5))}>+5</button>\n        </div>\n    );\n}\n```\n\n---\n\n## 17. ï¿½ï¸ Angular Framework\n\n**Angular is a comprehensive TypeScript-based framework for building scalable web applications, featuring dependency injection, RxJS observables, and a powerful CLI.** Unlike React (library), Angular is a full-fledged framework providing routing, forms, HTTP client, and more out of the box. Understanding components, services, directives, and RxJS is essential for Angular development.\n\n### Angular Components\n\n```typescript\n// app.component.ts - Basic component\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n  title = 'My Angular App';\n  count = 0;\n  users: User[] = [];\n  \n  ngOnInit() {\n    // Lifecycle hook - runs after component initialization\n    console.log('Component initialized');\n    this.loadUsers();\n  }\n  \n  increment() {\n    this.count++;\n  }\n  \n  decrement() {\n    this.count--;\n  }\n  \n  loadUsers() {\n    this.users = [\n      { id: 1, name: 'Alice', email: 'alice@example.com' },\n      { id: 2, name: 'Bob', email: 'bob@example.com' }\n    ];\n  }\n}\n\n// app.component.html - Template\n/*\n<div class=\"container\">\n  <h1>{{ title }}</h1>\n  \n  <!-- Data binding -->\n  <p>Count: {{ count }}</p>\n  \n  <!-- Event binding -->\n  <button (click)=\"increment()\">+</button>\n  <button (click)=\"decrement()\">-</button>\n  \n  <!-- Two-way binding -->\n  <input [(ngModel)]=\"title\" />\n  \n  <!-- Structural directives -->\n  <div *ngIf=\"count > 0\">Count is positive</div>\n  \n  <ul>\n    <li *ngFor=\"let user of users; let i = index\">\n      {{ i + 1 }}. {{ user.name }} ({{ user.email }})\n    </li>\n  </ul>\n</div>\n*/\n\n// Component with Input and Output\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\n\n@Component({\n  selector: 'app-user-card',\n  template: `\n    <div class=\"card\">\n      <h3>{{ user.name }}</h3>\n      <p>{{ user.email }}</p>\n      <button (click)=\"onDelete()\">Delete</button>\n    </div>\n  `\n})\nexport class UserCardComponent {\n  @Input() user!: User;  // Input from parent\n  @Output() delete = new EventEmitter<number>();  // Output to parent\n  \n  onDelete() {\n    this.delete.emit(this.user.id);\n  }\n}\n\n// Parent component usage:\n// <app-user-card [user]=\"user\" (delete)=\"handleDelete($event)\"></app-user-card>\n```\n\n### Angular Services & Dependency Injection\n\n```typescript\n// user.service.ts - Service for API calls\nimport { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, map, retry } from 'rxjs/operators';\n\n@Injectable({\n  providedIn: 'root'  // Singleton service available app-wide\n})\nexport class UserService {\n  private apiUrl = 'https://api.example.com/users';\n  \n  constructor(private http: HttpClient) {}\n  \n  // GET all users\n  getUsers(): Observable<User[]> {\n    return this.http.get<User[]>(this.apiUrl).pipe(\n      retry(2),  // Retry failed requests twice\n      catchError(this.handleError)\n    );\n  }\n  \n  // GET single user\n  getUser(id: number): Observable<User> {\n    return this.http.get<User>(`${this.apiUrl}/${id}`).pipe(\n      catchError(this.handleError)\n    );\n  }\n  \n  // POST create user\n  createUser(user: Partial<User>): Observable<User> {\n    return this.http.post<User>(this.apiUrl, user, {\n      headers: new HttpHeaders({ 'Content-Type': 'application/json' })\n    }).pipe(\n      catchError(this.handleError)\n    );\n  }\n  \n  // PUT update user\n  updateUser(id: number, user: Partial<User>): Observable<User> {\n    return this.http.put<User>(`${this.apiUrl}/${id}`, user).pipe(\n      catchError(this.handleError)\n    );\n  }\n  \n  // DELETE user\n  deleteUser(id: number): Observable<void> {\n    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(\n      catchError(this.handleError)\n    );\n  }\n  \n  private handleError(error: any) {\n    console.error('API Error:', error);\n    return throwError(() => new Error('Something went wrong'));\n  }\n}\n\n// Using service in component\nimport { Component, OnInit } from '@angular/core';\nimport { UserService } from './user.service';\n\n@Component({\n  selector: 'app-user-list',\n  templateUrl: './user-list.component.html'\n})\nexport class UserListComponent implements OnInit {\n  users: User[] = [];\n  loading = false;\n  error: string | null = null;\n  \n  constructor(private userService: UserService) {}  // Dependency injection\n  \n  ngOnInit() {\n    this.loadUsers();\n  }\n  \n  loadUsers() {\n    this.loading = true;\n    this.userService.getUsers().subscribe({\n      next: (users) => {\n        this.users = users;\n        this.loading = false;\n      },\n      error: (error) => {\n        this.error = error.message;\n        this.loading = false;\n      }\n    });\n  }\n  \n  deleteUser(id: number) {\n    this.userService.deleteUser(id).subscribe({\n      next: () => {\n        this.users = this.users.filter(u => u.id !== id);\n      },\n      error: (error) => console.error('Delete failed:', error)\n    });\n  }\n}\n```\n\n### RxJS Observables in Angular\n\n```typescript\nimport { Component, OnInit } from '@angular/core';\nimport { Observable, Subject, BehaviorSubject, interval, fromEvent } from 'rxjs';\nimport { map, filter, debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-rxjs-demo',\n  template: `\n    <input #searchInput placeholder=\"Search users...\" />\n    <div *ngFor=\"let user of searchResults$ | async\">\n      {{ user.name }}\n    </div>\n  `\n})\nexport class RxjsDemoComponent implements OnInit {\n  // Observable that emits search results\n  searchResults$!: Observable<User[]>;\n  \n  // Subject - manually emit values\n  private searchSubject = new Subject<string>();\n  \n  // BehaviorSubject - stores current value\n  private currentUser$ = new BehaviorSubject<User | null>(null);\n  \n  constructor(private userService: UserService) {}\n  \n  ngOnInit() {\n    // Search with debounce\n    this.searchResults$ = this.searchSubject.pipe(\n      debounceTime(300),  // Wait 300ms after user stops typing\n      distinctUntilChanged(),  // Only if value changed\n      filter(query => query.length >= 2),  // Minimum 2 characters\n      switchMap(query => this.userService.searchUsers(query))  // Switch to new search\n    );\n  }\n  \n  onSearchInput(event: Event) {\n    const query = (event.target as HTMLInputElement).value;\n    this.searchSubject.next(query);\n  }\n  \n  // Observable operators examples\n  demonstrateOperators() {\n    // Map - transform values\n    interval(1000).pipe(\n      map(n => n * 2)\n    ).subscribe(value => console.log(value));  // 0, 2, 4, 6...\n    \n    // Filter - only even numbers\n    interval(1000).pipe(\n      filter(n => n % 2 === 0)\n    ).subscribe(value => console.log(value));  // 0, 2, 4, 6...\n    \n    // Combine multiple observables\n    const clicks$ = fromEvent(document, 'click');\n    const timer$ = interval(1000);\n    \n    // switchMap - cancel previous, switch to new\n    clicks$.pipe(\n      switchMap(() => timer$)\n    ).subscribe(value => console.log(value));\n  }\n}\n\n// Custom Observable\nimport { Observable } from 'rxjs';\n\nfunction createCustomObservable(): Observable<number> {\n  return new Observable(subscriber => {\n    let count = 0;\n    \n    const interval = setInterval(() => {\n      count++;\n      subscriber.next(count);  // Emit value\n      \n      if (count === 5) {\n        subscriber.complete();  // Complete observable\n        clearInterval(interval);\n      }\n    }, 1000);\n    \n    // Cleanup function\n    return () => {\n      clearInterval(interval);\n    };\n  });\n}\n\n// Usage\ncreateCustomObservable().subscribe({\n  next: (value) => console.log('Value:', value),\n  error: (error) => console.error('Error:', error),\n  complete: () => console.log('Complete!')\n});\n```\n\n### Angular Routing\n\n```typescript\n// app-routing.module.ts\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { UserListComponent } from './users/user-list.component';\nimport { UserDetailComponent } from './users/user-detail.component';\nimport { LoginComponent } from './auth/login.component';\nimport { AuthGuard } from './auth/auth.guard';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'login', component: LoginComponent },\n  { \n    path: 'users', \n    component: UserListComponent,\n    canActivate: [AuthGuard]  // Protected route\n  },\n  { \n    path: 'users/:id', \n    component: UserDetailComponent,\n    canActivate: [AuthGuard]\n  },\n  { path: '**', redirectTo: '' }  // 404 redirect\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}\n\n// auth.guard.ts - Route guard\nimport { Injectable } from '@angular/core';\nimport { CanActivate, Router } from '@angular/router';\nimport { AuthService } from './auth.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  constructor(\n    private authService: AuthService,\n    private router: Router\n  ) {}\n  \n  canActivate(): boolean {\n    if (this.authService.isAuthenticated()) {\n      return true;\n    }\n    \n    this.router.navigate(['/login']);\n    return false;\n  }\n}\n\n// Navigation in component\nimport { Component } from '@angular/core';\nimport { Router, ActivatedRoute } from '@angular/router';\n\n@Component({\n  selector: 'app-user-detail',\n  template: '<div>User Detail</div>'\n})\nexport class UserDetailComponent {\n  constructor(\n    private router: Router,\n    private route: ActivatedRoute\n  ) {\n    // Get route parameters\n    this.route.params.subscribe(params => {\n      const userId = params['id'];\n      console.log('User ID:', userId);\n    });\n    \n    // Get query parameters\n    this.route.queryParams.subscribe(params => {\n      const page = params['page'];\n      console.log('Page:', page);\n    });\n  }\n  \n  navigateToUsers() {\n    this.router.navigate(['/users']);\n  }\n  \n  navigateWithParams() {\n    this.router.navigate(['/users', 123], { \n      queryParams: { page: 2 }\n    });\n  }\n}\n```\n\n### Angular Forms\n\n```typescript\n// Reactive Forms (Recommended)\nimport { Component, OnInit } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators, FormArray } from '@angular/forms';\n\n@Component({\n  selector: 'app-user-form',\n  template: `\n    <form [formGroup]=\"userForm\" (ngSubmit)=\"onSubmit()\">\n      <input formControlName=\"name\" placeholder=\"Name\" />\n      <div *ngIf=\"name?.invalid && name?.touched\">\n        <span *ngIf=\"name?.errors?.['required']\">Name is required</span>\n        <span *ngIf=\"name?.errors?.['minlength']\">Min 2 characters</span>\n      </div>\n      \n      <input formControlName=\"email\" placeholder=\"Email\" type=\"email\" />\n      <div *ngIf=\"email?.invalid && email?.touched\">\n        <span *ngIf=\"email?.errors?.['required']\">Email is required</span>\n        <span *ngIf=\"email?.errors?.['email']\">Invalid email</span>\n      </div>\n      \n      <input formControlName=\"age\" placeholder=\"Age\" type=\"number\" />\n      \n      <!-- Form Array - Dynamic fields -->\n      <div formArrayName=\"hobbies\">\n        <div *ngFor=\"let hobby of hobbies.controls; let i = index\">\n          <input [formControlName]=\"i\" placeholder=\"Hobby\" />\n          <button type=\"button\" (click)=\"removeHobby(i)\">Remove</button>\n        </div>\n      </div>\n      <button type=\"button\" (click)=\"addHobby()\">Add Hobby</button>\n      \n      <button type=\"submit\" [disabled]=\"userForm.invalid\">Submit</button>\n    </form>\n  `\n})\nexport class UserFormComponent implements OnInit {\n  userForm!: FormGroup;\n  \n  constructor(private fb: FormBuilder) {}\n  \n  ngOnInit() {\n    this.userForm = this.fb.group({\n      name: ['', [Validators.required, Validators.minLength(2)]],\n      email: ['', [Validators.required, Validators.email]],\n      age: [0, [Validators.required, Validators.min(0), Validators.max(150)]],\n      hobbies: this.fb.array([])\n    });\n  }\n  \n  get name() {\n    return this.userForm.get('name');\n  }\n  \n  get email() {\n    return this.userForm.get('email');\n  }\n  \n  get hobbies() {\n    return this.userForm.get('hobbies') as FormArray;\n  }\n  \n  addHobby() {\n    this.hobbies.push(this.fb.control(''));\n  }\n  \n  removeHobby(index: number) {\n    this.hobbies.removeAt(index);\n  }\n  \n  onSubmit() {\n    if (this.userForm.valid) {\n      console.log('Form value:', this.userForm.value);\n    }\n  }\n}\n\n// Template-driven Forms (Simpler)\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-simple-form',\n  template: `\n    <form #userForm=\"ngForm\" (ngSubmit)=\"onSubmit(userForm)\">\n      <input \n        name=\"name\" \n        [(ngModel)]=\"user.name\" \n        required \n        minlength=\"2\"\n        #name=\"ngModel\"\n      />\n      <div *ngIf=\"name.invalid && name.touched\">\n        Name is required (min 2 chars)\n      </div>\n      \n      <input \n        name=\"email\" \n        [(ngModel)]=\"user.email\" \n        required \n        email\n        #email=\"ngModel\"\n      />\n      <div *ngIf=\"email.invalid && email.touched\">\n        Valid email is required\n      </div>\n      \n      <button type=\"submit\" [disabled]=\"userForm.invalid\">Submit</button>\n    </form>\n  `\n})\nexport class SimpleFormComponent {\n  user = { name: '', email: '' };\n  \n  onSubmit(form: any) {\n    console.log('Form value:', form.value);\n  }\n}\n```\n\n### Angular Directives\n\n```typescript\n// Custom Attribute Directive\nimport { Directive, ElementRef, HostListener, Input } from '@angular/core';\n\n@Directive({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n  @Input() appHighlight = 'yellow';  // Default color\n  \n  constructor(private el: ElementRef) {}\n  \n  @HostListener('mouseenter') onMouseEnter() {\n    this.highlight(this.appHighlight);\n  }\n  \n  @HostListener('mouseleave') onMouseLeave() {\n    this.highlight('');\n  }\n  \n  private highlight(color: string) {\n    this.el.nativeElement.style.backgroundColor = color;\n  }\n}\n\n// Usage: <p appHighlight=\"lightblue\">Hover over me!</p>\n\n// Structural Directive\nimport { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';\n\n@Directive({\n  selector: '[appUnless]'\n})\nexport class UnlessDirective {\n  constructor(\n    private templateRef: TemplateRef<any>,\n    private viewContainer: ViewContainerRef\n  ) {}\n  \n  @Input() set appUnless(condition: boolean) {\n    if (!condition) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n    } else {\n      this.viewContainer.clear();\n    }\n  }\n}\n\n// Usage: <div *appUnless=\"condition\">Content shown when condition is false</div>\n```\n\n---\n\n## 18. ï¿½ðŸŽ¨ Design Patterns in JavaScript\n\n**Design patterns are reusable solutions to common programming problems, improving code organization and maintainability.** JavaScript supports various design patterns including Singleton, Factory, Observer, Module, and Strategy patterns. Understanding these patterns is essential for building scalable applications and acing technical interviews.\n\n### Singleton Pattern\n\n```javascript\n// Singleton - Ensure only one instance exists\nclass Database {\n    constructor() {\n        if (Database.instance) {\n            return Database.instance;\n        }\n        \n        this.connection = null;\n        this.isConnected = false;\n        Database.instance = this;\n    }\n    \n    connect() {\n        if (!this.isConnected) {\n            this.connection = 'Connected to database';\n            this.isConnected = true;\n            console.log('Database connected');\n        }\n        return this.connection;\n    }\n    \n    disconnect() {\n        this.isConnected = false;\n        this.connection = null;\n        console.log('Database disconnected');\n    }\n}\n\n// Usage\nconst db1 = new Database();\nconst db2 = new Database();\nconsole.log(db1 === db2);  // true - same instance\n\n// Modern ES6 singleton\nconst Singleton = (() => {\n    let instance;\n    \n    class SingletonClass {\n        constructor() {\n            if (instance) {\n                return instance;\n            }\n            this.data = [];\n            instance = this;\n        }\n        \n        addData(item) {\n            this.data.push(item);\n        }\n        \n        getData() {\n            return this.data;\n        }\n    }\n    \n    return SingletonClass;\n})();\n```\n\n### Factory Pattern\n\n```javascript\n// Factory - Create objects without specifying exact class\nclass Car {\n    constructor(options) {\n        this.doors = options.doors || 4;\n        this.state = options.state || 'new';\n        this.color = options.color || 'white';\n    }\n}\n\nclass Truck {\n    constructor(options) {\n        this.doors = options.doors || 2;\n        this.state = options.state || 'new';\n        this.wheelSize = options.wheelSize || 'large';\n    }\n}\n\nclass VehicleFactory {\n    createVehicle(type, options) {\n        switch(type) {\n            case 'car':\n                return new Car(options);\n            case 'truck':\n                return new Truck(options);\n            default:\n                throw new Error('Unknown vehicle type');\n        }\n    }\n}\n\n// Usage\nconst factory = new VehicleFactory();\nconst myCar = factory.createVehicle('car', { color: 'blue', doors: 4 });\nconst myTruck = factory.createVehicle('truck', { wheelSize: 'extra-large' });\n\n// Modern factory with classes\nclass UserFactory {\n    static createUser(type, data) {\n        const users = {\n            admin: () => new AdminUser(data),\n            regular: () => new RegularUser(data),\n            guest: () => new GuestUser(data)\n        };\n        \n        return users[type] ? users[type]() : null;\n    }\n}\n\nclass AdminUser {\n    constructor(data) {\n        this.name = data.name;\n        this.role = 'admin';\n        this.permissions = ['read', 'write', 'delete'];\n    }\n}\n\nclass RegularUser {\n    constructor(data) {\n        this.name = data.name;\n        this.role = 'user';\n        this.permissions = ['read', 'write'];\n    }\n}\n```\n\n### Observer Pattern (Pub/Sub)\n\n```javascript\n// Observer - Notify multiple objects about state changes\nclass EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    \n    on(event, listener) {\n        if (!this.events[event]) {\n            this.events[event] = [];\n        }\n        this.events[event].push(listener);\n    }\n    \n    emit(event, ...args) {\n        if (this.events[event]) {\n            this.events[event].forEach(listener => listener(...args));\n        }\n    }\n    \n    off(event, listenerToRemove) {\n        if (this.events[event]) {\n            this.events[event] = this.events[event].filter(\n                listener => listener !== listenerToRemove\n            );\n        }\n    }\n}\n\n// Usage\nconst emitter = new EventEmitter();\n\n// Subscribe to events\nemitter.on('userLoggedIn', (user) => {\n    console.log(`Welcome ${user.name}!`);\n});\n\nemitter.on('userLoggedIn', (user) => {\n    console.log(`Logging: User ${user.id} logged in`);\n});\n\n// Emit event\nemitter.emit('userLoggedIn', { id: 1, name: 'Alice' });\n// Output:\n// Welcome Alice!\n// Logging: User 1 logged in\n\n// Real-world example: Shopping cart\nclass ShoppingCart {\n    constructor() {\n        this.items = [];\n        this.observers = [];\n    }\n    \n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n    \n    notify(event, data) {\n        this.observers.forEach(observer => observer.update(event, data));\n    }\n    \n    addItem(item) {\n        this.items.push(item);\n        this.notify('itemAdded', { item, total: this.getTotal() });\n    }\n    \n    removeItem(itemId) {\n        this.items = this.items.filter(item => item.id !== itemId);\n        this.notify('itemRemoved', { itemId, total: this.getTotal() });\n    }\n    \n    getTotal() {\n        return this.items.reduce((sum, item) => sum + item.price, 0);\n    }\n}\n\n// Observers\nclass CartDisplay {\n    update(event, data) {\n        console.log(`Display: ${event}`, data);\n    }\n}\n\nclass CartAnalytics {\n    update(event, data) {\n        console.log(`Analytics: Tracking ${event}`, data);\n    }\n}\n\n// Usage\nconst cart = new ShoppingCart();\ncart.subscribe(new CartDisplay());\ncart.subscribe(new CartAnalytics());\n\ncart.addItem({ id: 1, name: 'Book', price: 20 });\n```\n\n### Module Pattern\n\n```javascript\n// Module - Encapsulate private data\nconst CounterModule = (() => {\n    // Private variables\n    let count = 0;\n    \n    // Private method\n    function logCount() {\n        console.log(`Current count: ${count}`);\n    }\n    \n    // Public API\n    return {\n        increment() {\n            count++;\n            logCount();\n        },\n        decrement() {\n            count--;\n            logCount();\n        },\n        getCount() {\n            return count;\n        },\n        reset() {\n            count = 0;\n            logCount();\n        }\n    };\n})();\n\n// Usage\nCounterModule.increment();  // Current count: 1\nCounterModule.increment();  // Current count: 2\nconsole.log(CounterModule.getCount());  // 2\n// console.log(CounterModule.count);  // undefined - private variable\n\n// Modern ES6 module\nclass UserService {\n    #users = [];  // Private field (ES2022)\n    \n    addUser(user) {\n        this.#users.push(user);\n        this.#notifyObservers();\n    }\n    \n    #notifyObservers() {\n        console.log('User list updated');\n    }\n    \n    getUsers() {\n        return [...this.#users];  // Return copy\n    }\n}\n```\n\n### Strategy Pattern\n\n```javascript\n// Strategy - Define family of algorithms, make them interchangeable\nclass PaymentStrategy {\n    pay(amount) {\n        throw new Error('pay() must be implemented');\n    }\n}\n\nclass CreditCardPayment extends PaymentStrategy {\n    constructor(cardNumber) {\n        super();\n        this.cardNumber = cardNumber;\n    }\n    \n    pay(amount) {\n        console.log(`Paid $${amount} with credit card ${this.cardNumber}`);\n        return { success: true, method: 'credit-card', amount };\n    }\n}\n\nclass PayPalPayment extends PaymentStrategy {\n    constructor(email) {\n        super();\n        this.email = email;\n    }\n    \n    pay(amount) {\n        console.log(`Paid $${amount} via PayPal account ${this.email}`);\n        return { success: true, method: 'paypal', amount };\n    }\n}\n\nclass CryptoPayment extends PaymentStrategy {\n    constructor(walletAddress) {\n        super();\n        this.walletAddress = walletAddress;\n    }\n    \n    pay(amount) {\n        console.log(`Paid $${amount} via crypto wallet ${this.walletAddress}`);\n        return { success: true, method: 'crypto', amount };\n    }\n}\n\nclass ShoppingCart {\n    constructor(paymentStrategy) {\n        this.paymentStrategy = paymentStrategy;\n        this.items = [];\n    }\n    \n    setPaymentStrategy(strategy) {\n        this.paymentStrategy = strategy;\n    }\n    \n    checkout() {\n        const amount = this.calculateTotal();\n        return this.paymentStrategy.pay(amount);\n    }\n    \n    calculateTotal() {\n        return this.items.reduce((sum, item) => sum + item.price, 0);\n    }\n}\n\n// Usage\nconst cart = new ShoppingCart(new CreditCardPayment('1234-5678-9012-3456'));\ncart.items = [{ name: 'Book', price: 20 }, { name: 'Pen', price: 5 }];\ncart.checkout();  // Paid $25 with credit card\n\n// Switch payment strategy\ncart.setPaymentStrategy(new PayPalPayment('user@example.com'));\ncart.checkout();  // Paid $25 via PayPal\n```\n\n### Decorator Pattern\n\n```javascript\n// Decorator - Add functionality to objects dynamically\nclass Coffee {\n    cost() {\n        return 5;\n    }\n    \n    description() {\n        return 'Simple coffee';\n    }\n}\n\n// Decorators\nclass MilkDecorator {\n    constructor(coffee) {\n        this.coffee = coffee;\n    }\n    \n    cost() {\n        return this.coffee.cost() + 2;\n    }\n    \n    description() {\n        return this.coffee.description() + ', milk';\n    }\n}\n\nclass SugarDecorator {\n    constructor(coffee) {\n        this.coffee = coffee;\n    }\n    \n    cost() {\n        return this.coffee.cost() + 1;\n    }\n    \n    description() {\n        return this.coffee.description() + ', sugar';\n    }\n}\n\nclass WhipDecorator {\n    constructor(coffee) {\n        this.coffee = coffee;\n    }\n    \n    cost() {\n        return this.coffee.cost() + 3;\n    }\n    \n    description() {\n        return this.coffee.description() + ', whipped cream';\n    }\n}\n\n// Usage\nlet myCoffee = new Coffee();\nconsole.log(myCoffee.description(), `$${myCoffee.cost()}`);  \n// Simple coffee $5\n\nmyCoffee = new MilkDecorator(myCoffee);\nmyCoffee = new SugarDecorator(myCoffee);\nmyCoffee = new WhipDecorator(myCoffee);\n\nconsole.log(myCoffee.description(), `$${myCoffee.cost()}`);  \n// Simple coffee, milk, sugar, whipped cream $11\n\n// Modern decorator with functions\nfunction withLogging(fn) {\n    return function(...args) {\n        console.log(`Calling ${fn.name} with:`, args);\n        const result = fn(...args);\n        console.log(`Result:`, result);\n        return result;\n    };\n}\n\nfunction add(a, b) {\n    return a + b;\n}\n\nconst addWithLogging = withLogging(add);\naddWithLogging(5, 3);\n// Output:\n// Calling add with: [5, 3]\n// Result: 8\n```\n\n---\n\n## 19. ðŸ”’ Security Best Practices\n\n**Web security is critical for protecting user data and preventing attacks like XSS, CSRF, and SQL injection.** Understanding common vulnerabilities and implementing proper security measures is essential for professional web development. Always validate input, sanitize output, use HTTPS, and follow the principle of least privilege.\n\n### Cross-Site Scripting (XSS) Prevention\n\n```javascript\n// âŒ Vulnerable to XSS\nfunction displayUserInput(input) {\n    document.getElementById('output').innerHTML = input;  // DANGEROUS!\n    // If input = \"<img src=x onerror='alert(document.cookie)'>\"\n    // This will execute malicious JavaScript\n}\n\n// âœ… Prevent XSS by escaping HTML\nfunction escapeHtml(unsafe) {\n    return unsafe\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}\n\nfunction displayUserInputSafely(input) {\n    const escaped = escapeHtml(input);\n    document.getElementById('output').textContent = escaped;  // Safe\n}\n\n// Using DOMPurify library (recommended for production)\nimport DOMPurify from 'dompurify';\n\nfunction displayRichContent(html) {\n    const clean = DOMPurify.sanitize(html);\n    document.getElementById('output').innerHTML = clean;\n}\n\n// Content Security Policy (CSP) header\n// Set in your server or meta tag:\n// <meta http-equiv=\"Content-Security-Policy\" \n//       content=\"default-src 'self'; script-src 'self' https://trusted.com\">\n```\n\n### CSRF Protection\n\n```javascript\n// Cross-Site Request Forgery prevention\n\n// Generate CSRF token (server-side)\nconst crypto = require('crypto');\n\nfunction generateCSRFToken() {\n    return crypto.randomBytes(32).toString('hex');\n}\n\n// Store token in session\napp.get('/form', (req, res) => {\n    req.session.csrfToken = generateCSRFToken();\n    res.render('form', { csrfToken: req.session.csrfToken });\n});\n\n// Verify token on submission\napp.post('/submit', (req, res) => {\n    const token = req.body.csrfToken;\n    if (token !== req.session.csrfToken) {\n        return res.status(403).json({ error: 'Invalid CSRF token' });\n    }\n    // Process form...\n});\n\n// Client-side: Include token in forms\n// <form method=\"POST\" action=\"/submit\">\n//     <input type=\"hidden\" name=\"csrfToken\" value=\"<%= csrfToken %>\">\n//     <!-- other fields -->\n// </form>\n\n// For AJAX requests\nfetch('/api/data', {\n    method: 'POST',\n    headers: {\n        'X-CSRF-Token': getCsrfToken(),  // Get from cookie or meta tag\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(data)\n});\n```\n\n### Authentication with JWT\n\n```javascript\n// JSON Web Token authentication\nconst express = require('express');\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\n\nconst app = express();\nconst SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key-change-this';\n\n// Register user\napp.post('/register', async (req, res) => {\n    try {\n        const { username, password } = req.body;\n        \n        // Validate input\n        if (!username || !password || password.length < 8) {\n            return res.status(400).json({ error: 'Invalid credentials' });\n        }\n        \n        // Hash password\n        const saltRounds = 10;\n        const hashedPassword = await bcrypt.hash(password, saltRounds);\n        \n        // Save user to database (example)\n        const user = await User.create({\n            username,\n            password: hashedPassword\n        });\n        \n        res.status(201).json({ message: 'User registered successfully' });\n    } catch (error) {\n        res.status(500).json({ error: 'Registration failed' });\n    }\n});\n\n// Login user\napp.post('/login', async (req, res) => {\n    try {\n        const { username, password } = req.body;\n        \n        // Find user\n        const user = await User.findOne({ username });\n        if (!user) {\n            return res.status(401).json({ error: 'Invalid credentials' });\n        }\n        \n        // Verify password\n        const isValid = await bcrypt.compare(password, user.password);\n        if (!isValid) {\n            return res.status(401).json({ error: 'Invalid credentials' });\n        }\n        \n        // Generate JWT\n        const token = jwt.sign(\n            { userId: user.id, username: user.username },\n            SECRET_KEY,\n            { expiresIn: '24h' }\n        );\n        \n        res.json({ token, user: { id: user.id, username: user.username } });\n    } catch (error) {\n        res.status(500).json({ error: 'Login failed' });\n    }\n});\n\n// Middleware to verify JWT\nfunction authenticateToken(req, res, next) {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1];  // Bearer TOKEN\n    \n    if (!token) {\n        return res.status(401).json({ error: 'Access token required' });\n    }\n    \n    jwt.verify(token, SECRET_KEY, (err, user) => {\n        if (err) {\n            return res.status(403).json({ error: 'Invalid token' });\n        }\n        req.user = user;\n        next();\n    });\n}\n\n// Protected route\napp.get('/api/profile', authenticateToken, (req, res) => {\n    res.json({ user: req.user });\n});\n\n// Refresh token implementation\napp.post('/refresh', (req, res) => {\n    const { refreshToken } = req.body;\n    \n    // Verify refresh token\n    jwt.verify(refreshToken, REFRESH_SECRET, (err, user) => {\n        if (err) {\n            return res.status(403).json({ error: 'Invalid refresh token' });\n        }\n        \n        // Generate new access token\n        const accessToken = jwt.sign(\n            { userId: user.userId, username: user.username },\n            SECRET_KEY,\n            { expiresIn: '15m' }\n        );\n        \n        res.json({ accessToken });\n    });\n});\n```\n\n### Input Validation and Sanitization\n\n```javascript\n// Input validation with Joi\nconst Joi = require('joi');\n\nconst userSchema = Joi.object({\n    username: Joi.string()\n        .alphanum()\n        .min(3)\n        .max(30)\n        .required(),\n    email: Joi.string()\n        .email()\n        .required(),\n    password: Joi.string()\n        .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/)\n        .required()\n        .messages({\n            'string.pattern.base': 'Password must contain uppercase, lowercase, number, and special character'\n        }),\n    age: Joi.number()\n        .integer()\n        .min(18)\n        .max(120)\n});\n\napp.post('/api/users', (req, res) => {\n    // Validate input\n    const { error, value } = userSchema.validate(req.body);\n    \n    if (error) {\n        return res.status(400).json({ error: error.details[0].message });\n    }\n    \n    // Process validated data\n    createUser(value);\n    res.status(201).json({ message: 'User created' });\n});\n\n// SQL Injection prevention (use parameterized queries)\n// âŒ Vulnerable\nconst userId = req.params.id;\nconst query = `SELECT * FROM users WHERE id = ${userId}`;  // DANGEROUS!\n\n// âœ… Safe - use parameterized queries\nconst query = 'SELECT * FROM users WHERE id = ?';\ndb.execute(query, [userId]);\n\n// With MongoDB (use ORM/ODM like Mongoose)\n// âŒ Vulnerable\nUser.find({ username: req.body.username });  // Can be exploited with $ne, $gt, etc.\n\n// âœ… Safe - validate input type\nconst username = String(req.body.username);  // Ensure it's a string\nUser.find({ username: username });\n```\n\n### CORS Configuration\n\n```javascript\n// CORS (Cross-Origin Resource Sharing) setup\nconst express = require('express');\nconst cors = require('cors');\n\nconst app = express();\n\n// Simple CORS - Allow all origins (NOT recommended for production)\napp.use(cors());\n\n// Configured CORS - Production recommended\nconst corsOptions = {\n    origin: ['https://yourdomain.com', 'https://app.yourdomain.com'],\n    methods: ['GET', 'POST', 'PUT', 'DELETE'],\n    allowedHeaders: ['Content-Type', 'Authorization'],\n    credentials: true,  // Allow cookies\n    maxAge: 86400  // Cache preflight request for 24 hours\n};\n\napp.use(cors(corsOptions));\n\n// Dynamic CORS based on request\napp.use(cors((req, callback) => {\n    const allowedOrigins = ['https://yourdomain.com', 'https://app.yourdomain.com'];\n    const origin = req.header('Origin');\n    \n    if (allowedOrigins.includes(origin)) {\n        callback(null, { origin: true });\n    } else {\n        callback(new Error('Not allowed by CORS'));\n    }\n}));\n\n// Manual CORS headers\napp.use((req, res, next) => {\n    res.header('Access-Control-Allow-Origin', 'https://yourdomain.com');\n    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    res.header('Access-Control-Allow-Credentials', 'true');\n    \n    // Handle preflight\n    if (req.method === 'OPTIONS') {\n        return res.sendStatus(200);\n    }\n    \n    next();\n});\n```\n\n### Security Headers\n\n```javascript\n// Set security headers with Helmet\nconst helmet = require('helmet');\n\napp.use(helmet());\n\n// Custom security headers\napp.use(helmet({\n    contentSecurityPolicy: {\n        directives: {\n            defaultSrc: [\"'self'\"],\n            scriptSrc: [\"'self'\", \"'unsafe-inline'\", \"https://trusted-cdn.com\"],\n            styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n            imgSrc: [\"'self'\", \"data:\", \"https:\"],\n            connectSrc: [\"'self'\", \"https://api.yourdomain.com\"],\n            fontSrc: [\"'self'\", \"https:\", \"data:\"],\n            objectSrc: [\"'none'\"],\n            mediaSrc: [\"'self'\"],\n            frameSrc: [\"'none'\"]\n        }\n    },\n    hsts: {\n        maxAge: 31536000,  // 1 year\n        includeSubDomains: true,\n        preload: true\n    }\n}));\n\n// Rate limiting to prevent brute force\nconst rateLimit = require('express-rate-limit');\n\nconst limiter = rateLimit({\n    windowMs: 15 * 60 * 1000,  // 15 minutes\n    max: 100,  // Limit each IP to 100 requests per windowMs\n    message: 'Too many requests, please try again later'\n});\n\napp.use('/api/', limiter);\n\n// Stricter limit for authentication endpoints\nconst authLimiter = rateLimit({\n    windowMs: 15 * 60 * 1000,\n    max: 5,  // Only 5 login attempts per 15 minutes\n    message: 'Too many login attempts, please try again later'\n});\n\napp.use('/api/login', authLimiter);\napp.use('/api/register', authLimiter);\n```\n\n---\n\n## 20. ðŸ”Œ WebSockets & Real-time Communication\n\n**WebSockets provide full-duplex communication channels over a single TCP connection, enabling real-time data transfer between client and server.** Unlike HTTP polling, WebSockets maintain persistent connections for instant, bidirectional communication. This is essential for chat applications, live notifications, real-time dashboards, and multiplayer games.\n\n### Native WebSocket API\n\n```javascript\n// Client-side WebSocket\nconst socket = new WebSocket('ws://localhost:8080');\n\n// Connection opened\nsocket.addEventListener('open', (event) => {\n    console.log('Connected to WebSocket server');\n    socket.send(JSON.stringify({ type: 'greeting', message: 'Hello Server!' }));\n});\n\n// Listen for messages\nsocket.addEventListener('message', (event) => {\n    console.log('Message from server:', event.data);\n    const data = JSON.parse(event.data);\n    \n    if (data.type === 'notification') {\n        showNotification(data.message);\n    }\n});\n\n// Connection closed\nsocket.addEventListener('close', (event) => {\n    console.log('Disconnected from server');\n    // Attempt to reconnect\n    setTimeout(() => connectWebSocket(), 1000);\n});\n\n// Handle errors\nsocket.addEventListener('error', (error) => {\n    console.error('WebSocket error:', error);\n});\n\n// Send messages\nfunction sendMessage(message) {\n    if (socket.readyState === WebSocket.OPEN) {\n        socket.send(JSON.stringify({ type: 'message', content: message }));\n    } else {\n        console.error('WebSocket is not open');\n    }\n}\n\n// Close connection\nfunction closeConnection() {\n    socket.close(1000, 'Client closing connection');\n}\n```\n\n### WebSocket Server with Node.js\n\n```javascript\n// Server-side WebSocket with 'ws' library\nconst WebSocket = require('ws');\nconst http = require('http');\n\nconst server = http.createServer();\nconst wss = new WebSocket.Server({ server });\n\n// Store connected clients\nconst clients = new Set();\n\nwss.on('connection', (ws, req) => {\n    console.log('New client connected');\n    clients.add(ws);\n    \n    // Send welcome message\n    ws.send(JSON.stringify({\n        type: 'welcome',\n        message: 'Connected to server',\n        clientCount: clients.size\n    }));\n    \n    // Broadcast to all clients\n    broadcastMessage({ type: 'userJoined', count: clients.size });\n    \n    // Handle messages from client\n    ws.on('message', (data) => {\n        try {\n            const message = JSON.parse(data);\n            console.log('Received:', message);\n            \n            // Echo message to all clients\n            broadcastMessage({\n                type: 'message',\n                content: message.content,\n                timestamp: new Date().toISOString()\n            });\n        } catch (error) {\n            console.error('Error parsing message:', error);\n        }\n    });\n    \n    // Handle client disconnect\n    ws.on('close', () => {\n        console.log('Client disconnected');\n        clients.delete(ws);\n        broadcastMessage({ type: 'userLeft', count: clients.size });\n    });\n    \n    // Handle errors\n    ws.on('error', (error) => {\n        console.error('WebSocket error:', error);\n        clients.delete(ws);\n    });\n});\n\n// Broadcast to all connected clients\nfunction broadcastMessage(message) {\n    const data = JSON.stringify(message);\n    clients.forEach(client => {\n        if (client.readyState === WebSocket.OPEN) {\n            client.send(data);\n        }\n    });\n}\n\n// Start server\nserver.listen(8080, () => {\n    console.log('WebSocket server running on port 8080');\n});\n```\n\n### Socket.IO (Advanced WebSocket Library)\n\n```javascript\n// Socket.IO Client\nimport io from 'socket.io-client';\n\nconst socket = io('http://localhost:3000', {\n    auth: {\n        token: 'your-auth-token'\n    }\n});\n\n// Connect event\nsocket.on('connect', () => {\n    console.log('Connected:', socket.id);\n});\n\n// Listen for events\nsocket.on('message', (data) => {\n    console.log('Received message:', data);\n});\n\nsocket.on('notification', (data) => {\n    showNotification(data.title, data.body);\n});\n\n// Send events\nsocket.emit('sendMessage', { to: 'user123', message: 'Hello!' });\n\n// Room-based communication\nsocket.emit('joinRoom', 'room-1');\nsocket.on('roomMessage', (data) => {\n    console.log('Room message:', data);\n});\n\n// Disconnect\nsocket.on('disconnect', (reason) => {\n    console.log('Disconnected:', reason);\n    if (reason === 'io server disconnect') {\n        // Manually reconnect\n        socket.connect();\n    }\n});\n\n// Socket.IO Server\nconst express = require('express');\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server, {\n    cors: {\n        origin: 'http://localhost:3000',\n        methods: ['GET', 'POST']\n    }\n});\n\n// Middleware for authentication\nio.use((socket, next) => {\n    const token = socket.handshake.auth.token;\n    if (isValidToken(token)) {\n        socket.userId = getUserIdFromToken(token);\n        next();\n    } else {\n        next(new Error('Authentication error'));\n    }\n});\n\n// Connection handling\nio.on('connection', (socket) => {\n    console.log('User connected:', socket.userId);\n    \n    // Join user to their personal room\n    socket.join(`user-${socket.userId}`);\n    \n    // Handle events\n    socket.on('sendMessage', (data) => {\n        // Send to specific user\n        io.to(`user-${data.to}`).emit('message', {\n            from: socket.userId,\n            message: data.message,\n            timestamp: new Date()\n        });\n    });\n    \n    // Room management\n    socket.on('joinRoom', (roomId) => {\n        socket.join(roomId);\n        socket.to(roomId).emit('userJoined', {\n            userId: socket.userId,\n            roomId\n        });\n    });\n    \n    socket.on('leaveRoom', (roomId) => {\n        socket.leave(roomId);\n        socket.to(roomId).emit('userLeft', {\n            userId: socket.userId,\n            roomId\n        });\n    });\n    \n    // Broadcast to room\n    socket.on('roomMessage', (data) => {\n        io.to(data.roomId).emit('roomMessage', {\n            from: socket.userId,\n            message: data.message,\n            timestamp: new Date()\n        });\n    });\n    \n    // Disconnect\n    socket.on('disconnect', (reason) => {\n        console.log('User disconnected:', socket.userId, reason);\n    });\n});\n\nserver.listen(3000, () => {\n    console.log('Socket.IO server running on port 3000');\n});\n```\n\n### Real-time Chat Application\n\n```javascript\n// Complete chat application with React + Socket.IO\n\n// ChatApp.jsx\nimport React, { useState, useEffect, useRef } from 'react';\nimport io from 'socket.io-client';\n\nfunction ChatApp() {\n    const [socket, setSocket] = useState(null);\n    const [messages, setMessages] = useState([]);\n    const [inputMessage, setInputMessage] = useState('');\n    const [username, setUsername] = useState('');\n    const [isConnected, setIsConnected] = useState(false);\n    const [onlineUsers, setOnlineUsers] = useState(0);\n    const messagesEndRef = useRef(null);\n    \n    useEffect(() => {\n        // Initialize socket connection\n        const newSocket = io('http://localhost:3000', {\n            auth: { username: username || 'Anonymous' }\n        });\n        \n        newSocket.on('connect', () => {\n            setIsConnected(true);\n            console.log('Connected to chat server');\n        });\n        \n        newSocket.on('disconnect', () => {\n            setIsConnected(false);\n            console.log('Disconnected from chat server');\n        });\n        \n        newSocket.on('message', (message) => {\n            setMessages(prev => [...prev, message]);\n            scrollToBottom();\n        });\n        \n        newSocket.on('userCount', (count) => {\n            setOnlineUsers(count);\n        });\n        \n        setSocket(newSocket);\n        \n        return () => newSocket.close();\n    }, [username]);\n    \n    const scrollToBottom = () => {\n        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n    };\n    \n    const sendMessage = (e) => {\n        e.preventDefault();\n        \n        if (inputMessage.trim() && socket) {\n            socket.emit('sendMessage', {\n                text: inputMessage,\n                timestamp: new Date()\n            });\n            setInputMessage('');\n        }\n    };\n    \n    return (\n        <div className=\"chat-app\">\n            <div className=\"chat-header\">\n                <h2>Real-time Chat</h2>\n                <div className=\"status\">\n                    <span className={isConnected ? 'connected' : 'disconnected'}>\n                        {isConnected ? 'â— Online' : 'â—‹ Offline'}\n                    </span>\n                    <span>{onlineUsers} users online</span>\n                </div>\n            </div>\n            \n            <div className=\"messages\">\n                {messages.map((msg, index) => (\n                    <div key={index} className=\"message\">\n                        <span className=\"username\">{msg.username}:</span>\n                        <span className=\"text\">{msg.text}</span>\n                        <span className=\"time\">\n                            {new Date(msg.timestamp).toLocaleTimeString()}\n                        </span>\n                    </div>\n                ))}\n                <div ref={messagesEndRef} />\n            </div>\n            \n            <form onSubmit={sendMessage} className=\"input-form\">\n                <input\n                    type=\"text\"\n                    value={inputMessage}\n                    onChange={(e) => setInputMessage(e.target.value)}\n                    placeholder=\"Type a message...\"\n                    disabled={!isConnected}\n                />\n                <button type=\"submit\" disabled={!isConnected || !inputMessage.trim()}>\n                    Send\n                </button>\n            </form>\n        </div>\n    );\n}\n\nexport default ChatApp;\n```\n\n---\n\n## ðŸš€ Next Steps for JavaScript Mastery\n\n### 1. **Advanced Patterns**\n- Learn design patterns (Observer, Module, Factory)\n- Master functional programming concepts\n- Understand reactive programming with RxJS\n\n### 2. **Framework Expertise**\n- **React**: Hooks, Context, state management\n- **Vue**: Composition API, Vuex/Pinia\n- **Angular**: Components, services, dependency injection\n\n### 3. **Node.js Mastery**\n- Express.js and middleware\n- Database integration (MongoDB, PostgreSQL)\n- Authentication and security\n- Microservices architecture\n\n### 4. **Testing Strategy**\n- Unit testing with Jest\n- Integration testing\n- End-to-end testing with Cypress\n- Test-driven development (TDD)\n\n### 5. **Build Tools & DevOps**\n- Webpack, Vite, Rollup configuration\n- CI/CD pipelines\n- Docker containers\n- Performance monitoring\n\n### 6. **Modern Web APIs**\n- Service Workers and PWAs\n- WebRTC for real-time communication\n- Web Workers for background processing\n- WebAssembly integration\n\n---\n\n## ðŸ“– JavaScript Concepts Quick Reference\n\n| Category | Key Concepts |\n|----------|-------------|\n| **Fundamentals** | Variables, data types, operators, hoisting |\n| **Functions** | Arrow functions, closures, higher-order functions |\n| **Objects** | Prototypes, classes, inheritance, SOLID principles |\n| **Async** | Promises, async/await, event loop, async iteration |\n| **DOM** | Selectors, events, manipulation, event delegation |\n| **ES6+** | Destructuring, spread/rest, modules, template literals |\n| **Functional** | Map, filter, reduce, immutability, composition |\n| **Advanced** | Generators, symbols, weak collections, proxies |\n| **Testing** | Jest, mocking, TDD, test coverage |\n| **Performance** | Debouncing, throttling, memory management, lazy loading |\n| **Node.js** | Express.js, middleware, REST APIs, Worker Threads, Streams |\n| **âš›ï¸ React** | Hooks, Context, State Management, Custom Hooks, Router, Redux |\n| **ðŸ…°ï¸ Angular** | Components, Services, RxJS, Routing, Forms, Directives |\n| **ðŸŽ¨ Patterns** | Singleton, Factory, Observer, Module, Strategy, Decorator |\n| **ðŸ”’ Security** | XSS/CSRF prevention, JWT, Input validation, CORS, Rate limiting |\n| **ðŸ”Œ Real-time** | WebSockets, Socket.IO, bidirectional communication |\n| **Ecosystem** | npm, Webpack, Vite, Babel, ESLint, build tools |\n\n---\n\n> **ðŸŽ‰ Congratulations!** You now have a complete JavaScript reference covering all concepts from beginner to expert level. This guide prepares you for modern web development, interviews, and advanced JavaScript projects.\n\n**Ready for the next level?** Consider learning TypeScript, React/Vue/Angular, or diving deeper into Node.js backend development!"}