{"id":"typescript-guide","title":"üìò TypeScript Complete Guide","content":"# üî∑ TypeScript Complete Mastery Guide\n\n> **Complete TypeScript Reference for Modern Development**  \n> From JavaScript to Type-Safe Development - All Concepts Covered\n\n---\n\n## üìö Table of Contents\n\n1. [TypeScript Fundamentals](#1-typescript-fundamentals)\n2. [Basic Types](#2-basic-types)\n3. [Interfaces and Types](#3-interfaces-and-types)\n4. [Classes and Inheritance](#4-classes-and-inheritance)\n5. [Generics](#5-generics)\n6. [Advanced Types](#6-advanced-types)\n7. [Modules and Namespaces](#7-modules-and-namespaces)\n8. [Decorators](#8-decorators)\n9. [TypeScript with React](#9-typescript-with-react)\n10. [Node.js with TypeScript](#10-nodejs-with-typescript)\n11. [Configuration and Build](#11-configuration-and-build)\n12. [Best Practices](#12-best-practices)\n\n---\n\n## 1. TypeScript Fundamentals\n\n### What is TypeScript?\n\nTypeScript is a superset of JavaScript that adds static type definitions. It compiles to plain JavaScript and runs anywhere JavaScript runs.\n\n### Getting Started\n\n```bash\n# Install TypeScript globally\nnpm install -g typescript\n\n# Create tsconfig.json\ntsc --init\n\n# Compile TypeScript file\ntsc app.ts\n\n# Watch mode\ntsc app.ts --watch\n```\n\n### Basic TypeScript File\n\n```typescript\n// app.ts\nfunction greet(name: string): string {\n    return `Hello, ${name}!`;\n}\n\nconst user = \"Alice\";\nconsole.log(greet(user));\n\n// Compile: tsc app.ts\n// Output: app.js (plain JavaScript)\n```\n\n---\n\n## 2. Basic Types\n\n### Primitive Types\n\n```typescript\n// Boolean\nlet isDone: boolean = false;\nlet isActive: boolean = true;\n\n// Number\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\n\n// String\nlet color: string = \"blue\";\nlet fullName: string = `Bob Smith`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${fullName}. I'll be ${age + 1} years old next month.`;\n\n// Null and Undefined\nlet u: undefined = undefined;\nlet n: null = null;\n\n// Void (typically for functions that don't return a value)\nfunction warnUser(): void {\n    console.log(\"This is my warning message\");\n}\n\n// Never (for functions that never return)\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// Any (disable type checking)\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n\n// Unknown (type-safe any)\nlet userInput: unknown;\nlet userName: string;\n\nuserInput = 5;\nuserInput = \"hello\";\n\nif (typeof userInput === \"string\") {\n    userName = userInput; // Type guard required\n}\n```\n\n### Arrays and Tuples\n\n```typescript\n// Arrays\nlet list: number[] = [1, 2, 3];\nlet listGeneric: Array<number> = [1, 2, 3];\nlet mixedArray: (string | number)[] = [\"hello\", 42, \"world\"];\n\n// Tuples\nlet x: [string, number];\nx = [\"hello\", 10]; // OK\n// x = [10, \"hello\"]; // Error\n\n// Tuple with optional elements\nlet optionalTuple: [string, number?] = [\"hello\"];\n\n// Rest elements in tuples\nlet restTuple: [string, ...number[]] = [\"hello\", 1, 2, 3];\n\n// Named tuples\nlet namedTuple: [name: string, age: number] = [\"Alice\", 30];\n```\n\n### Enums\n\n```typescript\n// Numeric enum\nenum Color {\n    Red,    // 0\n    Green,  // 1\n    Blue    // 2\n}\nlet c: Color = Color.Green;\n\n// String enum\nenum Direction {\n    Up = \"UP\",\n    Down = \"DOWN\",\n    Left = \"LEFT\",\n    Right = \"RIGHT\",\n}\n\n// Mixed enum\nenum BooleanLikeHeterogeneousEnum {\n    No = 0,\n    Yes = \"YES\",\n}\n\n// Const enum (optimized)\nconst enum Status {\n    Active = \"ACTIVE\",\n    Inactive = \"INACTIVE\"\n}\n```\n\n---\n\n## 3. Interfaces and Types\n\n### Interfaces\n\n```typescript\n// Basic interface\ninterface User {\n    name: string;\n    age: number;\n    email: string;\n}\n\nfunction createUser(user: User): User {\n    return user;\n}\n\nconst newUser = createUser({\n    name: \"Alice\",\n    age: 30,\n    email: \"alice@example.com\"\n});\n\n// Optional properties\ninterface Config {\n    color?: string;\n    width?: number;\n}\n\n// Readonly properties\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n\nlet p1: Point = { x: 10, y: 20 };\n// p1.x = 5; // Error: Cannot assign to 'x' because it is a read-only property\n\n// Index signatures\ninterface StringArray {\n    [index: number]: string;\n}\n\ninterface StringDictionary {\n    [key: string]: string;\n}\n\n// Function types in interfaces\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc = function(source: string, subString: string): boolean {\n    return source.search(subString) > -1;\n};\n\n// Class types\ninterface ClockInterface {\n    currentTime: Date;\n    setTime(d: Date): void;\n}\n\nclass Clock implements ClockInterface {\n    currentTime: Date = new Date();\n    setTime(d: Date) {\n        this.currentTime = d;\n    }\n}\n```\n\n### Type Aliases\n\n```typescript\n// Basic type alias\ntype Name = string;\ntype Age = number;\ntype User = {\n    name: Name;\n    age: Age;\n};\n\n// Union types\ntype StringOrNumber = string | number;\ntype Theme = \"light\" | \"dark\";\n\n// Function type alias\ntype EventHandler = (event: Event) => void;\n\n// Generic type alias\ntype Container<T> = {\n    value: T;\n};\n\n// Conditional types\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\n// Template literal types\ntype Greeting = `hello ${string}`;\ntype EmailAddress = `${string}@${string}.${string}`;\n```\n\n### Interface vs Type\n\n```typescript\n// Interface - can be extended and merged\ninterface Animal {\n    name: string;\n}\n\ninterface Animal {\n    age: number; // Declaration merging\n}\n\ninterface Dog extends Animal {\n    breed: string;\n}\n\n// Type - more flexible for unions and complex types\ntype Pet = Dog | Cat;\ntype EventNames = \"click\" | \"scroll\" | \"mousemove\";\n```\n\n---\n\n## 4. Classes and Inheritance\n\n### Basic Classes\n\n```typescript\nclass Person {\n    // Properties\n    private name: string;\n    protected age: number;\n    public email: string;\n    readonly id: number;\n\n    // Constructor\n    constructor(name: string, age: number, email: string) {\n        this.name = name;\n        this.age = age;\n        this.email = email;\n        this.id = Date.now();\n    }\n\n    // Methods\n    greet(): string {\n        return `Hello, I'm ${this.name}`;\n    }\n\n    // Getter\n    get displayName(): string {\n        return this.name.toUpperCase();\n    }\n\n    // Setter\n    set displayName(newName: string) {\n        if (newName.length > 0) {\n            this.name = newName;\n        }\n    }\n\n    // Static method\n    static createGuest(): Person {\n        return new Person(\"Guest\", 0, \"guest@example.com\");\n    }\n}\n\n// Inheritance\nclass Employee extends Person {\n    private department: string;\n    private salary: number;\n\n    constructor(name: string, age: number, email: string, department: string, salary: number) {\n        super(name, age, email); // Call parent constructor\n        this.department = department;\n        this.salary = salary;\n    }\n\n    // Override method\n    greet(): string {\n        return `${super.greet()} I work in ${this.department}`;\n    }\n\n    // New method\n    getAnnualSalary(): number {\n        return this.salary * 12;\n    }\n}\n\n// Parameter properties (shorthand)\nclass Student {\n    constructor(\n        public name: string,\n        private grade: number,\n        protected school: string\n    ) {}\n}\n```\n\n### Abstract Classes\n\n```typescript\nabstract class Animal {\n    abstract makeSound(): void;\n\n    move(): void {\n        console.log(\"Moving...\");\n    }\n}\n\nclass Dog extends Animal {\n    makeSound(): void {\n        console.log(\"Woof!\");\n    }\n}\n\n// const animal = new Animal(); // Error: Cannot create instance of abstract class\nconst dog = new Dog();\ndog.makeSound(); // \"Woof!\"\ndog.move(); // \"Moving...\"\n```\n\n### SOLID Principles in TypeScript\n\nTypeScript's type system makes implementing SOLID principles even more robust and type-safe.\n\n#### 1. Single Responsibility Principle (SRP)\n\n```typescript\n// ‚ùå Bad - Multiple responsibilities\nclass User {\n    constructor(public name: string, public email: string) {}\n    \n    saveToDatabase(): void {\n        // Database logic\n        console.log('Saving to database...');\n    }\n    \n    sendEmail(message: string): void {\n        // Email logic\n        console.log(`Sending email to ${this.email}: ${message}`);\n    }\n    \n    validateEmail(): boolean {\n        // Validation logic\n        return this.email.includes('@');\n    }\n}\n\n// ‚úÖ Good - Single responsibility per class\nclass User {\n    constructor(public readonly name: string, public readonly email: string) {}\n}\n\nclass UserRepository {\n    save(user: User): Promise<void> {\n        console.log(`Saving ${user.name} to database...`);\n        return Promise.resolve();\n    }\n}\n\nclass EmailService {\n    send(user: User, message: string): Promise<void> {\n        console.log(`Sending email to ${user.email}: ${message}`);\n        return Promise.resolve();\n    }\n}\n\nclass EmailValidator {\n    isValid(email: string): boolean {\n        return email.includes('@') && email.includes('.');\n    }\n}\n```\n\n#### 2. Open/Closed Principle (OCP)\n\n```typescript\n// ‚úÖ Good - Using interfaces and inheritance\ninterface Shape {\n    area(): number;\n}\n\nclass Circle implements Shape {\n    constructor(private radius: number) {}\n    \n    area(): number {\n        return Math.PI * this.radius ** 2;\n    }\n}\n\nclass Rectangle implements Shape {\n    constructor(private width: number, private height: number) {}\n    \n    area(): number {\n        return this.width * this.height;\n    }\n}\n\nclass AreaCalculator {\n    calculateTotal(shapes: Shape[]): number {\n        return shapes.reduce((total, shape) => total + shape.area(), 0);\n    }\n}\n\n// Adding new shapes doesn't modify existing code\nclass Triangle implements Shape {\n    constructor(private base: number, private height: number) {}\n    \n    area(): number {\n        return 0.5 * this.base * this.height;\n    }\n}\n\n// Usage\nconst calculator = new AreaCalculator();\nconst shapes: Shape[] = [\n    new Circle(5),\n    new Rectangle(4, 6),\n    new Triangle(3, 4)\n];\nconsole.log(calculator.calculateTotal(shapes));\n```\n\n#### 3. Liskov Substitution Principle (LSP)\n\n```typescript\n// ‚úÖ Good - Proper inheritance hierarchy\nabstract class Bird {\n    abstract move(): string;\n}\n\nabstract class FlyingBird extends Bird {\n    move(): string {\n        return this.fly();\n    }\n    \n    abstract fly(): string;\n}\n\nabstract class WalkingBird extends Bird {\n    move(): string {\n        return this.walk();\n    }\n    \n    abstract walk(): string;\n}\n\nclass Eagle extends FlyingBird {\n    fly(): string {\n        return \"Eagle soars through the sky\";\n    }\n}\n\nclass Penguin extends WalkingBird {\n    walk(): string {\n        return \"Penguin waddles on ice\";\n    }\n}\n\n// All birds can be used interchangeably\nfunction makeBirdMove(bird: Bird): string {\n    return bird.move();\n}\n\nconst eagle: Bird = new Eagle();\nconst penguin: Bird = new Penguin();\nconsole.log(makeBirdMove(eagle));   // Type-safe\nconsole.log(makeBirdMove(penguin)); // Type-safe\n```\n\n#### 4. Interface Segregation Principle (ISP)\n\n```typescript\n// ‚ùå Bad - Fat interface\ninterface Worker {\n    work(): void;\n    eat(): void;\n    sleep(): void;\n}\n\n// ‚úÖ Good - Segregated interfaces\ninterface Workable {\n    work(): void;\n}\n\ninterface Eatable {\n    eat(): void;\n}\n\ninterface Sleepable {\n    sleep(): void;\n}\n\nclass Human implements Workable, Eatable, Sleepable {\n    constructor(private name: string) {}\n    \n    work(): void {\n        console.log(`${this.name} is working`);\n    }\n    \n    eat(): void {\n        console.log(`${this.name} is eating`);\n    }\n    \n    sleep(): void {\n        console.log(`${this.name} is sleeping`);\n    }\n}\n\nclass Robot implements Workable {\n    constructor(private model: string) {}\n    \n    work(): void {\n        console.log(`${this.model} robot is working`);\n    }\n    // Robot doesn't need to implement eat() or sleep()\n}\n\n// Factory pattern with ISP\nclass WorkerFactory {\n    static createWorker(type: 'human' | 'robot', name: string): Workable {\n        switch (type) {\n            case 'human':\n                return new Human(name);\n            case 'robot':\n                return new Robot(name);\n            default:\n                throw new Error('Unknown worker type');\n        }\n    }\n}\n```\n\n#### 5. Dependency Inversion Principle (DIP)\n\n```typescript\n// ‚ùå Bad - High-level module depends on low-level module\nclass FileLogger {\n    log(message: string): void {\n        console.log(`File: ${message}`);\n    }\n}\n\nclass OrderService {\n    private logger = new FileLogger(); // Direct dependency\n    \n    createOrder(order: { id: string; amount: number }): void {\n        // Create order logic\n        this.logger.log(`Order ${order.id} created`);\n    }\n}\n\n// ‚úÖ Good - Depend on abstraction\ninterface Logger {\n    log(message: string): void;\n}\n\nclass FileLogger implements Logger {\n    log(message: string): void {\n        console.log(`[FILE] ${new Date().toISOString()}: ${message}`);\n    }\n}\n\nclass DatabaseLogger implements Logger {\n    log(message: string): void {\n        console.log(`[DB] ${new Date().toISOString()}: ${message}`);\n    }\n}\n\nclass ConsoleLogger implements Logger {\n    log(message: string): void {\n        console.log(`[CONSOLE] ${message}`);\n    }\n}\n\ninterface Order {\n    id: string;\n    amount: number;\n    customerEmail: string;\n}\n\nclass OrderService {\n    constructor(private logger: Logger) {} // Depends on abstraction\n    \n    createOrder(order: Order): void {\n        // Create order logic\n        this.logger.log(`Order ${order.id} for $${order.amount} created`);\n    }\n}\n\n// Usage with dependency injection\nconst fileLogger: Logger = new FileLogger();\nconst orderService = new OrderService(fileLogger);\n\n// Easy to switch implementations\nconst consoleLogger: Logger = new ConsoleLogger();\nconst orderServiceWithConsole = new OrderService(consoleLogger);\n```\n\n#### Advanced SOLID Example with TypeScript Features\n\n```typescript\n// Using generics, interfaces, and advanced TypeScript features\ninterface Repository<T> {\n    save(entity: T): Promise<T>;\n    findById(id: string): Promise<T | null>;\n    findAll(): Promise<T[]>;\n    delete(id: string): Promise<void>;\n}\n\ninterface PaymentProcessor {\n    process(amount: number): Promise<PaymentResult>;\n}\n\ninterface NotificationService<TMessage = string> {\n    send(message: TMessage, recipient: string): Promise<void>;\n}\n\ninterface Logger {\n    info(message: string): void;\n    error(message: string, error?: Error): void;\n    warn(message: string): void;\n}\n\n// Types\ntype PaymentResult = {\n    success: boolean;\n    transactionId?: string;\n    error?: string;\n};\n\ntype OrderStatus = 'pending' | 'processing' | 'completed' | 'failed';\n\ninterface Order {\n    id: string;\n    customerId: string;\n    amount: number;\n    status: OrderStatus;\n    createdAt: Date;\n}\n\n// Implementations\nclass InMemoryOrderRepository implements Repository<Order> {\n    private orders: Map<string, Order> = new Map();\n    \n    async save(order: Order): Promise<Order> {\n        this.orders.set(order.id, order);\n        return order;\n    }\n    \n    async findById(id: string): Promise<Order | null> {\n        return this.orders.get(id) || null;\n    }\n    \n    async findAll(): Promise<Order[]> {\n        return Array.from(this.orders.values());\n    }\n    \n    async delete(id: string): Promise<void> {\n        this.orders.delete(id);\n    }\n}\n\nclass StripePaymentProcessor implements PaymentProcessor {\n    async process(amount: number): Promise<PaymentResult> {\n        // Simulate payment processing\n        return {\n            success: true,\n            transactionId: `stripe_${Date.now()}`\n        };\n    }\n}\n\nclass EmailNotificationService implements NotificationService {\n    async send(message: string, recipient: string): Promise<void> {\n        console.log(`Email sent to ${recipient}: ${message}`);\n    }\n}\n\nclass ConsoleLogger implements Logger {\n    info(message: string): void {\n        console.log(`[INFO] ${message}`);\n    }\n    \n    error(message: string, error?: Error): void {\n        console.error(`[ERROR] ${message}`, error);\n    }\n    \n    warn(message: string): void {\n        console.warn(`[WARN] ${message}`);\n    }\n}\n\n// High-level service\nclass OrderProcessor {\n    constructor(\n        private orderRepository: Repository<Order>,\n        private paymentProcessor: PaymentProcessor,\n        private notificationService: NotificationService,\n        private logger: Logger\n    ) {}\n    \n    async processOrder(orderData: Omit<Order, 'id' | 'status' | 'createdAt'>): Promise<Order> {\n        const order: Order = {\n            ...orderData,\n            id: `order_${Date.now()}`,\n            status: 'pending',\n            createdAt: new Date()\n        };\n        \n        try {\n            this.logger.info(`Processing order ${order.id}`);\n            \n            // Save order\n            await this.orderRepository.save(order);\n            \n            // Process payment\n            order.status = 'processing';\n            await this.orderRepository.save(order);\n            \n            const paymentResult = await this.paymentProcessor.process(order.amount);\n            \n            if (paymentResult.success) {\n                order.status = 'completed';\n                await this.orderRepository.save(order);\n                \n                await this.notificationService.send(\n                    `Your order ${order.id} has been processed successfully!`,\n                    order.customerId\n                );\n                \n                this.logger.info(`Order ${order.id} completed successfully`);\n            } else {\n                order.status = 'failed';\n                await this.orderRepository.save(order);\n                this.logger.error(`Order ${order.id} payment failed: ${paymentResult.error}`);\n            }\n            \n            return order;\n        } catch (error) {\n            order.status = 'failed';\n            await this.orderRepository.save(order);\n            this.logger.error(`Order ${order.id} processing failed`, error as Error);\n            throw error;\n        }\n    }\n}\n\n// Dependency injection setup\nconst orderRepository = new InMemoryOrderRepository();\nconst paymentProcessor = new StripePaymentProcessor();\nconst notificationService = new EmailNotificationService();\nconst logger = new ConsoleLogger();\n\nconst orderProcessor = new OrderProcessor(\n    orderRepository,\n    paymentProcessor,\n    notificationService,\n    logger\n);\n\n// Usage\norderProcessor.processOrder({\n    customerId: 'customer_123',\n    amount: 99.99\n}).then(order => {\n    console.log('Order processed:', order);\n}).catch(error => {\n    console.error('Order processing failed:', error);\n});\n```\n\n---\n\n## 5. Generics\n\n### Basic Generics\n\n```typescript\n// Generic function\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nlet output1 = identity<string>(\"myString\");\nlet output2 = identity<number>(100);\n\n// Generic with type inference\nlet output3 = identity(\"myString\"); // TypeScript infers string\n\n// Generic with constraints\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n\nloggingIdentity(\"hello\"); // OK\nloggingIdentity([1, 2, 3]); // OK\n// loggingIdentity(3); // Error: number doesn't have length property\n```\n\n### Generic Classes\n\n```typescript\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n\n    constructor(zeroValue: T, addFunction: (x: T, y: T) => T) {\n        this.zeroValue = zeroValue;\n        this.add = addFunction;\n    }\n}\n\nlet myGenericNumber = new GenericNumber<number>(0, (x, y) => x + y);\nlet stringNumeric = new GenericNumber<string>(\"\", (x, y) => x + y);\n\n// Generic interfaces\ninterface Repository<T> {\n    create(item: T): T;\n    findById(id: string): T | null;\n    update(id: string, item: Partial<T>): T;\n    delete(id: string): boolean;\n}\n\nclass UserRepository implements Repository<User> {\n    private users: User[] = [];\n\n    create(user: User): User {\n        this.users.push(user);\n        return user;\n    }\n\n    findById(id: string): User | null {\n        return this.users.find(u => u.id === id) || null;\n    }\n\n    update(id: string, updates: Partial<User>): User {\n        const user = this.findById(id);\n        if (user) {\n            Object.assign(user, updates);\n        }\n        return user!;\n    }\n\n    delete(id: string): boolean {\n        const index = this.users.findIndex(u => u.id === id);\n        if (index > -1) {\n            this.users.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n### Advanced Generics\n\n```typescript\n// Multiple type parameters\nfunction combine<T, U>(first: T, second: U): T & U {\n    return { ...first as any, ...second as any };\n}\n\n// Generic constraints with keyof\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n    return obj[key];\n}\n\nlet person = { name: \"Alice\", age: 30, email: \"alice@example.com\" };\nlet name = getProperty(person, \"name\"); // string\nlet age = getProperty(person, \"age\"); // number\n\n// Conditional types\ntype ApiResponse<T> = T extends string ? string : T extends number ? number : object;\n\n// Mapped types\ntype Optional<T> = {\n    [P in keyof T]?: T[P];\n};\n\ntype PersonOptional = Optional<Person>; // All properties become optional\n\n// Utility types\ntype PartialPerson = Partial<Person>; // All properties optional\ntype RequiredPerson = Required<Person>; // All properties required\ntype PersonName = Pick<Person, \"name\">; // Only name property\ntype PersonWithoutName = Omit<Person, \"name\">; // All except name\n```\n\n---\n\n## 6. Advanced Types\n\n### Union and Intersection Types\n\n```typescript\n// Union types\ntype StringOrNumber = string | number;\ntype Theme = \"light\" | \"dark\" | \"auto\";\n\nfunction formatValue(value: StringOrNumber): string {\n    if (typeof value === \"string\") {\n        return value.toUpperCase();\n    } else {\n        return value.toString();\n    }\n}\n\n// Intersection types\ninterface Colorful {\n    color: string;\n}\n\ninterface Circle {\n    radius: number;\n}\n\ntype ColorfulCircle = Colorful & Circle;\n\nconst cc: ColorfulCircle = {\n    color: \"red\",\n    radius: 42\n};\n\n// Discriminated unions\ninterface Bird {\n    type: \"bird\";\n    flyingSpeed: number;\n}\n\ninterface Horse {\n    type: \"horse\";\n    runningSpeed: number;\n}\n\ntype Animal = Bird | Horse;\n\nfunction moveAnimal(animal: Animal) {\n    switch (animal.type) {\n        case \"bird\":\n            console.log(\"Flying at speed: \" + animal.flyingSpeed);\n            break;\n        case \"horse\":\n            console.log(\"Running at speed: \" + animal.runningSpeed);\n            break;\n    }\n}\n```\n\n### Type Guards\n\n```typescript\n// typeof type guard\nfunction isString(value: unknown): value is string {\n    return typeof value === \"string\";\n}\n\n// instanceof type guard\nclass Car {\n    drive() {\n        console.log(\"Driving a car...\");\n    }\n}\n\nclass Truck {\n    drive() {\n        console.log(\"Driving a truck...\");\n    }\n    \n    loadCargo() {\n        console.log(\"Loading cargo...\");\n    }\n}\n\nfunction useVehicle(vehicle: Car | Truck) {\n    vehicle.drive();\n    if (vehicle instanceof Truck) {\n        vehicle.loadCargo();\n    }\n}\n\n// Custom type guard\ninterface Cat {\n    meow(): void;\n}\n\ninterface Dog {\n    bark(): void;\n}\n\nfunction isCat(animal: Cat | Dog): animal is Cat {\n    return (animal as Cat).meow !== undefined;\n}\n\nfunction makeSound(animal: Cat | Dog) {\n    if (isCat(animal)) {\n        animal.meow();\n    } else {\n        animal.bark();\n    }\n}\n```\n\n### Template Literal Types\n\n```typescript\n// Basic template literal types\ntype World = \"world\";\ntype Greeting = `hello ${World}`; // \"hello world\"\n\n// Template literal patterns\ntype EmailAddress = `${string}@${string}.${string}`;\ntype EventNames = `on${Capitalize<string>}`;\n\n// Template literal with unions\ntype Color = \"red\" | \"green\" | \"blue\";\ntype Quantity = \"one\" | \"two\" | \"three\";\ntype SeussFish = `${Quantity | Color} fish`;\n// \"one fish\" | \"two fish\" | \"three fish\" | \"red fish\" | \"green fish\" | \"blue fish\"\n\n// Key remapping with template literals\ntype Getters<T> = {\n    [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype Person = {\n    name: string;\n    age: number;\n};\n\ntype PersonGetters = Getters<Person>;\n// {\n//   getName: () => string;\n//   getAge: () => number;\n// }\n```\n\n---\n\n## 7. Modules and Namespaces\n\n### ES6 Modules\n\n```typescript\n// math.ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport const PI = 3.14159;\n\nexport default function multiply(a: number, b: number): number {\n    return a * b;\n}\n\n// main.ts\nimport multiply, { add, subtract, PI } from \"./math\";\nimport * as MathUtils from \"./math\";\n\nconsole.log(add(2, 3)); // 5\nconsole.log(multiply(2, 3)); // 6\nconsole.log(MathUtils.PI); // 3.14159\n\n// Re-exports\nexport { add, subtract } from \"./math\";\nexport { default as multiply } from \"./math\";\n```\n\n### Namespaces\n\n```typescript\n// geometry.ts\nnamespace Geometry {\n    export interface Point {\n        x: number;\n        y: number;\n    }\n\n    export namespace Shapes {\n        export class Circle {\n            constructor(public center: Point, public radius: number) {}\n\n            area(): number {\n                return Math.PI * this.radius ** 2;\n            }\n        }\n\n        export class Rectangle {\n            constructor(\n                public topLeft: Point,\n                public width: number,\n                public height: number\n            ) {}\n\n            area(): number {\n                return this.width * this.height;\n            }\n        }\n    }\n\n    export function distance(p1: Point, p2: Point): number {\n        return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n    }\n}\n\n// Usage\nconst point1: Geometry.Point = { x: 0, y: 0 };\nconst point2: Geometry.Point = { x: 3, y: 4 };\nconst circle = new Geometry.Shapes.Circle(point1, 5);\nconst distance = Geometry.distance(point1, point2);\n```\n\n### Module Augmentation\n\n```typescript\n// Extending existing modules\ndeclare global {\n    interface Array<T> {\n        last(): T | undefined;\n    }\n}\n\nArray.prototype.last = function() {\n    return this[this.length - 1];\n};\n\n// Augmenting third-party modules\ndeclare module \"lodash\" {\n    interface LoDashStatic {\n        customFunction(): string;\n    }\n}\n```\n\n---\n\n## 8. Decorators\n\n> Note: Decorators are experimental. Enable with `\"experimentalDecorators\": true` in tsconfig.json\n\n### Class Decorators\n\n```typescript\n// Simple class decorator\nfunction sealed(constructor: Function) {\n    Object.seal(constructor);\n    Object.seal(constructor.prototype);\n}\n\n@sealed\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n    greet() {\n        return \"Hello, \" + this.greeting;\n    }\n}\n\n// Decorator factory\nfunction Entity(tableName: string) {\n    return function <T extends { new (...args: any[]): {} }>(constructor: T) {\n        return class extends constructor {\n            tableName = tableName;\n        };\n    };\n}\n\n@Entity(\"users\")\nclass User {\n    constructor(public name: string) {}\n}\n```\n\n### Method Decorators\n\n```typescript\n// Method decorator\nfunction log(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = function (...args: any[]) {\n        console.log(`Calling ${propertyName} with args:`, args);\n        const result = originalMethod.apply(this, args);\n        console.log(`Method ${propertyName} returned:`, result);\n        return result;\n    };\n}\n\nclass Calculator {\n    @log\n    add(a: number, b: number): number {\n        return a + b;\n    }\n}\n\n// Property decorator\nfunction readonly(target: any, propertyName: string) {\n    Object.defineProperty(target, propertyName, {\n        writable: false\n    });\n}\n\nclass Person {\n    @readonly\n    name: string = \"Alice\";\n}\n\n// Parameter decorator\nfunction logParameter(target: any, propertyName: string, parameterIndex: number) {\n    console.log(`Parameter ${parameterIndex} of ${propertyName} was decorated`);\n}\n\nclass Service {\n    method(@logParameter param1: string, @logParameter param2: number) {\n        // Method implementation\n    }\n}\n```\n\n---\n\n## 9. TypeScript with React\n\n### React Component Types\n\n```typescript\nimport React, { useState, useEffect, ReactNode } from 'react';\n\n// Function component with props\ninterface Props {\n    name: string;\n    age?: number;\n    children?: ReactNode;\n}\n\nconst UserProfile: React.FC<Props> = ({ name, age = 0, children }) => {\n    const [isVisible, setIsVisible] = useState<boolean>(true);\n\n    return (\n        <div>\n            <h1>{name}</h1>\n            {age > 0 && <p>Age: {age}</p>}\n            {children}\n            <button onClick={() => setIsVisible(!isVisible)}>\n                Toggle\n            </button>\n        </div>\n    );\n};\n\n// Class component\ninterface State {\n    count: number;\n}\n\nclass Counter extends React.Component<Props, State> {\n    state: State = {\n        count: 0\n    };\n\n    increment = (): void => {\n        this.setState({ count: this.state.count + 1 });\n    };\n\n    render(): ReactNode {\n        return (\n            <div>\n                <p>Count: {this.state.count}</p>\n                <button onClick={this.increment}>Increment</button>\n            </div>\n        );\n    }\n}\n```\n\n### Hooks with TypeScript\n\n```typescript\nimport { useState, useEffect, useRef, useCallback, useMemo } from 'react';\n\n// useState with type inference\nconst [name, setName] = useState(\"\"); // string\nconst [age, setAge] = useState(0); // number\nconst [user, setUser] = useState<User | null>(null); // User | null\n\n// useEffect\nuseEffect(() => {\n    // Effect logic\n    return () => {\n        // Cleanup\n    };\n}, []);\n\n// useRef\nconst inputRef = useRef<HTMLInputElement>(null);\nconst countRef = useRef<number>(0);\n\n// useCallback\nconst handleClick = useCallback((id: string) => {\n    console.log(`Clicked item ${id}`);\n}, []);\n\n// useMemo\nconst expensiveValue = useMemo(() => {\n    return computeExpensiveValue(data);\n}, [data]);\n\n// Custom hook\nfunction useCounter(initialValue: number = 0) {\n    const [count, setCount] = useState(initialValue);\n\n    const increment = useCallback(() => setCount(c => c + 1), []);\n    const decrement = useCallback(() => setCount(c => c - 1), []);\n    const reset = useCallback(() => setCount(initialValue), [initialValue]);\n\n    return { count, increment, decrement, reset };\n}\n\n// Using custom hook\nconst MyComponent: React.FC = () => {\n    const { count, increment, decrement, reset } = useCounter(10);\n\n    return (\n        <div>\n            <p>Count: {count}</p>\n            <button onClick={increment}>+</button>\n            <button onClick={decrement}>-</button>\n            <button onClick={reset}>Reset</button>\n        </div>\n    );\n};\n```\n\n### Event Handling\n\n```typescript\nimport React from 'react';\n\nconst EventExample: React.FC = () => {\n    const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {\n        console.log('Button clicked', event.currentTarget);\n    };\n\n    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        console.log('Input changed', event.target.value);\n    };\n\n    const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n        event.preventDefault();\n        console.log('Form submitted');\n    };\n\n    return (\n        <form onSubmit={handleSubmit}>\n            <input onChange={handleChange} />\n            <button onClick={handleClick}>Submit</button>\n        </form>\n    );\n};\n```\n\n---\n\n## 10. Node.js with TypeScript\n\n### Setting Up Node.js Project\n\n```bash\n# Initialize project\nnpm init -y\n\n# Install TypeScript and dependencies\nnpm install -D typescript @types/node ts-node nodemon\nnpm install express\nnpm install -D @types/express\n\n# Create tsconfig.json\nnpx tsc --init\n```\n\n### Express Server with TypeScript\n\n```typescript\n// server.ts\nimport express, { Request, Response, NextFunction } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(helmet());\napp.use(cors());\napp.use(express.json());\n\n// Types\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n}\n\ninterface CreateUserRequest {\n    name: string;\n    email: string;\n}\n\n// Routes\napp.get('/', (req: Request, res: Response) => {\n    res.json({ message: 'TypeScript Express Server' });\n});\n\napp.get('/api/users', (req: Request, res: Response) => {\n    const users: User[] = [\n        { id: 1, name: 'Alice', email: 'alice@example.com' },\n        { id: 2, name: 'Bob', email: 'bob@example.com' }\n    ];\n    res.json({ users });\n});\n\napp.post('/api/users', (req: Request<{}, User, CreateUserRequest>, res: Response<User>) => {\n    const { name, email } = req.body;\n    \n    const newUser: User = {\n        id: Date.now(),\n        name,\n        email\n    };\n    \n    res.status(201).json(newUser);\n});\n\n// Error handling\napp.use((err: Error, req: Request, res: Response, next: NextFunction) => {\n    console.error(err.stack);\n    res.status(500).json({ error: 'Something went wrong!' });\n});\n\napp.listen(PORT, () => {\n    console.log(`Server running on port ${PORT}`);\n});\n```\n\n### Database Integration\n\n```typescript\n// database.ts\nimport { Pool } from 'pg';\n\ninterface DatabaseConfig {\n    host: string;\n    port: number;\n    database: string;\n    user: string;\n    password: string;\n}\n\nclass Database {\n    private pool: Pool;\n\n    constructor(config: DatabaseConfig) {\n        this.pool = new Pool(config);\n    }\n\n    async query<T = any>(text: string, params?: any[]): Promise<T[]> {\n        const client = await this.pool.connect();\n        try {\n            const result = await client.query(text, params);\n            return result.rows;\n        } finally {\n            client.release();\n        }\n    }\n\n    async close(): Promise<void> {\n        await this.pool.end();\n    }\n}\n\n// User repository\nclass UserRepository {\n    constructor(private db: Database) {}\n\n    async findById(id: number): Promise<User | null> {\n        const users = await this.db.query<User>(\n            'SELECT * FROM users WHERE id = $1',\n            [id]\n        );\n        return users[0] || null;\n    }\n\n    async create(userData: CreateUserRequest): Promise<User> {\n        const users = await this.db.query<User>(\n            'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',\n            [userData.name, userData.email]\n        );\n        return users[0];\n    }\n\n    async findAll(): Promise<User[]> {\n        return this.db.query<User>('SELECT * FROM users');\n    }\n}\n```\n\n---\n\n## 11. Configuration and Build\n\n### tsconfig.json\n\n```json\n{\n  \"compilerOptions\": {\n    // Target and Module\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\", \"DOM\"],\n    \n    // Output\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"removeComments\": true,\n    \"sourceMap\": true,\n    \n    // Type Checking\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \n    // Module Resolution\n    \"moduleResolution\": \"node\",\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@components/*\": [\"src/components/*\"]\n    },\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \n    // Experimental\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \n    // Advanced\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.test.ts\"\n  ]\n}\n```\n\n### Build Scripts\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"ts-node src/index.ts\",\n    \"watch\": \"tsc --watch\",\n    \"dev:watch\": \"nodemon --exec ts-node src/index.ts\",\n    \"lint\": \"eslint src/**/*.ts\",\n    \"test\": \"jest\",\n    \"clean\": \"rimraf dist\"\n  }\n}\n```\n\n### Webpack Configuration\n\n```javascript\n// webpack.config.js\nconst path = require('path');\n\nmodule.exports = {\n  entry: './src/index.ts',\n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js'],\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n    },\n  },\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n};\n```\n\n---\n\n## 12. Best Practices\n\n### Type Safety\n\n```typescript\n// Use strict types\ninterface ApiResponse<T> {\n    data: T;\n    status: number;\n    message: string;\n}\n\n// Avoid any, use unknown instead\nfunction processData(data: unknown): string {\n    if (typeof data === 'string') {\n        return data.toUpperCase();\n    }\n    if (typeof data === 'object' && data !== null) {\n        return JSON.stringify(data);\n    }\n    return String(data);\n}\n\n// Use type assertions carefully\nconst userInput = document.getElementById('user-input') as HTMLInputElement;\n\n// Prefer type guards\nfunction isUser(obj: any): obj is User {\n    return obj && typeof obj.name === 'string' && typeof obj.email === 'string';\n}\n```\n\n### Error Handling\n\n```typescript\n// Result pattern for error handling\ntype Result<T, E = Error> = {\n    success: true;\n    data: T;\n} | {\n    success: false;\n    error: E;\n};\n\nasync function fetchUser(id: number): Promise<Result<User>> {\n    try {\n        const user = await api.getUser(id);\n        return { success: true, data: user };\n    } catch (error) {\n        return { success: false, error: error as Error };\n    }\n}\n\n// Usage\nconst result = await fetchUser(1);\nif (result.success) {\n    console.log(result.data.name); // TypeScript knows this is User\n} else {\n    console.error(result.error.message); // TypeScript knows this is Error\n}\n```\n\n### Performance Tips\n\n```typescript\n// Use const assertions for better inference\nconst colors = ['red', 'green', 'blue'] as const;\ntype Color = typeof colors[number]; // 'red' | 'green' | 'blue'\n\n// Lazy loading with dynamic imports\nasync function loadModule() {\n    const { heavyFunction } = await import('./heavy-module');\n    return heavyFunction();\n}\n\n// Use branded types for type safety\ntype UserId = string & { readonly brand: unique symbol };\ntype Email = string & { readonly brand: unique symbol };\n\nfunction createUserId(id: string): UserId {\n    return id as UserId;\n}\n\nfunction createEmail(email: string): Email {\n    if (!email.includes('@')) {\n        throw new Error('Invalid email');\n    }\n    return email as Email;\n}\n\n// Now these can't be mixed up\nfunction sendEmail(userId: UserId, email: Email): void {\n    // Implementation\n}\n```\n\n### Testing with TypeScript\n\n```typescript\n// jest.config.js\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n  ],\n};\n\n// Example test\nimport { Calculator } from '../Calculator';\n\ndescribe('Calculator', () => {\n    let calculator: Calculator;\n\n    beforeEach(() => {\n        calculator = new Calculator();\n    });\n\n    it('should add two numbers correctly', () => {\n        const result = calculator.add(2, 3);\n        expect(result).toBe(5);\n    });\n\n    it('should handle edge cases', () => {\n        expect(calculator.add(0, 0)).toBe(0);\n        expect(calculator.add(-1, 1)).toBe(0);\n    });\n});\n```\n\n---\n\n## üöÄ Next Steps for TypeScript Mastery\n\n### 1. **Advanced Type System**\n- Conditional types and mapped types\n- Template literal types\n- Recursive types and type-level programming\n\n### 2. **Framework Integration**\n- **React**: Advanced patterns with TypeScript\n- **Vue**: Composition API with TypeScript\n- **Angular**: Full TypeScript integration\n\n### 3. **Backend Development**\n- **Express**: Type-safe REST APIs\n- **NestJS**: Decorator-based architecture\n- **GraphQL**: Type-safe schema definition\n\n### 4. **Build and Tooling**\n- Webpack and TypeScript\n- ESBuild and SWC for fast compilation\n- Monorepo setup with TypeScript\n\n### 5. **Testing Strategy**\n- Type-safe testing with Jest\n- End-to-end testing with Playwright\n- Property-based testing\n\n---\n\n## üìñ TypeScript Quick Reference\n\n| Feature | Syntax | Use Case |\n|---------|--------|----------|\n| **Basic Types** | `let name: string` | Type annotation |\n| **Interfaces** | `interface User { name: string }` | Object shapes |\n| **Generics** | `function id<T>(arg: T): T` | Reusable components |\n| **Union Types** | `string \\| number` | Multiple possible types |\n| **Type Guards** | `if (typeof x === 'string')` | Runtime type checking |\n| **Utility Types** | `Partial<T>`, `Pick<T, K>` | Type transformations |\n| **Decorators** | `@Component` | Metadata and enhancement |\n| **SOLID Principles** | Interface segregation, DIP | Clean architecture |\n\n---\n\n> **üéâ Congratulations!** You now have a complete TypeScript reference covering all concepts from basic types to advanced patterns. TypeScript will help you write more maintainable, scalable, and bug-free JavaScript applications!\n\n**Ready for production?** Start building type-safe applications with React, Node.js, or your favorite framework!"}