{"id":"ts-examples","title":"üìò TypeScript Code Examples","content":"# Code Examples\n\n```typescript\n#!/usr/bin/env ts-node\n/**\n * üî∑ TYPESCRIPT MASTERY GUIDE - COMPLETE REFERENCE FOR INTERVIEWS & MASTERY\n * =========================================================================\n * \n * This comprehensive guide covers all TypeScript concepts from basics to advanced topics.\n * Perfect for interview preparation, skill assessment, and continuous learning.\n * \n * Author: Tech Mastery Notebooks\n * Date: November 2025\n * Level: Beginner to Expert\n */\n\n// ===============================================================\n// 1. TYPESCRIPT FUNDAMENTALS - TYPE SYSTEM BASICS\n// ===============================================================\nconsole.log(\"üî∑ TYPESCRIPT FUNDAMENTALS\");\nconsole.log(\"=\".repeat(50));\n\n// Basic Types\nconsole.log(\"\\nüìä BASIC TYPES:\");\n\n// Primitive types\nconst numberType: number = 42;\nconst stringType: string = \"Hello, TypeScript!\";\nconst booleanType: boolean = true;\nconst undefinedType: undefined = undefined;\nconst nullType: null = null;\n\nconsole.log(`Number: ${numberType} (type: number)`);\nconsole.log(`String: ${stringType} (type: string)`);\nconsole.log(`Boolean: ${booleanType} (type: boolean)`);\nconsole.log(`Undefined: ${undefinedType} (type: undefined)`);\nconsole.log(`Null: ${nullType} (type: null)`);\n\n// Array types\nconst numberArray: number[] = [1, 2, 3, 4, 5];\nconst stringArray: Array<string> = [\"apple\", \"banana\", \"cherry\"];\nconst mixedArray: (string | number)[] = [\"hello\", 42, \"world\", 100];\n\nconsole.log(`\\nNumber array: ${numberArray}`);\nconsole.log(`String array: ${stringArray}`);\nconsole.log(`Mixed array: ${mixedArray}`);\n\n// Tuple types\nconst tuple: [string, number, boolean] = [\"Alice\", 30, true];\nconst namedTuple: readonly [name: string, age: number] = [\"Bob\", 25];\n\nconsole.log(`Tuple: ${tuple}`);\nconsole.log(`Named tuple: ${namedTuple}`);\n\n// Enum types\nenum Color {\n    Red = \"red\",\n    Green = \"green\",\n    Blue = \"blue\"\n}\n\nenum Status {\n    Pending,\n    Approved,\n    Rejected\n}\n\nconsole.log(`\\nColor enum: ${Color.Red}`);\nconsole.log(`Status enum: ${Status.Pending} (numeric)`);\n\n// ===============================================================\n// 2. OBJECT TYPES AND INTERFACES\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ OBJECT TYPES AND INTERFACES\");\nconsole.log(\"=\".repeat(50));\n\n// Object type annotations\nconst userObj: { name: string; age: number; email?: string } = {\n    name: \"Alice\",\n    age: 30\n};\n\nconsole.log(`\\nüë§ OBJECT TYPES:`);\nconsole.log(`User object:`, userObj);\n\n// Interface definitions\ninterface User {\n    readonly id: number;\n    name: string;\n    age: number;\n    email?: string; // Optional property\n    isActive: boolean;\n}\n\ninterface UserMethods {\n    getName(): string;\n    setAge(age: number): void;\n    getFullProfile(): string;\n}\n\n// Combining interfaces\ninterface CompleteUser extends User, UserMethods {}\n\n// Interface implementation\nclass UserClass implements CompleteUser {\n    readonly id: number;\n    name: string;\n    age: number;\n    email?: string;\n    isActive: boolean;\n\n    constructor(id: number, name: string, age: number, isActive: boolean = true) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.isActive = isActive;\n    }\n\n    getName(): string {\n        return this.name;\n    }\n\n    setAge(age: number): void {\n        this.age = age;\n    }\n\n    getFullProfile(): string {\n        return `User ${this.name} (ID: ${this.id}, Age: ${this.age})`;\n    }\n}\n\nconst user = new UserClass(1, \"Alice\", 30);\nconsole.log(`User profile: ${user.getFullProfile()}`);\n\n// Index signatures\ninterface StringDictionary {\n    [key: string]: string;\n}\n\ninterface NumberDictionary {\n    [key: string]: number;\n    length: number; // Can have specific properties too\n}\n\nconst colors: StringDictionary = {\n    primary: \"blue\",\n    secondary: \"green\",\n    accent: \"red\"\n};\n\nconsole.log(`Colors dictionary:`, colors);\n\n// ===============================================================\n// 3. UNION TYPES AND TYPE GUARDS\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ UNION TYPES AND TYPE GUARDS\");\nconsole.log(\"=\".repeat(50));\n\n// Union types\ntype StringOrNumber = string | number;\ntype Theme = \"light\" | \"dark\" | \"auto\";\n\nfunction formatValue(value: StringOrNumber): string {\n    if (typeof value === \"string\") {\n        return value.toUpperCase();\n    } else {\n        return value.toFixed(2);\n    }\n}\n\nconsole.log(`\\nüîÄ UNION TYPES:`);\nconsole.log(`Format string: ${formatValue(\"hello\")}`);\nconsole.log(`Format number: ${formatValue(42.789)}`);\n\n// Discriminated unions\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\n\ninterface Triangle {\n    kind: \"triangle\";\n    base: number;\n    height: number;\n}\n\ntype Shape = Circle | Rectangle | Triangle;\n\nfunction calculateArea(shape: Shape): number {\n    switch (shape.kind) {\n        case \"circle\":\n            return Math.PI * shape.radius ** 2;\n        case \"rectangle\":\n            return shape.width * shape.height;\n        case \"triangle\":\n            return (shape.base * shape.height) / 2;\n        default:\n            // Exhaustiveness check\n            const _exhaustiveCheck: never = shape;\n            return _exhaustiveCheck;\n    }\n}\n\nconst circle: Circle = { kind: \"circle\", radius: 5 };\nconst rectangle: Rectangle = { kind: \"rectangle\", width: 10, height: 6 };\n\nconsole.log(`Circle area: ${calculateArea(circle).toFixed(2)}`);\nconsole.log(`Rectangle area: ${calculateArea(rectangle)}`);\n\n// Type guards\nfunction isString(value: any): value is string {\n    return typeof value === \"string\";\n}\n\nfunction isUser(obj: any): obj is User {\n    return obj && typeof obj.name === \"string\" && typeof obj.age === \"number\";\n}\n\n// Using type guards\nfunction processValue(value: unknown) {\n    if (isString(value)) {\n        console.log(`Processing string: ${value.toUpperCase()}`);\n    } else if (typeof value === \"number\") {\n        console.log(`Processing number: ${value.toFixed(2)}`);\n    } else {\n        console.log(`Unknown type: ${typeof value}`);\n    }\n}\n\nconsole.log(`\\nüõ°Ô∏è TYPE GUARDS:`);\nprocessValue(\"hello\");\nprocessValue(42.789);\nprocessValue(true);\n\n// ===============================================================\n// 4. GENERICS - REUSABLE TYPE DEFINITIONS\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ GENERICS\");\nconsole.log(\"=\".repeat(50));\n\n// Generic functions\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nfunction getFirstElement<T>(array: T[]): T | undefined {\n    return array[0];\n}\n\nfunction swapPair<T, U>(pair: [T, U]): [U, T] {\n    return [pair[1], pair[0]];\n}\n\nconsole.log(`\\nüß¨ GENERIC FUNCTIONS:`);\nconsole.log(`Identity string: ${identity(\"hello\")}`);\nconsole.log(`Identity number: ${identity(42)}`);\nconsole.log(`First element: ${getFirstElement([1, 2, 3])}`);\nconsole.log(`Swapped pair: ${swapPair([\"hello\", 42])}`);\n\n// Generic interfaces\ninterface Container<T> {\n    value: T;\n    getValue(): T;\n    setValue(value: T): void;\n}\n\nclass Box<T> implements Container<T> {\n    constructor(public value: T) {}\n\n    getValue(): T {\n        return this.value;\n    }\n\n    setValue(value: T): void {\n        this.value = value;\n    }\n}\n\nconst stringBox = new Box<string>(\"Hello\");\nconst numberBox = new Box<number>(42);\n\nconsole.log(`String box: ${stringBox.getValue()}`);\nconsole.log(`Number box: ${numberBox.getValue()}`);\n\n// Generic constraints\ninterface Lengthwise {\n    length: number;\n}\n\nfunction logAndReturn<T extends Lengthwise>(arg: T): T {\n    console.log(`Length: ${arg.length}`);\n    return arg;\n}\n\nlogAndReturn(\"Hello, TypeScript!\");\nlogAndReturn([1, 2, 3, 4, 5]);\n\n// Conditional types\ntype NonNullable<T> = T extends null | undefined ? never : T;\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\n\ntype StringType = NonNullable<string | null>; // string\ntype NumberFromArray = ArrayElement<number[]>; // number\n\n// ===============================================================\n// 5. ADVANCED TYPES AND UTILITY TYPES\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ ADVANCED TYPES AND UTILITY TYPES\");\nconsole.log(\"=\".repeat(50));\n\n// Mapped types\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n\ninterface Person {\n    name: string;\n    age: number;\n    email?: string;\n}\n\ntype ReadonlyPerson = Readonly<Person>;\ntype PartialPerson = Partial<Person>;\ntype RequiredPerson = Required<Person>;\n\nconsole.log(`\\nüó∫Ô∏è MAPPED TYPES:`);\nconsole.log(\"Readonly, Partial, and Required utility types applied\");\n\n// Template literal types\ntype EventName<T extends string> = `on${Capitalize<T>}`;\ntype ButtonEvents = EventName<\"click\" | \"hover\" | \"focus\">; // \"onClick\" | \"onHover\" | \"onFocus\"\n\n// Conditional types with template literals\ntype ExtractRouteParams<T extends string> = \n    T extends `${string}:${infer Param}/${infer Rest}`\n        ? { [K in Param | keyof ExtractRouteParams<Rest>]: string }\n        : T extends `${string}:${infer Param}`\n        ? { [K in Param]: string }\n        : {};\n\ntype RouteParams = ExtractRouteParams<\"/users/:id/posts/:postId\">; // { id: string, postId: string }\n\n// Utility types in action\ninterface ApiResponse {\n    id: number;\n    name: string;\n    email: string;\n    createdAt: Date;\n    updatedAt: Date;\n}\n\ntype CreateUserRequest = Pick<ApiResponse, \"name\" | \"email\">;\ntype UpdateUserRequest = Partial<Pick<ApiResponse, \"name\" | \"email\">>;\ntype UserSummary = Omit<ApiResponse, \"createdAt\" | \"updatedAt\">;\n\nfunction createUser(data: CreateUserRequest): ApiResponse {\n    return {\n        id: Math.random(),\n        ...data,\n        createdAt: new Date(),\n        updatedAt: new Date()\n    };\n}\n\nconst newUser = createUser({ name: \"John\", email: \"john@example.com\" });\nconsole.log(`Created user: ${newUser.name}`);\n\n// ===============================================================\n// 6. CLASSES AND INHERITANCE\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ CLASSES AND INHERITANCE\");\nconsole.log(\"=\".repeat(50));\n\n// Abstract classes\nabstract class Animal {\n    protected name: string;\n    protected age: number;\n\n    constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n\n    abstract makeSound(): string;\n    \n    protected getInfo(): string {\n        return `${this.name} is ${this.age} years old`;\n    }\n\n    public introduce(): string {\n        return `${this.getInfo()} and says: ${this.makeSound()}`;\n    }\n}\n\nclass Dog extends Animal {\n    private breed: string;\n\n    constructor(name: string, age: number, breed: string) {\n        super(name, age);\n        this.breed = breed;\n    }\n\n    makeSound(): string {\n        return \"Woof!\";\n    }\n\n    public getBreed(): string {\n        return this.breed;\n    }\n}\n\nclass Cat extends Animal {\n    private isIndoor: boolean;\n\n    constructor(name: string, age: number, isIndoor: boolean = true) {\n        super(name, age);\n        this.isIndoor = isIndoor;\n    }\n\n    makeSound(): string {\n        return \"Meow!\";\n    }\n\n    public isIndoorCat(): boolean {\n        return this.isIndoor;\n    }\n}\n\nconst dog = new Dog(\"Buddy\", 3, \"Golden Retriever\");\nconst cat = new Cat(\"Whiskers\", 2, true);\n\nconsole.log(`\\nüêï CLASSES AND INHERITANCE:`);\nconsole.log(dog.introduce());\nconsole.log(cat.introduce());\nconsole.log(`Dog breed: ${dog.getBreed()}`);\nconsole.log(`Cat is indoor: ${cat.isIndoorCat()}`);\n\n// Static members and getters/setters\nclass MathUtils {\n    private static readonly PI = 3.14159;\n    private _value: number = 0;\n\n    static circleArea(radius: number): number {\n        return this.PI * radius * radius;\n    }\n\n    get value(): number {\n        return this._value;\n    }\n\n    set value(newValue: number) {\n        if (newValue < 0) {\n            throw new Error(\"Value cannot be negative\");\n        }\n        this._value = newValue;\n    }\n}\n\nconsole.log(`Circle area: ${MathUtils.circleArea(5)}`);\n\nconst mathUtils = new MathUtils();\nmathUtils.value = 42;\nconsole.log(`Math utils value: ${mathUtils.value}`);\n\n// ===============================================================\n// 7. MODULES AND NAMESPACES\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ MODULES AND NAMESPACES\");\nconsole.log(\"=\".repeat(50));\n\n// Namespace example\nnamespace Validation {\n    export interface StringValidator {\n        isAcceptable(s: string): boolean;\n    }\n\n    const lettersRegexp = /^[A-Za-z]+$/;\n    const numberRegexp = /^[0-9]+$/;\n\n    export class LettersOnlyValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return lettersRegexp.test(s);\n        }\n    }\n\n    export class ZipCodeValidator implements StringValidator {\n        isAcceptable(s: string) {\n            return s.length === 5 && numberRegexp.test(s);\n        }\n    }\n}\n\n// Module-like structure\nexport class DataProcessor<T> {\n    private data: T[] = [];\n\n    add(item: T): void {\n        this.data.push(item);\n    }\n\n    process(callback: (item: T) => T): T[] {\n        return this.data.map(callback);\n    }\n\n    filter(predicate: (item: T) => boolean): T[] {\n        return this.data.filter(predicate);\n    }\n\n    getCount(): number {\n        return this.data.length;\n    }\n}\n\nconst validator = new Validation.LettersOnlyValidator();\nconst zipValidator = new Validation.ZipCodeValidator();\n\nconsole.log(`\\nüì¶ MODULES AND NAMESPACES:`);\nconsole.log(`Letters validation: ${validator.isAcceptable(\"Hello\")}`);\nconsole.log(`Zip validation: ${zipValidator.isAcceptable(\"12345\")}`);\n\nconst processor = new DataProcessor<number>();\nprocessor.add(1);\nprocessor.add(2);\nprocessor.add(3);\nconsole.log(`Processed data: ${processor.process(x => x * 2)}`);\n\n// ===============================================================\n// 8. DECORATORS AND METADATA\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ DECORATORS AND METADATA\");\nconsole.log(\"=\".repeat(50));\n\n// Method decorators\nfunction log(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const method = descriptor.value;\n    \n    descriptor.value = function (...args: any[]) {\n        console.log(`Calling ${propertyName} with arguments: ${JSON.stringify(args)}`);\n        const result = method.apply(this, args);\n        console.log(`${propertyName} returned: ${JSON.stringify(result)}`);\n        return result;\n    };\n    \n    return descriptor;\n}\n\nfunction validate(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const method = descriptor.value;\n    \n    descriptor.value = function (...args: any[]) {\n        for (const arg of args) {\n            if (arg == null) {\n                throw new Error(`Null or undefined argument passed to ${propertyName}`);\n            }\n        }\n        return method.apply(this, args);\n    };\n    \n    return descriptor;\n}\n\n// Class using decorators\nclass Calculator {\n    add(a: number, b: number): number {\n        console.log(`Calling add with arguments: [${a}, ${b}]`);\n        const result = a + b;\n        console.log(`add returned: ${result}`);\n        return result;\n    }\n\n    multiply(a: number, b: number): number {\n        console.log(`Calling multiply with arguments: [${a}, ${b}]`);\n        const result = a * b;\n        console.log(`multiply returned: ${result}`);\n        return result;\n    }\n}\n\nconsole.log(`\\nüé≠ DECORATORS:`);\nconst calc = new Calculator();\nconsole.log(`Addition result: ${calc.add(5, 3)}`);\nconsole.log(`Multiplication result: ${calc.multiply(4, 6)}`);\n\n// Property example (without decorators for compatibility)\nclass Product {\n    readonly id: number;\n    name: string;\n    price: number;\n\n    constructor(id: number, name: string, price: number) {\n        this.id = id;\n        this.name = name;\n        this.price = price;\n    }\n}\n\n// ===============================================================\n// 9. ASYNC/AWAIT AND PROMISES WITH TYPES\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ ASYNC/AWAIT AND PROMISES\");\nconsole.log(\"=\".repeat(50));\n\n// Generic promise types\ninterface ApiUser {\n    id: number;\n    name: string;\n    email: string;\n}\n\ninterface ApiError {\n    message: string;\n    code: number;\n}\n\ntype ApiResult<T> = {\n    success: true;\n    data: T;\n} | {\n    success: false;\n    error: ApiError;\n};\n\n// Async functions with proper typing\nasync function fetchUser(id: number): Promise<ApiResult<ApiUser>> {\n    try {\n        // Simulate API call\n        await new Promise(resolve => setTimeout(resolve, 100));\n        \n        if (id <= 0) {\n            return {\n                success: false,\n                error: { message: \"Invalid user ID\", code: 400 }\n            };\n        }\n\n        return {\n            success: true,\n            data: {\n                id,\n                name: `User ${id}`,\n                email: `user${id}@example.com`\n            }\n        };\n    } catch (error) {\n        return {\n            success: false,\n            error: { message: \"Network error\", code: 500 }\n        };\n    }\n}\n\nasync function fetchMultipleUsers(ids: number[]): Promise<ApiUser[]> {\n    const promises = ids.map(id => fetchUser(id));\n    const results = await Promise.all(promises);\n    \n    return results\n        .filter((result): result is { success: true; data: ApiUser } => result.success)\n        .map(result => result.data);\n}\n\n// Usage example\n(async () => {\n    console.log(`\\nüîÑ ASYNC/AWAIT:`);\n    \n    const userResult = await fetchUser(1);\n    if (userResult.success) {\n        console.log(`Fetched user: ${userResult.data.name}`);\n    } else {\n        console.log(`Error: ${userResult.error.message}`);\n    }\n\n    const users = await fetchMultipleUsers([1, 2, 3]);\n    console.log(`Fetched ${users.length} users`);\n})();\n\n// ===============================================================\n// 10. ERROR HANDLING AND CUSTOM TYPES\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ ERROR HANDLING\");\nconsole.log(\"=\".repeat(50));\n\n// Custom error types\nclass ValidationError extends Error {\n    constructor(\n        message: string,\n        public field: string,\n        public value: any\n    ) {\n        super(message);\n        this.name = \"ValidationError\";\n    }\n}\n\nclass NotFoundError extends Error {\n    constructor(resource: string, id: string | number) {\n        super(`${resource} with id ${id} not found`);\n        this.name = \"NotFoundError\";\n    }\n}\n\n// Result type pattern\ntype Result<T, E = Error> = \n    | { success: true; data: T }\n    | { success: false; error: E };\n\nfunction validateEmail(email: string): Result<string, ValidationError> {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    \n    if (!emailRegex.test(email)) {\n        return {\n            success: false,\n            error: new ValidationError(\"Invalid email format\", \"email\", email)\n        };\n    }\n    \n    return { success: true, data: email };\n}\n\nfunction findUserById(id: number): Result<ApiUser, NotFoundError> {\n    // Simulate user lookup\n    if (id === 999) {\n        return {\n            success: false,\n            error: new NotFoundError(\"User\", id)\n        };\n    }\n    \n    return {\n        success: true,\n        data: { id, name: `User ${id}`, email: `user${id}@example.com` }\n    };\n}\n\nconsole.log(`\\n‚ùå ERROR HANDLING:`);\n\nconst emailResult = validateEmail(\"invalid-email\");\nif (!emailResult.success) {\n    console.log(`Validation error: ${emailResult.error.message} for field: ${emailResult.error.field}`);\n}\n\nconst userResult2 = findUserById(999);\nif (!userResult2.success) {\n    console.log(`Not found error: ${userResult2.error.message}`);\n}\n\n// ===============================================================\n// 11. PERFORMANCE AND OPTIMIZATION\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ PERFORMANCE OPTIMIZATION\");\nconsole.log(\"=\".repeat(50));\n\n// Type-only imports for better tree shaking\ntype UserType = User; // Type-only import/usage\n\n// Const assertions for better type inference\nconst themes = [\"light\", \"dark\", \"auto\"] as const;\ntype ThemeType = typeof themes[number]; // \"light\" | \"dark\" | \"auto\"\n\nconst config = {\n    apiUrl: \"https://api.example.com\",\n    timeout: 5000,\n    retries: 3\n} as const;\n\ntype Config = typeof config;\n\n// Lazy evaluation with getters\nclass ExpensiveCalculation {\n    private _result?: number;\n\n    get result(): number {\n        if (this._result === undefined) {\n            console.log(\"Performing expensive calculation...\");\n            this._result = Array.from({ length: 1000000 }, (_, i) => i)\n                .reduce((sum, i) => sum + i, 0);\n        }\n        return this._result;\n    }\n}\n\nconsole.log(`\\n‚ö° PERFORMANCE:`);\nconsole.log(`Themes type: ${themes.join(\", \")}`);\nconsole.log(`Config keys: ${Object.keys(config).join(\", \")}`);\n\nconst calc2 = new ExpensiveCalculation();\nconsole.log(`First access: ${calc2.result > 0 ? \"Calculated\" : \"Error\"}`);\nconsole.log(`Second access: ${calc2.result > 0 ? \"Cached\" : \"Error\"}`);\n\n// ===============================================================\n// 12. TESTING WITH TYPESCRIPT\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ TESTING WITH TYPESCRIPT\");\nconsole.log(\"=\".repeat(50));\n\n// Type-safe testing utilities\ninterface TestCase<T, R> {\n    input: T;\n    expected: R;\n    description: string;\n}\n\nfunction createTestSuite<T, R>(\n    name: string,\n    testFunction: (input: T) => R,\n    testCases: TestCase<T, R>[]\n): void {\n    console.log(`\\nüß™ Test Suite: ${name}`);\n    \n    testCases.forEach((testCase, index) => {\n        try {\n            const result = testFunction(testCase.input);\n            const passed = JSON.stringify(result) === JSON.stringify(testCase.expected);\n            \n            console.log(`  Test ${index + 1}: ${testCase.description} - ${passed ? \"‚úÖ PASS\" : \"‚ùå FAIL\"}`);\n            if (!passed) {\n                console.log(`    Expected: ${JSON.stringify(testCase.expected)}`);\n                console.log(`    Received: ${JSON.stringify(result)}`);\n            }\n        } catch (error) {\n            console.log(`  Test ${index + 1}: ${testCase.description} - ‚ùå ERROR: ${error}`);\n        }\n    });\n}\n\n// Example test usage\nfunction addNumbers(a: number, b: number): number {\n    return a + b;\n}\n\nconst mathTestCases: TestCase<[number, number], number>[] = [\n    { input: [2, 3], expected: 5, description: \"Add positive numbers\" },\n    { input: [-1, 1], expected: 0, description: \"Add negative and positive\" },\n    { input: [0, 0], expected: 0, description: \"Add zeros\" }\n];\n\ncreateTestSuite(\"Math Operations\", ([a, b]) => addNumbers(a, b), mathTestCases);\n\n// Mock types for testing\ninterface MockUser {\n    id: number;\n    name: string;\n    email: string;\n}\n\ntype MockFunction<T extends (...args: any[]) => any> = {\n    (...args: Parameters<T>): ReturnType<T>;\n    mockReturnValue(value: ReturnType<T>): void;\n    mockImplementation(fn: T): void;\n    calls: Parameters<T>[];\n};\n\nfunction createMock<T extends (...args: any[]) => any>(): MockFunction<T> {\n    const calls: Parameters<T>[] = [];\n    let returnValue: ReturnType<T>;\n    let implementation: T;\n\n    const mockFn = ((...args: Parameters<T>): ReturnType<T> => {\n        calls.push(args);\n        if (implementation) {\n            return implementation(...args);\n        }\n        return returnValue;\n    }) as MockFunction<T>;\n\n    mockFn.mockReturnValue = (value: ReturnType<T>) => {\n        returnValue = value;\n    };\n\n    mockFn.mockImplementation = (fn: T) => {\n        implementation = fn;\n    };\n\n    mockFn.calls = calls;\n\n    return mockFn;\n}\n\nconsole.log(\"\\nüé≠ MOCKING:\");\nconst mockGetUser = createMock<(id: number) => MockUser>();\nmockGetUser.mockReturnValue({ id: 1, name: \"Test User\", email: \"test@example.com\" });\n\nconst result = mockGetUser(1);\nconsole.log(`Mock result: ${result.name}`);\nconsole.log(`Mock was called ${mockGetUser.calls.length} times`);\n\n// ===============================================================\n// 13. REAL-WORLD PATTERNS AND BEST PRACTICES\n// ===============================================================\nconsole.log(\"\\n\\nüî∑ REAL-WORLD PATTERNS\");\nconsole.log(\"=\".repeat(50));\n\n// Builder pattern with TypeScript\nclass ApiRequestBuilder {\n    private url: string = \"\";\n    private method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" = \"GET\";\n    private headers: Record<string, string> = {};\n    private body?: any;\n\n    setUrl(url: string): this {\n        this.url = url;\n        return this;\n    }\n\n    setMethod(method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\"): this {\n        this.method = method;\n        return this;\n    }\n\n    setHeader(key: string, value: string): this {\n        this.headers[key] = value;\n        return this;\n    }\n\n    setBody(body: any): this {\n        this.body = body;\n        return this;\n    }\n\n    build(): { url: string; method: string; headers: Record<string, string>; body?: any } {\n        if (!this.url) {\n            throw new Error(\"URL is required\");\n        }\n        return {\n            url: this.url,\n            method: this.method,\n            headers: this.headers,\n            body: this.body\n        };\n    }\n}\n\n// Factory pattern\ninterface Logger {\n    log(message: string): void;\n    error(message: string): void;\n}\n\nclass ConsoleLogger implements Logger {\n    log(message: string): void {\n        console.log(`[LOG] ${message}`);\n    }\n\n    error(message: string): void {\n        console.error(`[ERROR] ${message}`);\n    }\n}\n\nclass FileLogger implements Logger {\n    constructor(private filename: string) {}\n\n    log(message: string): void {\n        console.log(`[FILE LOG to ${this.filename}] ${message}`);\n    }\n\n    error(message: string): void {\n        console.log(`[FILE ERROR to ${this.filename}] ${message}`);\n    }\n}\n\nclass LoggerFactory {\n    static create(type: \"console\" | \"file\", filename?: string): Logger {\n        switch (type) {\n            case \"console\":\n                return new ConsoleLogger();\n            case \"file\":\n                if (!filename) throw new Error(\"Filename required for file logger\");\n                return new FileLogger(filename);\n            default:\n                throw new Error(`Unknown logger type: ${type}`);\n        }\n    }\n}\n\nconsole.log(`\\nüèóÔ∏è DESIGN PATTERNS:`);\n\nconst request = new ApiRequestBuilder()\n    .setUrl(\"https://api.example.com/users\")\n    .setMethod(\"POST\")\n    .setHeader(\"Content-Type\", \"application/json\")\n    .setBody({ name: \"John\", email: \"john@example.com\" })\n    .build();\n\nconsole.log(`Built request: ${request.method} ${request.url}`);\n\nconst logger = LoggerFactory.create(\"console\");\nlogger.log(\"Application started\");\n\n// Observer pattern with TypeScript\ninterface Observer<T> {\n    update(data: T): void;\n}\n\ninterface Subject<T> {\n    subscribe(observer: Observer<T>): void;\n    unsubscribe(observer: Observer<T>): void;\n    notify(data: T): void;\n}\n\nclass EventEmitter<T> implements Subject<T> {\n    private observers: Observer<T>[] = [];\n\n    subscribe(observer: Observer<T>): void {\n        this.observers.push(observer);\n    }\n\n    unsubscribe(observer: Observer<T>): void {\n        const index = this.observers.indexOf(observer);\n        if (index > -1) {\n            this.observers.splice(index, 1);\n        }\n    }\n\n    notify(data: T): void {\n        this.observers.forEach(observer => observer.update(data));\n    }\n}\n\nclass UserActivityObserver implements Observer<string> {\n    update(activity: string): void {\n        console.log(`User activity detected: ${activity}`);\n    }\n}\n\nconst activityEmitter = new EventEmitter<string>();\nconst activityObserver = new UserActivityObserver();\n\nactivityEmitter.subscribe(activityObserver);\nactivityEmitter.notify(\"User logged in\");\n\nconsole.log(\"\\nüöÄ TYPESCRIPT MASTERY COMPLETE!\");\nconsole.log(\"=\".repeat(60));\nconsole.log(\"üéØ Key Concepts Covered:\");\n\nconst conceptsCovered = [\n    \"‚úÖ Type System (primitives, arrays, tuples, enums)\",\n    \"‚úÖ Object Types and Interfaces\",\n    \"‚úÖ Union Types and Type Guards\", \n    \"‚úÖ Generics and Constraints\",\n    \"‚úÖ Advanced Types and Utility Types\",\n    \"‚úÖ Classes and Inheritance\",\n    \"‚úÖ Modules and Namespaces\",\n    \"‚úÖ Decorators and Metadata\",\n    \"‚úÖ Async/Await with Types\",\n    \"‚úÖ Error Handling Patterns\",\n    \"‚úÖ Performance Optimization\",\n    \"‚úÖ Type-Safe Testing\",\n    \"‚úÖ Real-World Design Patterns\"\n];\n\nconceptsCovered.forEach(concept => console.log(concept));\n\nconsole.log(\"\\nüéì NEXT STEPS FOR MASTERY:\");\nconst nextSteps = [\n    \"üìö Practice with real TypeScript projects\",\n    \"üîß Learn advanced compiler options\",\n    \"üèóÔ∏è Study framework-specific TypeScript (React, Angular, Vue)\",\n    \"üì¶ Master module resolution and bundling\",\n    \"üîç Learn advanced type manipulation techniques\",\n    \"üß™ Practice test-driven development with TypeScript\",\n    \"‚ö° Optimize build performance and bundle size\",\n    \"üåê Explore TypeScript in Node.js backend development\",\n    \"üìñ Study TypeScript compiler API\",\n    \"üéØ Master strict mode and advanced linting\"\n];\n\nnextSteps.forEach(step => console.log(step));\n\nconsole.log(\"\\n\" + \"=\".repeat(60));\nconsole.log(\"üéâ READY FOR SENIOR TYPESCRIPT DEVELOPER ROLES!\");\nconsole.log(\"üí™ Complete mastery achieved - from basics to advanced patterns!\");\nconsole.log(\"=\".repeat(60));\n```"}