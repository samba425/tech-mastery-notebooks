{"id":"python-guide","title":"üêç Python Complete Guide","content":"# üêç Python Complete Mastery Guide\n\n> **Complete Python Reference for Interview Preparation and Skill Mastery**  \n> From Beginner to Expert Level - All Concepts Covered\n\n---\n\n## üìö Table of Contents\n\n1. [Python Fundamentals](#1-python-fundamentals)\n2. [Data Structures](#2-data-structures)\n3. [Control Flow](#3-control-flow)\n4. [Functions](#4-functions)\n5. [Object-Oriented Programming](#5-object-oriented-programming)\n6. [Advanced Features](#6-advanced-features)\n7. [Modules and Packages](#7-modules-and-packages)\n8. [File Operations](#8-file-operations)\n9. [Algorithm Implementations](#9-algorithm-implementations)\n10. [Concurrency & Parallelism](#10-concurrency--parallelism)\n11. [Data Science Fundamentals](#11-data-science-fundamentals)\n12. [Web Development Basics](#12-web-development-basics)\n13. [Testing & Code Quality](#13-testing--code-quality)\n14. [Advanced Python Features](#14-advanced-python-features)\n15. [Best Practices](#15-best-practices)\n16. [Asynchronous Programming](#16-asynchronous-programming) ‚≠ê\n17. [REST APIs & FastAPI](#17-rest-apis--fastapi) ‚≠ê\n18. [Database Operations](#18-database-operations) ‚≠ê\n19. [Testing](#19-testing) ‚≠ê\n20. [Type Hints & Static Type Checking](#20-type-hints--static-type-checking) ‚≠ê\n21. [Python Interview Topics](#21-python-interview-topics) ‚≠ê\n22. [Exception Handling & Error Management](#22-exception-handling--error-management) üî• NEW\n23. [Regular Expressions (Regex)](#23-regular-expressions-regex) üî• NEW\n24. [Virtual Environments & Package Management](#24-virtual-environments--package-management) üî• NEW\n25. [Logging & Monitoring](#25-logging--monitoring) üî• NEW\n26. [Authentication & Security](#26-authentication--security) üî• NEW\n27. [Docker & Deployment](#27-docker--deployment) üî• NEW\n28. [Design Patterns](#28-design-patterns) üî• NEW\n29. [Caching & Performance Optimization](#29-caching--performance-optimization) üî• NEW\n\n---\n\n## 1. Python Fundamentals\n\n### Variables and Data Types\n\nPython is dynamically typed, meaning you don't need to declare variable types explicitly. Python supports several built-in data types including integers (whole numbers), floats (decimal numbers), strings (text), booleans (True/False), and None (represents absence of value). Understanding these fundamental types is crucial as they form the building blocks of all Python programs.\n\n```python\n# Basic data types\ninteger_var = 42\nfloat_var = 3.14159\nstring_var = \"Hello, Python!\"\nboolean_var = True\nnone_var = None\n\n# Type checking\nprint(type(integer_var))            # <class 'int'>\nprint(isinstance(string_var, str))  # True\n```\n\n### Type Conversions\n\nType conversion (also called type casting) allows you to convert data from one type to another. Python provides built-in functions like `int()`, `float()`, `str()`, and `bool()` for explicit type conversion. Understanding type conversion is essential when working with user input, file operations, or when performing operations that require specific data types.\n\n```python\n# String to number\nage = int(\"25\")            # 25\nprice = float(\"99.99\")     # 99.99\n\n# Number to string\ncount_str = str(100)       # \"100\"\n\n# Boolean conversions\nprint(bool(1))    # True\nprint(bool(0))    # False\nprint(bool(\"\"))   # False (empty string is falsy)\nprint(bool(\"hi\")) # True (non-empty string is truthy)\n```\n\n### String Operations\n\nStrings in Python are immutable sequences of characters. Python provides numerous built-in string methods for manipulation, searching, and formatting. Common operations include changing case, splitting/joining, searching for substrings, and replacing text. These methods are essential for text processing and data cleaning tasks.\n\n```python\ntext = \"Python Programming\"\n\n# Basic operations\nprint(f\"Length: {len(text)}\")           # Length: 18\nprint(f\"Upper: {text.upper()}\")         # Upper: PYTHON PROGRAMMING\nprint(f\"Lower: {text.lower()}\")         # Lower: python programming\nprint(f\"Split: {text.split()}\")         # Split: ['Python', 'Programming']\n\n# String methods\nprint(text.startswith(\"Python\"))  # True\nprint(text.endswith(\"ing\"))       # True\nprint(text.find(\"Program\"))       # 7 (index where \"Program\" starts)\nprint(text.replace(\"Python\", \"Advanced Python\"))  # \"Advanced Python Programming\"\n```\n\n### String Formatting\n\nString formatting allows you to create dynamic strings by inserting variables and expressions into text templates. Python offers three main approaches: f-strings (most modern and readable), the `format()` method, and the older % formatting. F-strings are the recommended approach in modern Python as they are more concise and readable.\n\n```python\nname = \"Alice\"\nage = 30\n\n# f-strings (Python 3.6+)\nmessage = f\"Hello, {name}! You are {age} years old.\"  # \"Hello, Alice! You are 30 years old.\"\n\n# format() method\nmessage = \"Hello, {}! You are {} years old.\".format(name, age)  # \"Hello, Alice! You are 30 years old.\"\n\n# % formatting (older style)\nmessage = \"Hello, %s! You are %d years old.\" % (name, age)  # \"Hello, Alice! You are 30 years old.\"\n```\n\n---\n\n## 2. Data Structures\n\n### Lists - Ordered, Mutable Collections\n\nLists are Python's most versatile data structure, storing ordered sequences of items that can be of different types. Unlike strings, lists are mutable, meaning you can modify their contents after creation. Lists support indexing, slicing, and numerous methods for adding, removing, and sorting elements, making them ideal for storing collections of data.\n\n```python\n# List creation and operations\nfruits = [\"apple\", \"banana\", \"cherry\"]\nnumbers = [1, 2, 3, 4, 5]\n\n# Accessing elements\nfirst_fruit = fruits[0]      # \"apple\"\nlast_fruit = fruits[-1]      # \"cherry\"\nsubset = fruits[1:3]         # [\"banana\", \"cherry\"]\n\n# List methods\nfruits.append(\"date\")        # fruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\nfruits.insert(1, \"orange\")   # fruits = [\"apple\", \"orange\", \"banana\", \"cherry\", \"date\"]\nremoved = fruits.pop()       # removed = \"date\", fruits = [\"apple\", \"orange\", \"banana\", \"cherry\"]\nfruits.remove(\"banana\")      # fruits = [\"apple\", \"orange\", \"cherry\"]\nfruits.sort()                # fruits = [\"apple\", \"cherry\", \"orange\"]\n```\n\n### List Comprehensions\n\nList comprehensions provide a concise way to create lists based on existing sequences or ranges. They combine the functionality of loops and conditional statements into a single, readable line of code. List comprehensions are more efficient and Pythonic than traditional for-loops for creating lists, and can include conditions and nested iterations.\n\n```python\n# Basic list comprehension\nsquares = [x**2 for x in range(1, 6)]  # [1, 4, 9, 16, 25]\n\n# With condition\neven_squares = [x**2 for x in range(1, 11) if x % 2 == 0]  # [4, 16, 36, 64, 100]\n\n# Nested comprehension\nmatrix = [[i*j for j in range(1, 4)] for i in range(1, 4)]  # [[1,2,3], [2,4,6], [3,6,9]]\n```\n\n### Tuples - Ordered, Immutable Collections\n\nTuples are ordered collections similar to lists, but they are immutable (cannot be modified after creation). This immutability makes tuples hashable and suitable for use as dictionary keys or set elements. Tuples are commonly used to store related data (like coordinates), return multiple values from functions, and ensure data integrity by preventing accidental modifications.\n\n```python\n# Tuple creation\ncoordinates = (10, 20)\ncolors = (\"red\", \"green\", \"blue\")\n\n# Tuple unpacking\nx, y = coordinates\nr, g, b = colors\n\n# Named tuples\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(10, 20)\nprint(p.x, p.y)  # 10 20\n```\n\n### Dictionaries - Key-Value Pairs\n\nDictionaries are unordered collections that store data in key-value pairs, providing fast lookups by key. Each key must be unique and immutable (strings, numbers, or tuples), while values can be any data type. Dictionaries are ideal for storing structured data like user profiles, configuration settings, or creating lookup tables, offering O(1) average time complexity for access operations.\n\n```python\n# Dictionary creation\nperson = {\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"city\": \"New York\"\n}\n\n# Accessing values\nname = person[\"name\"]           # KeyError if key doesn't exist\nage = person.get(\"age\", 0)      # Returns 0 if key doesn't exist\n\n# Dictionary methods\nkeys = person.keys()      # dict_keys(['name', 'age', 'city'])\nvalues = person.values()  # dict_values(['Alice', 30, 'New York'])\nitems = person.items()    # dict_items([('name', 'Alice'), ('age', 30), ('city', 'New York')])\n\n# Adding/updating\nperson[\"email\"] = \"alice@example.com\"           # Add new key-value pair\nperson.update({\"phone\": \"123-456-7890\"})        # Add/update multiple items\n```\n\n### Dictionary Comprehensions\n\nDictionary comprehensions provide a concise syntax for creating dictionaries, similar to list comprehensions. They allow you to build dictionaries from iterables or transform existing dictionaries in a single, readable expression. This feature is useful for data transformation, filtering, and creating mappings efficiently.\n\n```python\n# Basic dict comprehension\nsquares_dict = {x: x**2 for x in range(1, 6)}  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n# With condition\neven_squares_dict = {x: x**2 for x in range(1, 11) if x % 2 == 0}  # {2: 4, 4: 16, 6: 36, 8: 64, 10: 100}\n\n# From two lists\nkeys = [\"a\", \"b\", \"c\"]\nvalues = [1, 2, 3]\ncombined = {k: v for k, v in zip(keys, values)}  # {'a': 1, 'b': 2, 'c': 3}\n```\n\n### Sets - Unique Collections\n\nSets are unordered collections of unique elements, automatically removing duplicates. They support mathematical set operations like union, intersection, and difference, making them perfect for membership testing and eliminating duplicates. Sets offer O(1) average time complexity for add, remove, and membership tests, making them highly efficient for checking if an item exists in a collection.\n\n```python\n# Set creation\nnumbers = {1, 2, 3, 4, 5}\nunique_chars = set(\"hello\")  # {'h', 'e', 'l', 'o'}\n\n# Set operations\nset1 = {1, 2, 3, 4}\nset2 = {3, 4, 5, 6}\n\nunion = set1 | set2          # {1, 2, 3, 4, 5, 6} - all elements from both sets\nintersection = set1 & set2   # {3, 4} - common elements\ndifference = set1 - set2     # {1, 2} - elements in set1 but not set2\nsymmetric_diff = set1 ^ set2 # {1, 2, 5, 6} - elements in either set but not both\n```\n\n---\n\n## 3. Control Flow\n\n### Conditional Statements\n\nConditional statements allow your program to make decisions and execute different code blocks based on conditions. Python uses `if`, `elif` (else if), and `else` keywords to create branches in your code logic. The ternary operator provides a concise way to write simple if-else statements in a single line, useful for assignments and return statements.\n\n```python\n# Basic if-elif-else\nscore = 85\n\nif score >= 90:\n    grade = \"A\"\nelif score >= 80:\n    grade = \"B\"\nelif score >= 70:\n    grade = \"C\"\nelse:\n    grade = \"F\"\n\n# Ternary operator\nstatus = \"pass\" if score >= 60 else \"fail\"  # status = \"pass\" (since 85 >= 60)\n\n# Multiple conditions\nif score >= 80 and score < 90:\n    print(\"Good job!\")  # This will execute since 80 <= 85 < 90\n```\n\n### Loops\n\nLoops allow you to execute code repeatedly, either a fixed number of times (for loops) or while a condition is true (while loops). For loops are ideal for iterating over sequences like lists, strings, or ranges, while while loops continue until a condition becomes false. Python provides `break` to exit loops early and `continue` to skip to the next iteration, giving you fine control over loop execution.\n\n```python\n# For loops\nfor i in range(5):\n    print(i)  # 0, 1, 2, 3, 4\n\nfor fruit in [\"apple\", \"banana\", \"cherry\"]:\n    print(fruit)\n\n# Enumerate for index and value\nfor index, fruit in enumerate([\"apple\", \"banana\", \"cherry\"]):\n    print(f\"{index}: {fruit}\")\n\n# While loops\ncount = 0\nwhile count < 5:\n    print(count)\n    count += 1\n\n# Loop control\nfor i in range(10):\n    if i == 3:\n        continue  # Skip to next iteration\n    if i == 7:\n        break     # Exit loop\n    print(i)\n```\n\n### Advanced Iteration\n\nPython provides powerful iteration tools beyond basic loops. The `zip()` function combines multiple iterables for parallel iteration, perfect for processing related data together. Nested loops allow you to work with multi-dimensional data structures. The loop-else construct is a unique Python feature where the else block executes only if the loop completes without encountering a break statement, useful for search operations.\n\n```python\n# Zip for parallel iteration\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [25, 30, 35]\nfor name, age in zip(names, ages):\n    print(f\"{name} is {age} years old\")\n\n# Nested loops\nfor i in range(3):\n    for j in range(3):\n        print(f\"({i}, {j})\")\n\n# Loop with else (executes if loop completes normally)\nfor i in range(5):\n    if i == 10:\n        break\nelse:\n    print(\"Loop completed normally\")\n```\n\n---\n\n## 4. Functions\n\n### Basic Function Definition\n\nFunctions are reusable blocks of code that perform specific tasks, defined using the `def` keyword. They can accept input parameters and return output values, promoting code reusability and organization. Functions should have descriptive names and docstrings explaining their purpose, helping maintain clean, readable, and maintainable code.\n\n```python\ndef greet(name):\n    \"\"\"Return a greeting message.\"\"\"\n    return f\"Hello, {name}!\"\n\ndef add_numbers(a, b):\n    \"\"\"Add two numbers and return the result.\"\"\"\n    return a + b\n\n# Function calls\nmessage = greet(\"Alice\")    # \"Hello, Alice!\"\nresult = add_numbers(5, 3)  # 8\n```\n\n### Function Parameters\n\nPython functions support flexible parameter handling including default values, keyword arguments, and variable-length arguments. Default parameters provide fallback values when arguments aren't supplied. `*args` collects any number of positional arguments into a tuple, while `**kwargs` collects keyword arguments into a dictionary, making functions highly adaptable to different calling scenarios.\n\n```python\n# Default parameters\ndef greet(name, greeting=\"Hello\"):\n    return f\"{greeting}, {name}!\"\n\n# Keyword arguments\nprint(greet(\"Alice\"))                    # \"Hello, Alice!\"\nprint(greet(\"Bob\", greeting=\"Hi\"))       # \"Hi, Bob!\"\nprint(greet(greeting=\"Hey\", name=\"Charlie\"))  # \"Hey, Charlie!\"\n\n# Variable arguments\ndef sum_all(*args):\n    return sum(args)\n\ndef create_profile(**kwargs):\n    return kwargs\n\nresult = sum_all(1, 2, 3, 4, 5)  # 15\nprofile = create_profile(name=\"Alice\", age=30, city=\"NYC\")\n```\n\n### Lambda Functions\n\nLambda functions are anonymous, single-expression functions defined using the `lambda` keyword, ideal for short operations. They're commonly used with functions like `map()`, `filter()`, and `sorted()` when you need a simple function for a brief operation. While concise, lambdas should be used judiciously‚Äîfor complex logic, regular functions are more readable and maintainable.\n\n```python\n# Basic lambda\nsquare = lambda x: x**2\nprint(square(5))  # 25\n\n# Lambda with multiple arguments\nmultiply = lambda x, y: x * y\nprint(multiply(3, 4))  # 12\n\n# Using lambda with built-in functions\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, numbers))          # [1, 4, 9, 16, 25]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4]\n```\n\n### Higher-Order Functions\n\nHigher-order functions are functions that either accept other functions as arguments or return functions as results, enabling powerful functional programming patterns. They promote code reusability and abstraction by treating functions as first-class objects. Common examples include decorators, closures, and functions like `map()`, `filter()`, and `reduce()` that transform data using custom operations.\n\n```python\ndef apply_operation(numbers, operation):\n    \"\"\"Apply an operation to all numbers in a list.\"\"\"\n    return [operation(num) for num in numbers]\n\n# Using with lambda\ndoubled = apply_operation([1, 2, 3, 4], lambda x: x * 2)  # [2, 4, 6, 8]\n\n# Function as return value\ndef create_multiplier(factor):\n    def multiplier(x):\n        return x * factor\n    return multiplier\n\ndouble = create_multiplier(2)  # Returns a function that doubles\ntriple = create_multiplier(3)  # Returns a function that triples\nprint(double(5))   # 10\nprint(triple(5))   # 15\n```\n\n---\n\n## 5. Object-Oriented Programming\n\n### Basic Classes\n\nObject-Oriented Programming (OOP) organizes code into classes that bundle data (attributes) and behavior (methods) together. Classes serve as blueprints for creating objects (instances), enabling code reusability and logical organization. The `__init__` method is a constructor that initializes object attributes when an instance is created, while instance methods operate on individual objects.\n\n```python\nclass Person:\n    # Class variable\n    species = \"Homo sapiens\"\n    \n    def __init__(self, name, age):\n        self.name = name    # Instance variable\n        self.age = age      # Instance variable\n    \n    def introduce(self):\n        return f\"Hi, I'm {self.name} and I'm {self.age} years old.\"\n    \n    def have_birthday(self):\n        self.age += 1\n\n# Creating objects\nperson1 = Person(\"Alice\", 25)\nperson2 = Person(\"Bob\", 30)\n\nprint(person1.introduce())  # \"Hi, I'm Alice and I'm 25 years old.\"\nperson1.have_birthday()     # Increments age\nprint(person1.age)          # 26\n```\n\n### Inheritance\n\nInheritance allows classes to inherit attributes and methods from parent classes, promoting code reuse and establishing hierarchical relationships. Child classes can override parent methods to provide specialized behavior while maintaining the base interface. This enables polymorphism, where different objects can be treated uniformly through their common parent class interface.\n\n```python\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} says Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return f\"{self.name} says Meow!\"\n\n# Using inheritance\ndog = Dog(\"Buddy\")\ncat = Cat(\"Whiskers\")\nprint(dog.speak())  # \"Buddy says Woof!\"\nprint(cat.speak())  # \"Whiskers says Meow!\"\n```\n\n### Special Methods (Magic Methods)\n\nSpecial methods (also called dunder methods, from \"double underscore\") customize how objects behave with built-in Python operations. Methods like `__str__` and `__repr__` control string representation, `__len__` enables the `len()` function, and `__eq__` defines equality comparison. These methods allow your custom classes to integrate seamlessly with Python's syntax and built-in functions.\n\n```python\nclass Book:\n    def __init__(self, title, author, pages):\n        self.title = title\n        self.author = author\n        self.pages = pages\n    \n    def __str__(self):\n        return f\"{self.title} by {self.author}\"\n    \n    def __repr__(self):\n        return f\"Book('{self.title}', '{self.author}', {self.pages})\"\n    \n    def __len__(self):\n        return self.pages\n    \n    def __eq__(self, other):\n        return (self.title == other.title and \n                self.author == other.author)\n\nbook = Book(\"1984\", \"George Orwell\", 328)\nprint(str(book))    # \"1984 by George Orwell\" (calls __str__)\nprint(len(book))    # 328 (calls __len__)\nprint(repr(book))   # Book('1984', 'George Orwell', 328) (calls __repr__)\n```\n\n### Method Types\n\nPython classes support three types of methods: instance methods (work with instance data), class methods (work with class-level data using `@classmethod` decorator), and static methods (independent utilities using `@staticmethod` decorator). Instance methods receive `self` to access instance attributes, class methods receive `cls` to access class attributes, and static methods receive neither, acting as utility functions namespaced within the class.\n\n```python\nclass Calculator:\n    pi = 3.14159\n    \n    def __init__(self, name):\n        self.name = name\n    \n    def add(self, a, b):\n        \"\"\"Instance method\"\"\"\n        return a + b\n    \n    @classmethod\n    def get_pi(cls):\n        \"\"\"Class method - operates on the class\"\"\"\n        return cls.pi\n    \n    @staticmethod\n    def multiply(a, b):\n        \"\"\"Static method - independent function\"\"\"\n        return a * b\n\ncalc = Calculator(\"MyCal\")\nprint(calc.add(2, 3))            # 5 (instance method - uses self)\nprint(Calculator.get_pi())       # 3.14159 (class method - uses cls)\nprint(Calculator.multiply(4, 5)) # 20 (static method - independent utility)\n```\n\n### SOLID Principles in Python\n\nThe SOLID principles are five design principles that make software designs more understandable, flexible, and maintainable.\n\n#### 1. Single Responsibility Principle (SRP)\n*\"A class should have only one reason to change\"*\n\n```python\n# ‚ùå Bad - Multiple responsibilities\nclass User:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n    \n    def save_to_database(self):\n        # Database logic\n        pass\n    \n    def send_email(self):\n        # Email logic\n        pass\n\n# ‚úÖ Good - Single responsibility per class\nclass User:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\nclass UserRepository:\n    def save(self, user):\n        # Database logic\n        pass\n\nclass EmailService:\n    def send_email(self, user, message):\n        # Email logic\n        pass\n```\n\n#### 2. Open/Closed Principle (OCP)\n*\"Classes should be open for extension, but closed for modification\"*\n\n```python\n# ‚úÖ Good - Using inheritance for extension\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14159 * self.radius ** 2\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\nclass AreaCalculator:\n    def total_area(self, shapes):\n        return sum(shape.area() for shape in shapes)\n\n# Adding new shapes doesn't modify existing code\nclass Triangle(Shape):\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n    \n    def area(self):\n        return 0.5 * self.base * self.height\n```\n\n#### 3. Liskov Substitution Principle (LSP)\n*\"Objects of a superclass should be replaceable with objects of its subclasses\"*\n\n```python\n# ‚úÖ Good - Proper inheritance\nclass Bird(ABC):\n    @abstractmethod\n    def move(self):\n        pass\n\nclass FlyingBird(Bird):\n    def move(self):\n        return \"Flying\"\n    \n    def fly(self):\n        return \"Flying high\"\n\nclass WalkingBird(Bird):\n    def move(self):\n        return \"Walking\"\n    \n    def walk(self):\n        return \"Walking on ground\"\n\nclass Eagle(FlyingBird):\n    def fly(self):\n        return \"Soaring through the sky\"\n\nclass Penguin(WalkingBird):\n    def walk(self):\n        return \"Waddling on ice\"\n\n# All birds can be used interchangeably for movement\ndef make_bird_move(bird: Bird):\n    return bird.move()\n\neagle = Eagle()\npenguin = Penguin()\nprint(make_bird_move(eagle))    # \"Flying\"\nprint(make_bird_move(penguin))  # \"Walking\"\n```\n\n#### 4. Interface Segregation Principle (ISP)\n*\"Clients should not be forced to depend on interfaces they don't use\"*\n\n```python\n# ‚ùå Bad - Fat interface\nclass Worker(ABC):\n    @abstractmethod\n    def work(self):\n        pass\n    \n    @abstractmethod\n    def eat(self):\n        pass\n\n# ‚úÖ Good - Segregated interfaces\nclass Workable(ABC):\n    @abstractmethod\n    def work(self):\n        pass\n\nclass Eatable(ABC):\n    @abstractmethod\n    def eat(self):\n        pass\n\nclass Human(Workable, Eatable):\n    def work(self):\n        return \"Human working\"\n    \n    def eat(self):\n        return \"Human eating\"\n\nclass Robot(Workable):\n    def work(self):\n        return \"Robot working\"\n    # Robot doesn't need to implement eat()\n```\n\n#### 5. Dependency Inversion Principle (DIP)\n*\"Depend on abstractions, not concretions\"*\n\n```python\n# ‚ùå Bad - High-level module depends on low-level module\nclass FileLogger:\n    def log(self, message):\n        with open(\"log.txt\", \"a\") as f:\n            f.write(f\"{message}\\n\")\n\nclass UserService:\n    def __init__(self):\n        self.logger = FileLogger()  # Direct dependency\n    \n    def create_user(self, user):\n        # Create user logic\n        self.logger.log(f\"User {user.name} created\")\n\n# ‚úÖ Good - Depend on abstraction\nclass Logger(ABC):\n    @abstractmethod\n    def log(self, message):\n        pass\n\nclass FileLogger(Logger):\n    def log(self, message):\n        with open(\"log.txt\", \"a\") as f:\n            f.write(f\"{message}\\n\")\n\nclass DatabaseLogger(Logger):\n    def log(self, message):\n        # Log to database\n        pass\n\nclass UserService:\n    def __init__(self, logger: Logger):\n        self.logger = logger  # Depends on abstraction\n    \n    def create_user(self, user):\n        # Create user logic\n        self.logger.log(f\"User {user.name} created\")\n\n# Usage with dependency injection\nfile_logger = FileLogger()\nuser_service = UserService(file_logger)\n```\n\n#### SOLID Principles Summary\n\n```python\n# Example combining all SOLID principles\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\n# Interfaces (ISP)\nclass Readable(ABC):\n    @abstractmethod\n    def read(self) -> str:\n        pass\n\nclass Writable(ABC):\n    @abstractmethod\n    def write(self, data: str) -> None:\n        pass\n\n# Single Responsibility (SRP)\nclass FileReader(Readable):\n    def __init__(self, filename: str):\n        self.filename = filename\n    \n    def read(self) -> str:\n        with open(self.filename, 'r') as f:\n            return f.read()\n\nclass FileWriter(Writable):\n    def __init__(self, filename: str):\n        self.filename = filename\n    \n    def write(self, data: str) -> None:\n        with open(self.filename, 'w') as f:\n            f.write(data)\n\n# Open/Closed Principle (OCP) & Liskov Substitution (LSP)\nclass DataProcessor(ABC):\n    @abstractmethod\n    def process(self, data: str) -> str:\n        pass\n\nclass UpperCaseProcessor(DataProcessor):\n    def process(self, data: str) -> str:\n        return data.upper()\n\nclass JSONProcessor(DataProcessor):\n    def process(self, data: str) -> str:\n        import json\n        return json.dumps({\"data\": data})\n\n# Dependency Inversion (DIP)\nclass DocumentService:\n    def __init__(self, reader: Readable, writer: Writable, processor: DataProcessor):\n        self.reader = reader\n        self.writer = writer\n        self.processor = processor\n    \n    def process_document(self):\n        data = self.reader.read()\n        processed_data = self.processor.process(data)\n        self.writer.write(processed_data)\n\n# Usage\nreader = FileReader(\"input.txt\")\nwriter = FileWriter(\"output.txt\")\nprocessor = UpperCaseProcessor()\nservice = DocumentService(reader, writer, processor)\nservice.process_document()\n```\n\n---\n\n## 6. Advanced Features\n\n### Decorators\n\nDecorators are functions that modify or enhance other functions without changing their source code. They use the `@decorator_name` syntax and follow the wrapper pattern, taking a function as input and returning a modified version. Decorators are commonly used for logging, authentication, timing, caching, and input validation, making them essential for clean, maintainable code.\n\n```python\n# Basic decorator\ndef my_decorator(func):\n    def wrapper():\n        print(\"Before function call\")\n        result = func()\n        print(\"After function call\")\n        return result\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()\n# Output:\n# Before function call\n# Hello!\n# After function call\n\n# Decorator with arguments\ndef repeat(times):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Alice\")  # Prints \"Hello, Alice!\" three times\n```\n\n### Generators\n\nGenerators are memory-efficient iterators that produce values on-the-fly using the `yield` keyword instead of storing entire sequences in memory. They maintain their state between calls, making them perfect for processing large datasets or infinite sequences. Generator expressions (similar to list comprehensions but with parentheses) provide a concise way to create generators for simple transformations.\n\n```python\ndef count_up_to(max_count):\n    count = 1\n    while count <= max_count:\n        yield count\n        count += 1\n\n# Using generator\ncounter = count_up_to(5)\nfor num in counter:\n    print(num)  # 1, 2, 3, 4, 5\n\n# Generator expressions\nsquares = (x**2 for x in range(10))\nprint(list(squares))  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n# Fibonacci generator\ndef fibonacci():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nfib = fibonacci()\nprint([next(fib) for _ in range(10)])  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n```\n\n### Context Managers\n\nContext managers handle resource management by automatically setting up and tearing down resources using the `with` statement. They implement `__enter__` and `__exit__` methods to ensure proper cleanup even if errors occur. Context managers are essential for managing files, database connections, locks, and other resources that need guaranteed cleanup, preventing resource leaks.\n\n```python\n# Using with statement\nwith open('file.txt', 'w') as f:\n    f.write(\"Hello, World!\")\n# File is automatically closed\n\n# Custom context manager\nclass Timer:\n    def __enter__(self):\n        import time\n        self.start = time.time()\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        import time\n        self.end = time.time()\n        print(f\"Elapsed time: {self.end - self.start:.4f} seconds\")\n\nwith Timer():\n    import time\n    time.sleep(1)\n# Output: Elapsed time: 1.0001 seconds\n\n# Using contextlib\nfrom contextlib import contextmanager\n\n@contextmanager\ndef file_manager(filename, mode):\n    print(f\"Opening {filename}\")\n    f = open(filename, mode)\n    try:\n        yield f\n    finally:\n        print(f\"Closing {filename}\")\n        f.close()\n```\n\n---\n\n## 7. Modules and Packages\n\n### Importing Modules\n\nModules are Python files containing reusable code (functions, classes, variables) that can be imported into other programs. Python's import system supports various styles: importing entire modules, specific items, or using aliases for convenience. The standard library provides numerous built-in modules for common tasks, eliminating the need to write code from scratch for many operations.\n\n```python\n# Different import styles\nimport math\nfrom math import pi, sqrt\nfrom datetime import datetime as dt\nimport json as js\n\n# Using imported modules\nprint(math.pi)      # 3.141592653589793\nprint(sqrt(16))     # 4.0\nprint(dt.now())     # Current datetime\n\n# Standard library modules\nimport os\nimport sys\nimport random\nfrom collections import defaultdict, Counter\n```\n\n### Creating Custom Modules\n\n```python\n# my_module.py\ndef calculate_area(radius):\n    \"\"\"Calculate area of a circle.\"\"\"\n    import math\n    return math.pi * radius ** 2\n\ndef calculate_circumference(radius):\n    \"\"\"Calculate circumference of a circle.\"\"\"\n    import math\n    return 2 * math.pi * radius\n\nPI = 3.14159\n\n# main.py\nimport my_module\n\narea = my_module.calculate_area(5)\ncircumference = my_module.calculate_circumference(5)\n```\n\n### Package Structure\n\nPackages are directories containing Python modules organized hierarchically, with an `__init__.py` file marking them as packages. Packages enable better code organization for larger projects by grouping related modules together. Subpackages create nested namespaces, making it easier to manage and maintain large codebases with logical structure and clear separation of concerns.\n\n```\nmy_package/\n    __init__.py\n    module1.py\n    module2.py\n    subpackage/\n        __init__.py\n        submodule.py\n```\n\n```python\n# Importing from packages\nfrom my_package import module1\nfrom my_package.subpackage import submodule\n```\n\n---\n\n## 8. File Operations\n\n### Reading Files\n\nFile operations in Python are handled through built-in functions and the `with` statement for automatic resource management. Python provides multiple ways to read files: `read()` loads the entire content, iterating line-by-line is memory-efficient for large files, and `readlines()` creates a list of all lines. Always use the `with` statement to ensure proper file closure even if errors occur.\n\n```python\n# Reading entire file\nwith open('file.txt', 'r') as f:\n    content = f.read()\n\n# Reading line by line\nwith open('file.txt', 'r') as f:\n    for line in f:\n        print(line.strip())\n\n# Reading all lines into a list\nwith open('file.txt', 'r') as f:\n    lines = f.readlines()\n```\n\n### Writing Files\n\nPython supports different file writing modes: 'w' for writing (overwrites existing content), 'a' for appending (adds to end of file), and 'w+' for reading and writing. The `write()` method writes strings to files, while `writelines()` writes a list of strings. Understanding file modes prevents accidental data loss and enables proper file manipulation for various use cases.\n\n```python\n# Writing to file (overwrites existing)\nwith open('output.txt', 'w') as f:\n    f.write(\"Hello, World!\\n\")\n    f.write(\"This is a new line.\\n\")\n\n# Appending to file\nwith open('output.txt', 'a') as f:\n    f.write(\"This is appended.\\n\")\n\n# Writing multiple lines\nlines = [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\\n\"]\nwith open('output.txt', 'w') as f:\n    f.writelines(lines)\n```\n\n### Working with JSON\n\nJSON (JavaScript Object Notation) is a popular data interchange format used extensively in APIs and configuration files. Python's `json` module provides `dump()`/`load()` for file operations and `dumps()`/`loads()` for string operations. JSON seamlessly converts between Python dictionaries/lists and JSON format, making it essential for web development, API integration, and data storage.\n\n```python\nimport json\n\n# Writing JSON\ndata = {\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"skills\": [\"Python\", \"JavaScript\", \"SQL\"]\n}\n\nwith open('data.json', 'w') as f:\n    json.dump(data, f, indent=2)\n\n# Reading JSON\nwith open('data.json', 'r') as f:\n    loaded_data = json.load(f)\n\n# JSON strings\njson_string = json.dumps(data, indent=2)\nparsed_data = json.loads(json_string)\n```\n\n---\n\n## 9. Algorithm Implementations\n\n### Sorting Algorithms\n\nSorting algorithms arrange elements in a specific order (ascending/descending) and are fundamental to computer science. Different algorithms have varying time/space complexities: Bubble Sort (O(n¬≤)) is simple but inefficient, Quick Sort (O(n log n) average) is fast and widely used, while Merge Sort (O(n log n) guaranteed) is stable and predictable. Understanding these algorithms is crucial for technical interviews and choosing optimal solutions.\n\n```python\ndef bubble_sort(arr):\n    \"\"\"Bubble sort implementation.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\ndef quick_sort(arr):\n    \"\"\"Quick sort implementation.\"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return quick_sort(left) + middle + quick_sort(right)\n\ndef merge_sort(arr):\n    \"\"\"Merge sort implementation.\"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n```\n\n### Search Algorithms\n\n```python\ndef binary_search(arr, target):\n    \"\"\"Binary search implementation.\"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1  # Not found\n\ndef linear_search(arr, target):\n    \"\"\"Linear search implementation.\"\"\"\n    for i, value in enumerate(arr):\n        if value == target:\n            return i\n    return -1  # Not found\n```\n\n### Dynamic Programming\n\nDynamic Programming (DP) optimizes recursive problems by storing (memoizing) previously calculated results to avoid redundant computations. This technique transforms exponential time algorithms into polynomial time solutions. DP is essential for solving optimization problems like the knapsack problem, longest common subsequence, and shortest path algorithms, making it a critical skill for technical interviews.\n\n```python\ndef fibonacci_dp(n, memo={}):\n    \"\"\"Fibonacci with memoization.\"\"\"\n    if n in memo:\n        return memo[n]\n    if n <= 2:\n        return 1\n    memo[n] = fibonacci_dp(n-1, memo) + fibonacci_dp(n-2, memo)\n    return memo[n]\n\ndef knapsack(weights, values, capacity):\n    \"\"\"0/1 Knapsack problem.\"\"\"\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(\n                    values[i-1] + dp[i-1][w - weights[i-1]],\n                    dp[i-1][w]\n                )\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    return dp[n][capacity]\n```\n\n---\n\n## 10. Concurrency & Parallelism\n\n### Threading\n\nThreading allows multiple tasks to run concurrently within a single process, sharing the same memory space. Python's `threading` module is ideal for I/O-bound tasks (file operations, network requests) where threads wait for external resources. Note: Due to Python's Global Interpreter Lock (GIL), threading doesn't provide true parallelism for CPU-bound tasks, but it's perfect for improving responsiveness in I/O-heavy applications.\n\n```python\nimport threading\nimport time\n\ndef worker_function(name, duration):\n    \"\"\"Simulate work in a thread.\"\"\"\n    print(f\"Worker {name} starting...\")\n    time.sleep(duration)\n    print(f\"Worker {name} finished\")\n\n# Creating and starting threads\nthreads = []\nfor i in range(3):\n    thread = threading.Thread(\n        target=worker_function, \n        args=(f\"Thread-{i}\", 1)\n    )\n    threads.append(thread)\n    thread.start()\n\n# Wait for all threads to complete\nfor thread in threads:\n    thread.join()\n\n# Thread-safe operations\nclass ThreadSafeCounter:\n    def __init__(self):\n        self._value = 0\n        self._lock = threading.Lock()\n    \n    def increment(self):\n        with self._lock:\n            self._value += 1\n    \n    def get_value(self):\n        with self._lock:\n            return self._value\n```\n\n### Asyncio\n\n```python\nimport asyncio\n\nasync def fetch_data(url, delay):\n    \"\"\"Simulate async data fetching.\"\"\"\n    print(f\"Starting to fetch {url}\")\n    await asyncio.sleep(delay)  # Simulate network delay\n    print(f\"Finished fetching {url}\")\n    return f\"Data from {url}\"\n\nasync def main():\n    \"\"\"Run multiple async operations concurrently.\"\"\"\n    tasks = [\n        fetch_data(\"url1\", 1),\n        fetch_data(\"url2\", 2),\n        fetch_data(\"url3\", 1.5)\n    ]\n    \n    results = await asyncio.gather(*tasks)\n    return results\n\n# Run async code\n# results = asyncio.run(main())\n```\n\n### Multiprocessing\n\n```python\nimport multiprocessing\n\ndef cpu_intensive_task(n):\n    \"\"\"CPU intensive task for multiprocessing.\"\"\"\n    total = 0\n    for i in range(n):\n        total += i ** 2\n    return total\n\ndef parallel_processing():\n    \"\"\"Use multiprocessing for CPU-bound tasks.\"\"\"\n    with multiprocessing.Pool() as pool:\n        tasks = [1000000] * 4\n        results = pool.map(cpu_intensive_task, tasks)\n    return results\n\n# Thread vs Process pools\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor\n\ndef concurrent_execution():\n    # Thread pool for I/O-bound tasks\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        futures = [executor.submit(fetch_data, f\"url{i}\", 1) for i in range(4)]\n        thread_results = [f.result() for f in futures]\n    \n    # Process pool for CPU-bound tasks\n    with ProcessPoolExecutor(max_workers=4) as executor:\n        futures = [executor.submit(cpu_intensive_task, 100000) for _ in range(4)]\n        process_results = [f.result() for f in futures]\n    \n    return thread_results, process_results\n```\n\n### Advanced Threading Patterns\n\n```python\nimport threading\nimport queue\nimport time\nfrom typing import Any, Callable\n\n# Thread Pool Pattern\nclass ThreadPool:\n    \"\"\"Custom thread pool for managing worker threads.\"\"\"\n    \n    def __init__(self, num_workers: int = 4):\n        self.task_queue = queue.Queue()\n        self.workers = []\n        self.results = []\n        self._lock = threading.Lock()\n        \n        # Create worker threads\n        for _ in range(num_workers):\n            worker = threading.Thread(target=self._worker, daemon=True)\n            worker.start()\n            self.workers.append(worker)\n    \n    def _worker(self):\n        \"\"\"Worker thread that processes tasks from queue.\"\"\"\n        while True:\n            try:\n                func, args, kwargs = self.task_queue.get(timeout=1)\n                result = func(*args, **kwargs)\n                with self._lock:\n                    self.results.append(result)\n                self.task_queue.task_done()\n            except queue.Empty:\n                continue\n    \n    def submit(self, func: Callable, *args, **kwargs):\n        \"\"\"Submit a task to the thread pool.\"\"\"\n        self.task_queue.put((func, args, kwargs))\n    \n    def wait_completion(self):\n        \"\"\"Wait for all tasks to complete.\"\"\"\n        self.task_queue.join()\n        return self.results\n\n# Usage\ndef download_file(url: str) -> str:\n    \"\"\"Simulate file download (I/O-bound).\"\"\"\n    time.sleep(1)\n    return f\"Downloaded {url}\"\n\npool = ThreadPool(num_workers=4)\nurls = [f\"https://example.com/file{i}.txt\" for i in range(10)]\n\nfor url in urls:\n    pool.submit(download_file, url)\n\nresults = pool.wait_completion()\nprint(f\"Downloaded {len(results)} files\")\n\n# Producer-Consumer Pattern with Threading\nclass ProducerConsumer:\n    \"\"\"Producer-Consumer pattern using threads and queue.\"\"\"\n    \n    def __init__(self, num_consumers: int = 3):\n        self.task_queue = queue.Queue(maxsize=10)\n        self.num_consumers = num_consumers\n        self.stop_event = threading.Event()\n    \n    def producer(self, items: list):\n        \"\"\"Producer adds items to queue.\"\"\"\n        for item in items:\n            self.task_queue.put(item)\n            print(f\"Produced: {item}\")\n            time.sleep(0.1)\n        \n        # Signal completion\n        for _ in range(self.num_consumers):\n            self.task_queue.put(None)  # Poison pill\n    \n    def consumer(self, consumer_id: int):\n        \"\"\"Consumer processes items from queue.\"\"\"\n        while True:\n            item = self.task_queue.get()\n            if item is None:  # Poison pill received\n                break\n            \n            # Process item\n            print(f\"Consumer {consumer_id} processing: {item}\")\n            time.sleep(0.5)\n            self.task_queue.task_done()\n    \n    def run(self, items: list):\n        \"\"\"Start producer and consumers.\"\"\"\n        # Start consumers\n        consumers = []\n        for i in range(self.num_consumers):\n            t = threading.Thread(target=self.consumer, args=(i,))\n            t.start()\n            consumers.append(t)\n        \n        # Start producer\n        producer_thread = threading.Thread(target=self.producer, args=(items,))\n        producer_thread.start()\n        \n        # Wait for completion\n        producer_thread.join()\n        for t in consumers:\n            t.join()\n\n# Usage\npc = ProducerConsumer(num_consumers=3)\nitems = list(range(20))\npc.run(items)\n\n# Thread Synchronization Primitives\nclass ThreadSynchronization:\n    \"\"\"Demonstrate various thread synchronization mechanisms.\"\"\"\n    \n    def __init__(self):\n        self.lock = threading.Lock()\n        self.rlock = threading.RLock()  # Reentrant lock\n        self.semaphore = threading.Semaphore(3)  # Allow 3 threads max\n        self.event = threading.Event()\n        self.condition = threading.Condition()\n        self.barrier = threading.Barrier(3)  # Wait for 3 threads\n    \n    def lock_example(self):\n        \"\"\"Basic lock usage.\"\"\"\n        with self.lock:\n            # Critical section - only one thread at a time\n            print(f\"{threading.current_thread().name} acquired lock\")\n            time.sleep(1)\n    \n    def semaphore_example(self, worker_id: int):\n        \"\"\"Limit concurrent access to resource.\"\"\"\n        with self.semaphore:\n            print(f\"Worker {worker_id} accessing resource\")\n            time.sleep(2)\n            print(f\"Worker {worker_id} releasing resource\")\n    \n    def event_example_waiter(self):\n        \"\"\"Wait for event to be set.\"\"\"\n        print(\"Waiting for event...\")\n        self.event.wait()  # Block until event is set\n        print(\"Event received! Continuing...\")\n    \n    def event_example_setter(self):\n        \"\"\"Set event after delay.\"\"\"\n        time.sleep(2)\n        print(\"Setting event\")\n        self.event.set()\n    \n    def condition_example_consumer(self):\n        \"\"\"Wait for condition to be notified.\"\"\"\n        with self.condition:\n            print(\"Consumer waiting...\")\n            self.condition.wait()\n            print(\"Consumer notified!\")\n    \n    def condition_example_producer(self):\n        \"\"\"Notify waiting threads.\"\"\"\n        time.sleep(1)\n        with self.condition:\n            print(\"Producer notifying...\")\n            self.condition.notify_all()\n    \n    def barrier_example(self, worker_id: int):\n        \"\"\"Synchronize multiple threads at a point.\"\"\"\n        print(f\"Worker {worker_id} reached barrier\")\n        self.barrier.wait()  # Wait for all threads\n        print(f\"Worker {worker_id} passed barrier\")\n\n# Thread-Safe Data Structures\nclass ThreadSafeDict:\n    \"\"\"Thread-safe dictionary using RLock.\"\"\"\n    \n    def __init__(self):\n        self._dict = {}\n        self._lock = threading.RLock()\n    \n    def get(self, key: Any, default=None):\n        with self._lock:\n            return self._dict.get(key, default)\n    \n    def set(self, key: Any, value: Any):\n        with self._lock:\n            self._dict[key] = value\n    \n    def increment(self, key: Any, amount: int = 1):\n        with self._lock:\n            self._dict[key] = self._dict.get(key, 0) + amount\n    \n    def items(self):\n        with self._lock:\n            return list(self._dict.items())\n```\n\n### Advanced Multiprocessing\n\n```python\nimport multiprocessing as mp\nfrom multiprocessing import Process, Queue, Pipe, Manager, Pool\nimport os\nimport time\n\n# Process Pool with Progress Tracking\ndef cpu_bound_task(n: int) -> tuple:\n    \"\"\"CPU-intensive task that returns result.\"\"\"\n    result = sum(i * i for i in range(n))\n    return (os.getpid(), result)\n\ndef parallel_processing_with_pool():\n    \"\"\"Use Pool for parallel processing.\"\"\"\n    with mp.Pool(processes=4) as pool:\n        tasks = [1000000, 2000000, 3000000, 4000000]\n        \n        # Map - blocks until all complete\n        results = pool.map(cpu_bound_task, tasks)\n        \n        # Map async - non-blocking\n        async_result = pool.map_async(cpu_bound_task, tasks)\n        results = async_result.get()\n        \n        # Apply - single task\n        result = pool.apply(cpu_bound_task, (1000000,))\n        \n        # Apply async - single task non-blocking\n        async_result = pool.apply_async(cpu_bound_task, (1000000,))\n        result = async_result.get()\n    \n    return results\n\n# Inter-Process Communication with Queue\ndef producer_process(queue: Queue, items: list):\n    \"\"\"Producer adds items to queue.\"\"\"\n    for item in items:\n        queue.put(item)\n        print(f\"Produced: {item} by PID {os.getpid()}\")\n        time.sleep(0.1)\n    queue.put(None)  # Signal completion\n\ndef consumer_process(queue: Queue, consumer_id: int):\n    \"\"\"Consumer processes items from queue.\"\"\"\n    while True:\n        item = queue.get()\n        if item is None:\n            break\n        print(f\"Consumer {consumer_id} (PID {os.getpid()}) consumed: {item}\")\n        time.sleep(0.2)\n\ndef multiprocess_queue_example():\n    \"\"\"Demonstrate multiprocessing with Queue.\"\"\"\n    queue = mp.Queue()\n    items = list(range(10))\n    \n    # Start producer\n    producer = Process(target=producer_process, args=(queue, items))\n    producer.start()\n    \n    # Start consumers\n    consumers = []\n    for i in range(3):\n        consumer = Process(target=consumer_process, args=(queue, i))\n        consumer.start()\n        consumers.append(consumer)\n    \n    # Wait for completion\n    producer.join()\n    for consumer in consumers:\n        queue.put(None)  # Send poison pill to each consumer\n    for consumer in consumers:\n        consumer.join()\n\n# Shared Memory Between Processes\ndef shared_memory_example():\n    \"\"\"Share data between processes using Manager.\"\"\"\n    manager = Manager()\n    shared_dict = manager.dict()\n    shared_list = manager.list()\n    \n    def worker(worker_id: int, shared_dict, shared_list):\n        shared_dict[worker_id] = f\"Result from worker {worker_id}\"\n        shared_list.append(worker_id * 10)\n        print(f\"Worker {worker_id} (PID {os.getpid()}) updated shared data\")\n    \n    processes = []\n    for i in range(5):\n        p = Process(target=worker, args=(i, shared_dict, shared_list))\n        p.start()\n        processes.append(p)\n    \n    for p in processes:\n        p.join()\n    \n    print(\"Shared dict:\", dict(shared_dict))\n    print(\"Shared list:\", list(shared_list))\n\n# Process Pool with Callback\ndef task_with_callback(n: int) -> int:\n    \"\"\"Task that will trigger callback on completion.\"\"\"\n    return n * n\n\ndef on_task_complete(result):\n    \"\"\"Callback function called when task completes.\"\"\"\n    print(f\"Task completed with result: {result}\")\n\ndef pool_with_callbacks():\n    \"\"\"Use callbacks with async pool.\"\"\"\n    with mp.Pool(processes=4) as pool:\n        for i in range(10):\n            pool.apply_async(\n                task_with_callback,\n                args=(i,),\n                callback=on_task_complete\n            )\n        pool.close()\n        pool.join()\n\n# Process Synchronization\ndef process_synchronization_example():\n    \"\"\"Demonstrate process synchronization primitives.\"\"\"\n    lock = mp.Lock()\n    semaphore = mp.Semaphore(2)\n    event = mp.Event()\n    \n    def worker_with_lock(worker_id: int, lock):\n        with lock:\n            print(f\"Worker {worker_id} acquired lock\")\n            time.sleep(1)\n    \n    def worker_with_semaphore(worker_id: int, semaphore):\n        with semaphore:\n            print(f\"Worker {worker_id} acquired semaphore\")\n            time.sleep(2)\n    \n    # Create processes with lock\n    processes = []\n    for i in range(3):\n        p = Process(target=worker_with_lock, args=(i, lock))\n        p.start()\n        processes.append(p)\n    \n    for p in processes:\n        p.join()\n```\n\n### Advanced Asyncio Patterns\n\n```python\nimport asyncio\nimport aiohttp\nimport aiof files\nfrom typing import List\nimport time\n\n# Async HTTP Requests with aiohttp\nasync def fetch_url(session: aiohttp.ClientSession, url: str) -> str:\n    \"\"\"Fetch URL asynchronously.\"\"\"\n    try:\n        async with session.get(url, timeout=5) as response:\n            return await response.text()\n    except Exception as e:\n        return f\"Error: {e}\"\n\nasync def fetch_multiple_urls(urls: List[str]):\n    \"\"\"Fetch multiple URLs concurrently.\"\"\"\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        return results\n\n# Async File Operations\nasync def read_file_async(filepath: str) -> str:\n    \"\"\"Read file asynchronously.\"\"\"\n    async with aiofiles.open(filepath, 'r') as f:\n        content = await f.read()\n        return content\n\nasync def write_file_async(filepath: str, content: str):\n    \"\"\"Write file asynchronously.\"\"\"\n    async with aiofiles.open(filepath, 'w') as f:\n        await f.write(content)\n\n# Async Queue for Producer-Consumer\nasync def async_producer(queue: asyncio.Queue, items: List[int]):\n    \"\"\"Async producer adds items to queue.\"\"\"\n    for item in items:\n        await queue.put(item)\n        print(f\"Produced: {item}\")\n        await asyncio.sleep(0.1)\n    await queue.put(None)  # Signal completion\n\nasync def async_consumer(queue: asyncio.Queue, consumer_id: int):\n    \"\"\"Async consumer processes items from queue.\"\"\"\n    while True:\n        item = await queue.get()\n        if item is None:\n            queue.task_done()\n            break\n        \n        print(f\"Consumer {consumer_id} processing: {item}\")\n        await asyncio.sleep(0.5)\n        queue.task_done()\n\nasync def async_producer_consumer():\n    \"\"\"Run async producer-consumer pattern.\"\"\"\n    queue = asyncio.Queue(maxsize=5)\n    items = list(range(20))\n    \n    # Create producer and consumers\n    producer_task = asyncio.create_task(async_producer(queue, items))\n    consumer_tasks = [\n        asyncio.create_task(async_consumer(queue, i))\n        for i in range(3)\n    ]\n    \n    # Wait for producer to finish\n    await producer_task\n    \n    # Signal consumers to stop\n    for _ in consumer_tasks:\n        await queue.put(None)\n    \n    # Wait for consumers\n    await asyncio.gather(*consumer_tasks)\n\n# Async Semaphore for Rate Limiting\nasync def rate_limited_request(semaphore: asyncio.Semaphore, url: str):\n    \"\"\"Make request with rate limiting.\"\"\"\n    async with semaphore:\n        print(f\"Requesting {url}\")\n        await asyncio.sleep(1)  # Simulate request\n        return f\"Response from {url}\"\n\nasync def rate_limited_requests():\n    \"\"\"Limit concurrent requests using semaphore.\"\"\"\n    semaphore = asyncio.Semaphore(3)  # Max 3 concurrent requests\n    urls = [f\"https://api.example.com/endpoint{i}\" for i in range(10)]\n    \n    tasks = [rate_limited_request(semaphore, url) for url in urls]\n    results = await asyncio.gather(*tasks)\n    return results\n\n# Async Context Managers\nclass AsyncDatabase:\n    \"\"\"Async context manager for database connection.\"\"\"\n    \n    async def __aenter__(self):\n        print(\"Connecting to database...\")\n        await asyncio.sleep(0.5)\n        self.connection = \"DatabaseConnection\"\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        print(\"Closing database connection...\")\n        await asyncio.sleep(0.5)\n        return False\n    \n    async def query(self, sql: str):\n        print(f\"Executing: {sql}\")\n        await asyncio.sleep(0.2)\n        return [\"result1\", \"result2\"]\n\nasync def use_async_db():\n    \"\"\"Use async context manager.\"\"\"\n    async with AsyncDatabase() as db:\n        results = await db.query(\"SELECT * FROM users\")\n        return results\n\n# Async Generators\nasync def async_number_generator(n: int):\n    \"\"\"Async generator that yields numbers.\"\"\"\n    for i in range(n):\n        await asyncio.sleep(0.1)\n        yield i\n\nasync def consume_async_generator():\n    \"\"\"Consume async generator.\"\"\"\n    async for num in async_number_generator(10):\n        print(f\"Received: {num}\")\n\n# Async Task Groups (Python 3.11+)\nasync def task_with_timeout():\n    \"\"\"Task that might timeout.\"\"\"\n    try:\n        async with asyncio.timeout(2):\n            await asyncio.sleep(5)\n            return \"Completed\"\n    except asyncio.TimeoutError:\n        return \"Timeout\"\n\n# Async vs Sync Performance Comparison\ndef sync_io_task(n: int):\n    \"\"\"Synchronous I/O task.\"\"\"\n    time.sleep(0.5)\n    return n * 2\n\nasync def async_io_task(n: int):\n    \"\"\"Asynchronous I/O task.\"\"\"\n    await asyncio.sleep(0.5)\n    return n * 2\n\ndef compare_performance():\n    \"\"\"Compare sync vs async performance.\"\"\"\n    # Synchronous - takes 5 seconds (10 * 0.5)\n    start = time.time()\n    results = [sync_io_task(i) for i in range(10)]\n    sync_time = time.time() - start\n    print(f\"Sync time: {sync_time:.2f}s\")\n    \n    # Asynchronous - takes ~0.5 seconds (concurrent)\n    start = time.time()\n    results = asyncio.run(asyncio.gather(*[async_io_task(i) for i in range(10)]))\n    async_time = time.time() - start\n    print(f\"Async time: {async_time:.2f}s\")\n    print(f\"Speedup: {sync_time/async_time:.2f}x\")\n\n# Run async code\n# asyncio.run(fetch_multiple_urls(['https://example.com'] * 5))\n# asyncio.run(async_producer_consumer())\n# asyncio.run(rate_limited_requests())\n```\n\n### Choosing the Right Concurrency Model\n\n```python\n\"\"\"\nPython Concurrency Decision Guide:\n\n1. THREADING - Use for I/O-bound tasks\n   ‚úì Network requests, file I/O, database queries\n   ‚úì Tasks that wait for external resources\n   ‚úì Need to share memory between tasks\n   ‚úó CPU-bound tasks (GIL limits performance)\n   Example: Downloading multiple files, web scraping\n\n2. MULTIPROCESSING - Use for CPU-bound tasks\n   ‚úì Heavy computations, data processing\n   ‚úì True parallelism needed\n   ‚úì Can utilize multiple CPU cores\n   ‚úó Higher memory overhead (separate processes)\n   ‚úó Slower inter-process communication\n   Example: Image processing, scientific computing\n\n3. ASYNCIO - Use for high-concurrency I/O\n   ‚úì Thousands of concurrent connections\n   ‚úì Event-driven applications\n   ‚úì Most efficient for I/O-bound tasks\n   ‚úì Single-threaded, lower overhead\n   ‚úó Requires async libraries (aiohttp, aiofiles)\n   ‚úó All code must be async-aware\n   Example: Web servers, API clients, chat servers\n\nPerformance Comparison:\n- Threading: Good for 10-100 concurrent I/O tasks\n- Asyncio: Excellent for 1000+ concurrent I/O tasks\n- Multiprocessing: Best for utilizing all CPU cores\n\"\"\"\n\n# Practical example combining all three\nimport asyncio\nimport multiprocessing as mp\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor\n\nclass HybridProcessor:\n    \"\"\"Combine threading, multiprocessing, and asyncio.\"\"\"\n    \n    def __init__(self):\n        self.thread_pool = ThreadPoolExecutor(max_workers=10)\n        self.process_pool = ProcessPoolExecutor(max_workers=4)\n    \n    async def process_urls_async(self, urls: List[str]):\n        \"\"\"Use asyncio for I/O-bound URL fetching.\"\"\"\n        async with aiohttp.ClientSession() as session:\n            tasks = [self.fetch_url(session, url) for url in urls]\n            return await asyncio.gather(*tasks)\n    \n    async def fetch_url(self, session, url):\n        async with session.get(url) as response:\n            return await response.text()\n    \n    def process_images_parallel(self, images: List[str]):\n        \"\"\"Use multiprocessing for CPU-bound image processing.\"\"\"\n        return self.process_pool.map(self.process_image, images)\n    \n    @staticmethod\n    def process_image(image_path: str):\n        \"\"\"CPU-intensive image processing.\"\"\"\n        # Simulate image processing\n        time.sleep(2)\n        return f\"Processed {image_path}\"\n    \n    def download_files_threaded(self, urls: List[str]):\n        \"\"\"Use threading for I/O-bound file downloads.\"\"\"\n        return list(self.thread_pool.map(self.download_file, urls))\n    \n    @staticmethod\n    def download_file(url: str):\n        \"\"\"Simulate file download.\"\"\"\n        time.sleep(1)\n        return f\"Downloaded {url}\"\n```\n\n---\n\n## 11. Data Science Fundamentals\n\n### NumPy Basics\n\n```python\nimport numpy as np\n\n# Array creation\narr = np.array([1, 2, 3, 4, 5])\nmatrix = np.array([[1, 2], [3, 4], [5, 6]])\n\n# Array operations\nsquared = arr ** 2\nnormalized = (arr - arr.mean()) / arr.std()\n\n# Mathematical functions\nprint(f\"Sum: {np.sum(arr)}\")\nprint(f\"Mean: {np.mean(arr)}\")\nprint(f\"Standard deviation: {np.std(arr)}\")\n\n# Array manipulation\nreshaped = arr.reshape(-1, 1)  # Column vector\nconcatenated = np.concatenate([arr, arr])\n\n# Linear algebra\ndot_product = np.dot(arr, arr)\nmatrix_det = np.linalg.det(matrix[:2, :])  # 2x2 matrix determinant\n```\n\n### Pandas Basics\n\n```python\nimport pandas as pd\n\n# DataFrame creation\ndata = {\n    'name': ['Alice', 'Bob', 'Charlie', 'Diana'],\n    'age': [25, 30, 35, 28],\n    'salary': [50000, 60000, 70000, 55000],\n    'department': ['Engineering', 'Marketing', 'Engineering', 'Sales']\n}\ndf = pd.DataFrame(data)\n\n# Data selection\nprint(df['name'])  # Single column\nprint(df[['name', 'age']])  # Multiple columns\nprint(df[df['age'] > 28])  # Filtering\n\n# Data manipulation\ndf['age_group'] = df['age'].apply(lambda x: 'Young' if x < 30 else 'Adult')\nsorted_df = df.sort_values('salary', ascending=False)\n\n# Grouping and aggregation\ndept_stats = df.groupby('department').agg({\n    'salary': ['mean', 'max'],\n    'age': 'mean'\n})\n\n# Data cleaning\ndf_with_nulls = df.copy()\ndf_with_nulls.loc[0, 'salary'] = np.nan\ncleaned_df = df_with_nulls.fillna(df_with_nulls.mean())\n```\n\n---\n\n## 12. Web Development Basics\n\n### Flask Framework\n\n```python\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return \"Welcome to Python Web Development!\"\n\n@app.route('/api/users', methods=['GET', 'POST'])\ndef handle_users():\n    if request.method == 'GET':\n        users = [\n            {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n            {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\"}\n        ]\n        return jsonify({\"users\": users})\n    \n    elif request.method == 'POST':\n        user_data = request.get_json()\n        new_user = {\n            \"id\": 3,\n            \"name\": user_data.get('name'),\n            \"email\": user_data.get('email')\n        }\n        return jsonify({\"message\": \"User created\", \"user\": new_user}), 201\n\n@app.route('/api/users/<int:user_id>')\ndef get_user(user_id):\n    user = {\"id\": user_id, \"name\": \"Sample User\", \"email\": \"user@example.com\"}\n    return jsonify(user)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n### Database Integration\n\n```python\nimport sqlite3\nfrom contextlib import contextmanager\n\nclass DatabaseManager:\n    def __init__(self, db_name):\n        self.db_name = db_name\n        self.init_db()\n    \n    @contextmanager\n    def get_connection(self):\n        conn = sqlite3.connect(self.db_name)\n        try:\n            yield conn\n        finally:\n            conn.close()\n    \n    def init_db(self):\n        with self.get_connection() as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT NOT NULL,\n                    email TEXT UNIQUE NOT NULL,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n            conn.commit()\n    \n    def create_user(self, name, email):\n        with self.get_connection() as conn:\n            cursor = conn.cursor()\n            cursor.execute(\n                \"INSERT INTO users (name, email) VALUES (?, ?)\",\n                (name, email)\n            )\n            conn.commit()\n            return cursor.lastrowid\n    \n    def get_all_users(self):\n        with self.get_connection() as conn:\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT * FROM users\")\n            return cursor.fetchall()\n```\n\n---\n\n## 13. Testing & Code Quality\n\n### Unit Testing with unittest\n\n```python\nimport unittest\nfrom unittest.mock import Mock, patch\n\nclass Calculator:\n    def add(self, a, b):\n        return a + b\n    \n    def divide(self, a, b):\n        if b == 0:\n            raise ValueError(\"Cannot divide by zero\")\n        return a / b\n    \n    def get_random_number(self):\n        import random\n        return random.randint(1, 100)\n\nclass TestCalculator(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up test fixtures before each test method.\"\"\"\n        self.calc = Calculator()\n    \n    def test_add_positive_numbers(self):\n        \"\"\"Test addition of positive numbers.\"\"\"\n        result = self.calc.add(2, 3)\n        self.assertEqual(result, 5)\n    \n    def test_divide_by_zero(self):\n        \"\"\"Test division by zero raises exception.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            self.calc.divide(10, 0)\n        self.assertEqual(str(context.exception), \"Cannot divide by zero\")\n    \n    @patch('random.randint')\n    def test_get_random_number_mocked(self, mock_randint):\n        \"\"\"Test with mocked random function.\"\"\"\n        mock_randint.return_value = 42\n        result = self.calc.get_random_number()\n        self.assertEqual(result, 42)\n        mock_randint.assert_called_once_with(1, 100)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n### Pytest Framework\n\n```python\nimport pytest\n\n# Fixtures\n@pytest.fixture\ndef sample_data():\n    \"\"\"Fixture providing sample data for tests.\"\"\"\n    return [1, 2, 3, 4, 5]\n\n@pytest.fixture\ndef calculator():\n    \"\"\"Fixture providing calculator instance.\"\"\"\n    return Calculator()\n\n# Test functions\ndef test_list_operations(sample_data):\n    \"\"\"Test basic list operations.\"\"\"\n    assert len(sample_data) == 5\n    assert sum(sample_data) == 15\n    assert max(sample_data) == 5\n\ndef test_calculator_add(calculator):\n    \"\"\"Test calculator addition.\"\"\"\n    assert calculator.add(2, 3) == 5\n    assert calculator.add(-1, 1) == 0\n\n# Parametrized tests\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (2, 3, 5),\n    (0, 0, 0),\n    (-1, 1, 0),\n    (10, -5, 5)\n])\ndef test_add_parametrized(calculator, a, b, expected):\n    \"\"\"Test addition with multiple parameter sets.\"\"\"\n    assert calculator.add(a, b) == expected\n\n# Test classes\nclass TestCalculatorAdvanced:\n    def test_multiple_operations(self, calculator):\n        \"\"\"Test multiple operations in sequence.\"\"\"\n        result1 = calculator.add(2, 3)\n        result2 = calculator.divide(result1, 5)\n        assert result2 == 1.0\n```\n\n---\n\n## 14. Advanced Python Features\n\n### Metaclasses\n\n```python\nclass SingletonMeta(type):\n    \"\"\"Metaclass that creates singleton instances.\"\"\"\n    _instances = {}\n    \n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass DatabaseConnection(metaclass=SingletonMeta):\n    def __init__(self):\n        self.connection_string = \"Database connected\"\n    \n    def query(self, sql):\n        return f\"Executing: {sql}\"\n\n# Usage\ndb1 = DatabaseConnection()\ndb2 = DatabaseConnection()\nprint(db1 is db2)  # True - same instance\n```\n\n### Descriptors\n\n```python\nclass Validated:\n    \"\"\"Descriptor for validated attributes.\"\"\"\n    \n    def __init__(self, validator, name=None):\n        self.validator = validator\n        self.name = name\n    \n    def __set_name__(self, owner, name):\n        self.name = name\n    \n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        return obj.__dict__.get(self.name)\n    \n    def __set__(self, obj, value):\n        if not self.validator(value):\n            raise ValueError(f\"Invalid value for {self.name}: {value}\")\n        obj.__dict__[self.name] = value\n\nclass Person:\n    name = Validated(lambda x: isinstance(x, str) and len(x) > 0)\n    age = Validated(lambda x: isinstance(x, int) and 0 <= x <= 150)\n    \n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n# Usage\nperson = Person(\"Alice\", 30)\n# person.age = -5  # Would raise ValueError\n```\n\n### Protocol and Type Hints\n\n```python\nfrom typing import Protocol, TypeVar, Generic\nfrom abc import ABC, abstractmethod\n\n# Protocol for structural typing\nclass Drawable(Protocol):\n    def draw(self) -> str:\n        ...\n\nclass Circle:\n    def draw(self) -> str:\n        return \"Drawing a circle\"\n\nclass Square:\n    def draw(self) -> str:\n        return \"Drawing a square\"\n\ndef render_shape(shape: Drawable) -> str:\n    return shape.draw()\n\n# Generic types\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    def __init__(self):\n        self._items: list[T] = []\n    \n    def push(self, item: T) -> None:\n        self._items.append(item)\n    \n    def pop(self) -> T:\n        if not self._items:\n            raise IndexError(\"Stack is empty\")\n        return self._items.pop()\n```\n\n---\n\n## 15. Best Practices\n\n### Code Organization\n\n```python\n# Use meaningful variable names\nuser_age = 25  # Good\na = 25         # Bad\n\n# Follow PEP 8 naming conventions\nclass UserManager:     # CapitalizedWords for classes\n    def get_user(self):  # lowercase_with_underscores for functions\n        pass\n\nUSER_CONSTANT = \"value\"  # UPPER_CASE for constants\n\n# Use type hints\ndef calculate_area(radius: float) -> float:\n    return 3.14159 * radius ** 2\n\n# Docstrings for documentation\ndef fibonacci(n: int) -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n    \n    Args:\n        n: The position in the Fibonacci sequence\n        \n    Returns:\n        The nth Fibonacci number\n        \n    Raises:\n        ValueError: If n is negative\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n```\n\n### Error Handling\n\n```python\n# Specific exception handling\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\nexcept ValueError as e:\n    print(f\"Invalid value: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\nelse:\n    print(\"No exceptions occurred\")\nfinally:\n    print(\"This always executes\")\n\n# Custom exceptions\nclass ValidationError(Exception):\n    def __init__(self, message, field=None):\n        super().__init__(message)\n        self.field = field\n\ndef validate_age(age):\n    if not isinstance(age, int):\n        raise ValidationError(\"Age must be an integer\", \"age\")\n    if age < 0:\n        raise ValidationError(\"Age cannot be negative\", \"age\")\n```\n\n### Performance Tips\n\n```python\n# Use list comprehensions instead of loops\n# Good\nsquares = [x**2 for x in range(1000)]\n\n# Less efficient\nsquares = []\nfor x in range(1000):\n    squares.append(x**2)\n\n# Use join for string concatenation\n# Good\nwords = [\"Hello\", \"World\", \"Python\"]\nsentence = \" \".join(words)\n\n# Less efficient\nsentence = \"\"\nfor word in words:\n    sentence += word + \" \"\n\n# Use enumerate instead of range(len())\n# Good\nfor i, item in enumerate(items):\n    print(f\"{i}: {item}\")\n\n# Less pythonic\nfor i in range(len(items)):\n    print(f\"{i}: {items[i]}\")\n```\n\n---\n\n## 16. Asynchronous Programming\n\n### Async/Await Basics\n\nAsynchronous programming allows concurrent execution of I/O-bound tasks without blocking, making applications more efficient. Python's `asyncio` module uses `async`/`await` keywords to write non-blocking code. This is essential for web servers, API clients, database operations, and any scenario where waiting for I/O shouldn't freeze your program.\n\n```python\nimport asyncio\n\n# Basic async function\nasync def fetch_data(id):\n    \"\"\"Simulate fetching data asynchronously.\"\"\"\n    print(f\"Fetching data {id}...\")\n    await asyncio.sleep(1)  # Simulates I/O operation\n    return f\"Data {id}\"\n\nasync def main():\n    \"\"\"Run multiple async tasks concurrently.\"\"\"\n    # Sequential execution (slower)\n    result1 = await fetch_data(1)\n    result2 = await fetch_data(2)\n    print(f\"Sequential: {result1}, {result2}\")\n    \n    # Concurrent execution (faster)\n    results = await asyncio.gather(\n        fetch_data(3),\n        fetch_data(4),\n        fetch_data(5)\n    )\n    print(f\"Concurrent: {results}\")\n\n# Run the async program\nasyncio.run(main())\n```\n\n### Async Context Managers and Generators\n\n```python\nimport asyncio\nimport aiohttp\n\n# Async context manager\nclass AsyncDatabaseConnection:\n    async def __aenter__(self):\n        print(\"Opening database connection...\")\n        await asyncio.sleep(0.1)\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        print(\"Closing database connection...\")\n        await asyncio.sleep(0.1)\n    \n    async def query(self, sql):\n        await asyncio.sleep(0.1)\n        return f\"Results for: {sql}\"\n\n# Async generator\nasync def async_range(start, stop):\n    \"\"\"Async generator example.\"\"\"\n    for i in range(start, stop):\n        await asyncio.sleep(0.1)\n        yield i\n\nasync def demo():\n    # Using async context manager\n    async with AsyncDatabaseConnection() as db:\n        result = await db.query(\"SELECT * FROM users\")\n        print(result)\n    \n    # Using async generator\n    async for i in async_range(1, 5):\n        print(f\"Generated: {i}\")\n\nasyncio.run(demo())\n```\n\n### Async HTTP Requests\n\n```python\nimport asyncio\nimport aiohttp\n\nasync def fetch_url(session, url):\n    \"\"\"Fetch a single URL.\"\"\"\n    async with session.get(url) as response:\n        return await response.text()\n\nasync def fetch_multiple_urls(urls):\n    \"\"\"Fetch multiple URLs concurrently.\"\"\"\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n        return results\n\n# Usage\nurls = [\n    'https://api.github.com/users/github',\n    'https://api.github.com/users/python',\n]\n# results = asyncio.run(fetch_multiple_urls(urls))\n```\n\n---\n\n## 17. REST APIs & FastAPI\n\n### FastAPI Basics\n\nFastAPI is a modern, fast web framework for building APIs with Python. It provides automatic API documentation, type validation, and excellent performance. FastAPI uses Python type hints for automatic request/response validation and is built on Starlette and Pydantic, making it perfect for production-ready APIs.\n\n```python\nfrom fastapi import FastAPI, HTTPException, Query, Path\nfrom pydantic import BaseModel, Field\nfrom typing import Optional, List\n\napp = FastAPI(title=\"My API\", version=\"1.0.0\")\n\n# Pydantic models for request/response validation\nclass User(BaseModel):\n    id: int\n    name: str = Field(..., min_length=1, max_length=50)\n    email: str\n    age: Optional[int] = Field(None, ge=0, le=150)\n    is_active: bool = True\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n    age: Optional[int] = None\n\n# In-memory database (use real DB in production)\nusers_db: List[User] = [\n    User(id=1, name=\"Alice\", email=\"alice@example.com\", age=30),\n    User(id=2, name=\"Bob\", email=\"bob@example.com\", age=25),\n]\n\n# GET endpoint - List all users\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint.\"\"\"\n    return {\"message\": \"Welcome to My API\"}\n\n@app.get(\"/users\", response_model=List[User])\nasync def get_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100)\n):\n    \"\"\"Get list of users with pagination.\"\"\"\n    return users_db[skip : skip + limit]\n\n# GET endpoint with path parameter\n@app.get(\"/users/{user_id}\", response_model=User)\nasync def get_user(user_id: int = Path(..., gt=0)):\n    \"\"\"Get a specific user by ID.\"\"\"\n    user = next((u for u in users_db if u.id == user_id), None)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n\n# POST endpoint - Create user\n@app.post(\"/users\", response_model=User, status_code=201)\nasync def create_user(user: UserCreate):\n    \"\"\"Create a new user.\"\"\"\n    new_id = max([u.id for u in users_db], default=0) + 1\n    new_user = User(id=new_id, **user.dict())\n    users_db.append(new_user)\n    return new_user\n\n# PUT endpoint - Update user\n@app.put(\"/users/{user_id}\", response_model=User)\nasync def update_user(user_id: int, user_update: UserCreate):\n    \"\"\"Update an existing user.\"\"\"\n    user_idx = next((i for i, u in enumerate(users_db) if u.id == user_id), None)\n    if user_idx is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    \n    updated_user = User(id=user_id, **user_update.dict())\n    users_db[user_idx] = updated_user\n    return updated_user\n\n# DELETE endpoint\n@app.delete(\"/users/{user_id}\")\nasync def delete_user(user_id: int):\n    \"\"\"Delete a user.\"\"\"\n    user_idx = next((i for i, u in enumerate(users_db) if u.id == user_id), None)\n    if user_idx is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    \n    deleted_user = users_db.pop(user_idx)\n    return {\"message\": f\"User {deleted_user.name} deleted successfully\"}\n\n# Run with: uvicorn main:app --reload\n```\n\n### FastAPI Advanced Features\n\n```python\nfrom fastapi import FastAPI, Depends, Header, Cookie\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom typing import Annotated\nimport jwt\n\napp = FastAPI()\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Dependency injection\nasync def get_current_user(token: str = Header(None)):\n    \"\"\"Dependency to get current user from token.\"\"\"\n    if not token:\n        raise HTTPException(status_code=401, detail=\"Not authenticated\")\n    # Decode token and get user (simplified)\n    return {\"user_id\": 1, \"username\": \"alice\"}\n\n# Using dependencies\n@app.get(\"/me\")\nasync def read_users_me(current_user: dict = Depends(get_current_user)):\n    \"\"\"Get current user info.\"\"\"\n    return current_user\n\n# Background tasks\nfrom fastapi import BackgroundTasks\n\ndef send_email(email: str, message: str):\n    \"\"\"Simulate sending email.\"\"\"\n    print(f\"Sending email to {email}: {message}\")\n\n@app.post(\"/send-notification\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    \"\"\"Send notification in background.\"\"\"\n    background_tasks.add_task(send_email, email, \"Hello!\")\n    return {\"message\": \"Notification sent\"}\n\n# File upload\nfrom fastapi import File, UploadFile\n\n@app.post(\"/upload\")\nasync def upload_file(file: UploadFile = File(...)):\n    \"\"\"Upload a file.\"\"\"\n    contents = await file.read()\n    return {\n        \"filename\": file.filename,\n        \"content_type\": file.content_type,\n        \"size\": len(contents)\n    }\n```\n\n### REST API Best Practices\n\n```python\nfrom enum import Enum\nfrom fastapi import status\n\n# Use enums for fixed choices\nclass UserRole(str, Enum):\n    ADMIN = \"admin\"\n    USER = \"user\"\n    GUEST = \"guest\"\n\n# Proper status codes\n@app.post(\"/users\", status_code=status.HTTP_201_CREATED)\nasync def create_user_properly(user: UserCreate):\n    \"\"\"Create user with proper status code.\"\"\"\n    # ... create user logic\n    pass\n\n# Error responses with detail\nclass ErrorResponse(BaseModel):\n    detail: str\n    error_code: str\n    timestamp: str\n\n@app.get(\"/users/{user_id}\", responses={\n    404: {\"model\": ErrorResponse},\n    200: {\"model\": User}\n})\nasync def get_user_with_error_handling(user_id: int):\n    \"\"\"Get user with proper error handling.\"\"\"\n    user = next((u for u in users_db if u.id == user_id), None)\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail={\n                \"detail\": \"User not found\",\n                \"error_code\": \"USER_NOT_FOUND\",\n                \"timestamp\": \"2025-12-11T10:00:00Z\"\n            }\n        )\n    return user\n```\n\n---\n\n## 18. Database Operations\n\n### SQLAlchemy ORM\n\nSQLAlchemy is Python's most popular ORM (Object-Relational Mapping) library, allowing you to interact with databases using Python classes instead of raw SQL. It provides database abstraction, automatic migrations, relationship handling, and query building, making database operations more Pythonic and maintainable.\n\n```python\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, relationship\n\n# Database setup\nBase = declarative_base()\nengine = create_engine('sqlite:///example.db')\nSession = sessionmaker(bind=engine)\n\n# Define models\nclass User(Base):\n    __tablename__ = 'users'\n    \n    id = Column(Integer, primary_key=True)\n    username = Column(String(50), unique=True, nullable=False)\n    email = Column(String(100), unique=True, nullable=False)\n    posts = relationship(\"Post\", back_populates=\"author\")\n\nclass Post(Base):\n    __tablename__ = 'posts'\n    \n    id = Column(Integer, primary_key=True)\n    title = Column(String(200), nullable=False)\n    content = Column(String)\n    author_id = Column(Integer, ForeignKey('users.id'))\n    author = relationship(\"User\", back_populates=\"posts\")\n\n# Create tables\nBase.metadata.create_all(engine)\n\n# CRUD operations\nsession = Session()\n\n# Create\nnew_user = User(username='alice', email='alice@example.com')\nsession.add(new_user)\nsession.commit()\n\n# Read\nuser = session.query(User).filter_by(username='alice').first()\nall_users = session.query(User).all()\n\n# Update\nuser.email = 'newemail@example.com'\nsession.commit()\n\n# Delete\nsession.delete(user)\nsession.commit()\n\nsession.close()\n```\n\n### Async Database with FastAPI\n\n```python\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker\nfrom fastapi import Depends\n\n# Async engine\nengine = create_async_engine('sqlite+aiosqlite:///async_example.db')\nAsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Dependency\nasync def get_db():\n    async with AsyncSessionLocal() as session:\n        yield session\n\n# Using in FastAPI\n@app.get(\"/users\")\nasync def get_users_async(db: AsyncSession = Depends(get_db)):\n    \"\"\"Get users asynchronously.\"\"\"\n    result = await db.execute(select(User))\n    users = result.scalars().all()\n    return users\n```\n\n---\n\n## 19. Testing\n\n### Pytest Basics\n\nTesting ensures code reliability and catches bugs early. Pytest is Python's most popular testing framework, offering simple syntax, powerful fixtures, and excellent plugin ecosystem. Writing tests is crucial for maintaining code quality, enabling refactoring, and building confidence in deployments.\n\n```python\n# test_calculator.py\nimport pytest\n\n# Simple test\ndef add(a, b):\n    return a + b\n\ndef test_add():\n    \"\"\"Test addition function.\"\"\"\n    assert add(2, 3) == 5\n    assert add(-1, 1) == 0\n    assert add(0, 0) == 0\n\n# Parametrized tests\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (2, 3, 5),\n    (0, 0, 0),\n    (-1, 1, 0),\n    (100, 200, 300),\n])\ndef test_add_parametrized(a, b, expected):\n    \"\"\"Test add with multiple inputs.\"\"\"\n    assert add(a, b) == expected\n\n# Fixtures for setup/teardown\n@pytest.fixture\ndef sample_data():\n    \"\"\"Provide sample data for tests.\"\"\"\n    return [1, 2, 3, 4, 5]\n\ndef test_with_fixture(sample_data):\n    \"\"\"Test using fixture.\"\"\"\n    assert len(sample_data) == 5\n    assert sum(sample_data) == 15\n\n# Testing exceptions\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n\ndef test_divide_by_zero():\n    \"\"\"Test that division by zero raises error.\"\"\"\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        divide(10, 0)\n\n# Run with: pytest test_calculator.py\n```\n\n### Testing FastAPI\n\n```python\nfrom fastapi.testclient import TestClient\n\n# test_api.py\ndef test_read_main():\n    \"\"\"Test root endpoint.\"\"\"\n    client = TestClient(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Welcome to My API\"}\n\ndef test_create_user():\n    \"\"\"Test user creation.\"\"\"\n    client = TestClient(app)\n    response = client.post(\n        \"/users\",\n        json={\"name\": \"Test User\", \"email\": \"test@example.com\", \"age\": 25}\n    )\n    assert response.status_code == 201\n    assert response.json()[\"name\"] == \"Test User\"\n\ndef test_get_nonexistent_user():\n    \"\"\"Test getting user that doesn't exist.\"\"\"\n    client = TestClient(app)\n    response = client.get(\"/users/99999\")\n    assert response.status_code == 404\n```\n\n---\n\n## 20. Type Hints & Static Type Checking\n\n### Type Hints\n\nType hints improve code readability, enable better IDE support, and catch bugs early. They don't affect runtime but help with documentation and static analysis tools like mypy. Type hints are increasingly important in modern Python development and are commonly used in professional codebases.\n\n```python\nfrom typing import List, Dict, Optional, Union, Callable, Tuple, Any\n\n# Basic type hints\ndef greet(name: str) -> str:\n    \"\"\"Function with type hints.\"\"\"\n    return f\"Hello, {name}\"\n\n# Collection types\ndef process_items(items: List[int]) -> int:\n    \"\"\"Process list of integers.\"\"\"\n    return sum(items)\n\ndef get_user(user_id: int) -> Dict[str, Any]:\n    \"\"\"Return user dictionary.\"\"\"\n    return {\"id\": user_id, \"name\": \"Alice\"}\n\n# Optional types\ndef find_user(user_id: int) -> Optional[Dict]:\n    \"\"\"Return user or None if not found.\"\"\"\n    return None if user_id > 100 else {\"id\": user_id}\n\n# Union types\ndef process_id(id: Union[int, str]) -> str:\n    \"\"\"Accept int or string ID.\"\"\"\n    return str(id)\n\n# Callable types\ndef apply_operation(x: int, operation: Callable[[int], int]) -> int:\n    \"\"\"Apply operation to number.\"\"\"\n    return operation(x)\n\n# Generic types\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Stack(Generic[T]):\n    \"\"\"Generic stack implementation.\"\"\"\n    def __init__(self) -> None:\n        self.items: List[T] = []\n    \n    def push(self, item: T) -> None:\n        self.items.append(item)\n    \n    def pop(self) -> T:\n        return self.items.pop()\n\n# Using generic\nint_stack: Stack[int] = Stack()\nint_stack.push(1)\n```\n\n---\n\n## 21. Python Interview Topics\n\n### Common Interview Questions\n\nUnderstanding these concepts is crucial for technical interviews. They test your knowledge of Python's internals, best practices, and problem-solving abilities. These topics frequently appear in interviews for Python developer positions at all levels.\n\n```python\n# 1. What is the difference between list and tuple?\n# Lists are mutable, tuples are immutable\n# Tuples are faster and use less memory\n\n# 2. Explain *args and **kwargs\ndef flexible_function(*args, **kwargs):\n    print(f\"Args: {args}\")       # Positional arguments as tuple\n    print(f\"Kwargs: {kwargs}\")   # Keyword arguments as dict\n\n# 3. What is a decorator?\ndef timer_decorator(func):\n    def wrapper(*args, **kwargs):\n        import time\n        start = time.time()\n        result = func(*args, **kwargs)\n        print(f\"Time: {time.time() - start}\")\n        return result\n    return wrapper\n\n# 4. Explain list comprehension vs generator expression\nlist_comp = [x**2 for x in range(1000)]     # Creates list in memory\ngen_exp = (x**2 for x in range(1000))       # Generates on-demand\n\n# 5. What is the GIL (Global Interpreter Lock)?\n# The GIL prevents multiple threads from executing Python bytecode\n# Use multiprocessing for CPU-bound tasks, threading for I/O-bound\n\n# 6. Shallow vs Deep copy\nimport copy\noriginal = [[1, 2], [3, 4]]\nshallow = copy.copy(original)      # Copies outer list only\ndeep = copy.deepcopy(original)     # Copies everything recursively\n\n# 7. What are Python's magic methods?\nclass Point:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    \n    def __str__(self):\n        return f\"Point({self.x}, {self.y})\"\n    \n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n# 8. Explain generators and yield\ndef infinite_sequence():\n    num = 0\n    while True:\n        yield num  # Returns value and pauses execution\n        num += 1\n\n# 9. What is monkey patching?\n# Modifying/extending classes at runtime\nimport datetime\ndatetime.datetime.now = lambda: \"Patched!\"\n\n# 10. Context managers\nclass FileManager:\n    def __enter__(self):\n        # Setup code\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # Cleanup code\n        pass\n```\n\n---\n\n## 22. Exception Handling & Error Management\n\n### Understanding Exceptions\n\nException handling is critical for writing robust, production-ready code. Proper error handling prevents crashes, provides meaningful feedback, and enables graceful degradation. Understanding Python's exception hierarchy and handling mechanisms is essential for any professional developer and frequently tested in interviews.\n\n```python\n# Basic exception handling\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    print(\"This always executes\")\n\n# Multiple exceptions\ntry:\n    data = {\"name\": \"Alice\"}\n    age = data[\"age\"]  # KeyError\nexcept (KeyError, ValueError) as e:\n    print(f\"Error: {e}\")\n\n# Exception with else clause\ntry:\n    number = int(input(\"Enter a number: \"))\nexcept ValueError:\n    print(\"Invalid input!\")\nelse:\n    print(f\"You entered: {number}\")  # Runs if no exception\nfinally:\n    print(\"Cleanup code\")\n```\n\n### Custom Exceptions\n\n```python\n# Creating custom exceptions\nclass ValidationError(Exception):\n    \"\"\"Raised when validation fails.\"\"\"\n    def __init__(self, message, field_name=None):\n        self.message = message\n        self.field_name = field_name\n        super().__init__(self.message)\n\nclass DatabaseError(Exception):\n    \"\"\"Custom database error.\"\"\"\n    pass\n\nclass APIError(Exception):\n    \"\"\"API-specific errors.\"\"\"\n    def __init__(self, status_code, message):\n        self.status_code = status_code\n        self.message = message\n        super().__init__(f\"API Error {status_code}: {message}\")\n\n# Using custom exceptions\ndef validate_age(age):\n    if not isinstance(age, int):\n        raise ValidationError(\"Age must be an integer\", \"age\")\n    if age < 0 or age > 150:\n        raise ValidationError(\"Age must be between 0 and 150\", \"age\")\n    return True\n\ndef fetch_user_data(user_id):\n    if user_id < 0:\n        raise APIError(400, \"Invalid user ID\")\n    # Fetch data logic\n    return {\"id\": user_id, \"name\": \"User\"}\n\n# Handling custom exceptions\ntry:\n    validate_age(\"twenty\")\nexcept ValidationError as e:\n    print(f\"Validation failed for {e.field_name}: {e.message}\")\n\ntry:\n    user = fetch_user_data(-1)\nexcept APIError as e:\n    print(f\"Status: {e.status_code}, Message: {e.message}\")\n```\n\n### Exception Chaining and Context\n\n```python\n# Exception chaining (Python 3+)\nclass DataProcessingError(Exception):\n    pass\n\ndef process_data(data):\n    try:\n        result = int(data)\n    except ValueError as e:\n        raise DataProcessingError(\"Failed to process data\") from e\n\ntry:\n    process_data(\"invalid\")\nexcept DataProcessingError as e:\n    print(f\"Error: {e}\")\n    print(f\"Original cause: {e.__cause__}\")\n\n# Suppressing exception context\ntry:\n    # Some operation\n    raise ValueError(\"Original error\")\nexcept ValueError:\n    raise RuntimeError(\"New error\") from None  # Suppress original\n```\n\n### Best Practices for Exception Handling\n\n```python\n# ‚úÖ GOOD: Specific exceptions\ntry:\n    file = open(\"data.txt\")\n    data = file.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\nexcept PermissionError:\n    print(\"Permission denied\")\nfinally:\n    if 'file' in locals():\n        file.close()\n\n# ‚ùå BAD: Bare except\ntry:\n    risky_operation()\nexcept:  # Don't do this!\n    pass\n\n# ‚úÖ GOOD: Context manager (automatic cleanup)\ntry:\n    with open(\"data.txt\") as f:\n        data = f.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\n\n# ‚úÖ GOOD: Logging exceptions\nimport logging\n\nlogging.basicConfig(level=logging.ERROR)\n\ntry:\n    result = complex_operation()\nexcept Exception as e:\n    logging.error(f\"Operation failed: {e}\", exc_info=True)\n    raise  # Re-raise after logging\n```\n\n---\n\n## 23. Regular Expressions (Regex)\n\n### Regex Basics\n\nRegular expressions are powerful patterns for matching and manipulating text. They're essential for data validation, text parsing, web scraping, and log analysis. Mastering regex is crucial for interviews and real-world text processing tasks.\n\n```python\nimport re\n\n# Basic pattern matching\ntext = \"My email is john@example.com and phone is 123-456-7890\"\n\n# Search for pattern\nemail_match = re.search(r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b', text)\nif email_match:\n    print(f\"Found email: {email_match.group()}\")\n\n# Find all matches\nemails = re.findall(r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b', \n                    \"Contact: john@example.com or jane@test.org\")\nprint(f\"All emails: {emails}\")\n\n# Match phone numbers\nphone_pattern = r'\\d{3}-\\d{3}-\\d{4}'\nphone = re.search(phone_pattern, text)\nprint(f\"Phone: {phone.group()}\")\n```\n\n### Common Regex Patterns\n\n```python\nimport re\n\n# Email validation\ndef is_valid_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n\n# Phone number validation (US format)\ndef is_valid_phone(phone):\n    pattern = r'^\\(?(\\d{3})\\)?[-.\\s]?(\\d{3})[-.\\s]?(\\d{4})$'\n    return bool(re.match(pattern, phone))\n\n# URL validation\ndef is_valid_url(url):\n    pattern = r'^https?://(?:www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b'\n    return bool(re.match(pattern, url))\n\n# Password strength (min 8 chars, 1 upper, 1 lower, 1 digit)\ndef is_strong_password(password):\n    pattern = r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d@$!%*?&]{8,}$'\n    return bool(re.match(pattern, password))\n\n# Test validations\nprint(is_valid_email(\"user@example.com\"))      # True\nprint(is_valid_phone(\"123-456-7890\"))          # True\nprint(is_valid_url(\"https://www.google.com\"))  # True\nprint(is_strong_password(\"SecurePass123\"))     # True\n```\n\n### Advanced Regex Operations\n\n```python\nimport re\n\n# Substitution\ntext = \"The price is $100 and discount is $20\"\nnew_text = re.sub(r'\\$(\\d+)', r'USD \\1', text)\nprint(new_text)  # \"The price is USD 100 and discount is USD 20\"\n\n# Split by pattern\ndata = \"apple,banana;orange:grape\"\nfruits = re.split(r'[,;:]', data)\nprint(fruits)  # ['apple', 'banana', 'orange', 'grape']\n\n# Named groups\nlog_line = \"2025-12-11 10:30:45 ERROR: Database connection failed\"\npattern = r'(?P<date>\\d{4}-\\d{2}-\\d{2}) (?P<time>\\d{2}:\\d{2}:\\d{2}) (?P<level>\\w+): (?P<message>.+)'\nmatch = re.match(pattern, log_line)\nif match:\n    print(match.groupdict())\n    # {'date': '2025-12-11', 'time': '10:30:45', 'level': 'ERROR', 'message': 'Database connection failed'}\n\n# Compile patterns for reuse (more efficient)\nemail_pattern = re.compile(r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b')\ntext1 = \"Contact: john@example.com\"\ntext2 = \"Email: jane@test.org\"\nprint(email_pattern.findall(text1))\nprint(email_pattern.findall(text2))\n```\n\n### Practical Regex Examples\n\n```python\nimport re\n\n# Extract hashtags from social media text\ndef extract_hashtags(text):\n    return re.findall(r'#\\w+', text)\n\n# Extract mentions\ndef extract_mentions(text):\n    return re.findall(r'@\\w+', text)\n\n# Clean HTML tags\ndef remove_html_tags(html):\n    return re.sub(r'<[^>]+>', '', html)\n\n# Extract numbers from text\ndef extract_numbers(text):\n    return [float(n) for n in re.findall(r'-?\\d+\\.?\\d*', text)]\n\n# Validate credit card (basic)\ndef is_valid_credit_card(card):\n    # Remove spaces and dashes\n    card = re.sub(r'[\\s-]', '', card)\n    return bool(re.match(r'^\\d{13,19}$', card))\n\n# Usage\ntweet = \"Check out #Python and #FastAPI! Thanks @john_doe\"\nprint(extract_hashtags(tweet))   # ['#Python', '#FastAPI']\nprint(extract_mentions(tweet))   # ['@john_doe']\n\nhtml = \"<p>Hello <b>World</b>!</p>\"\nprint(remove_html_tags(html))    # \"Hello World!\"\n\ntext = \"The price is $19.99 and quantity is 5\"\nprint(extract_numbers(text))     # [19.99, 5.0]\n```\n\n---\n\n## 24. Virtual Environments & Package Management\n\n### Virtual Environments\n\nVirtual environments isolate project dependencies, preventing version conflicts between projects. Understanding virtual environments is fundamental for Python development and is one of the first questions in technical interviews about Python project setup.\n\n```python\n# Create virtual environment\n# Command line:\n# python -m venv myenv              # Create venv\n# source myenv/bin/activate         # Activate (Mac/Linux)\n# myenv\\Scripts\\activate           # Activate (Windows)\n# deactivate                        # Deactivate\n\n# Check active environment\nimport sys\nprint(f\"Python executable: {sys.executable}\")\nprint(f\"Python version: {sys.version}\")\n```\n\n### Package Management with pip\n\n```bash\n# Install packages\npip install requests\npip install fastapi uvicorn\npip install pandas numpy matplotlib\n\n# Install specific version\npip install django==4.2.0\n\n# Install from requirements.txt\npip install -r requirements.txt\n\n# Upgrade package\npip upgrade requests\n\n# Uninstall package\npip uninstall requests\n\n# List installed packages\npip list\n\n# Show package info\npip show requests\n\n# Generate requirements.txt\npip freeze > requirements.txt\n\n# Install in development mode\npip install -e .\n```\n\n### Requirements.txt Best Practices\n\n```python\n# requirements.txt\n# Production dependencies with pinned versions\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\npydantic==2.5.0\nsqlalchemy==2.0.23\npython-jose[cryptography]==3.3.0\npasslib[bcrypt]==1.7.4\npython-multipart==0.0.6\n\n# requirements-dev.txt\n# Development dependencies\n-r requirements.txt  # Include production requirements\npytest==7.4.3\npytest-cov==4.1.0\nblack==23.11.0\nflake8==6.1.0\nmypy==1.7.1\n```\n\n### Poetry - Modern Dependency Management\n\n```python\n# pyproject.toml (Poetry configuration)\n# [tool.poetry]\n# name = \"my-project\"\n# version = \"0.1.0\"\n# description = \"My awesome project\"\n# authors = [\"Your Name <you@example.com>\"]\n# \n# [tool.poetry.dependencies]\n# python = \"^3.9\"\n# fastapi = \"^0.104.0\"\n# uvicorn = \"^0.24.0\"\n# \n# [tool.poetry.dev-dependencies]\n# pytest = \"^7.4.0\"\n# black = \"^23.11.0\"\n\n# Poetry commands:\n# poetry init                 # Initialize new project\n# poetry add fastapi         # Add dependency\n# poetry add --dev pytest    # Add dev dependency\n# poetry install             # Install all dependencies\n# poetry update              # Update dependencies\n# poetry run python main.py  # Run with poetry environment\n```\n\n### Environment Variables with python-dotenv\n\n```python\n# .env file (never commit to git!)\n# DATABASE_URL=postgresql://user:pass@localhost/dbname\n# SECRET_KEY=your-secret-key-here\n# API_KEY=your-api-key\n# DEBUG=True\n# PORT=8000\n\n# Loading environment variables\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()  # Load from .env file\n\n# Access environment variables\nDATABASE_URL = os.getenv(\"DATABASE_URL\")\nSECRET_KEY = os.getenv(\"SECRET_KEY\", \"default-secret\")\nDEBUG = os.getenv(\"DEBUG\", \"False\").lower() == \"true\"\nPORT = int(os.getenv(\"PORT\", 8000))\n\nprint(f\"Database: {DATABASE_URL}\")\nprint(f\"Debug mode: {DEBUG}\")\n\n# Using with Pydantic for validation\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    database_url: str\n    secret_key: str\n    debug: bool = False\n    port: int = 8000\n    \n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()\nprint(settings.database_url)\n```\n\n---\n\n## 25. Logging & Monitoring\n\n### Python Logging Module\n\nLogging is essential for debugging, monitoring, and maintaining production applications. Proper logging practices help track application behavior, diagnose issues, and understand system performance. This is a must-know topic for professional development.\n\n```python\nimport logging\nfrom datetime import datetime\n\n# Basic logging configuration\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    datefmt='%Y-%m-%d %H:%M:%S'\n)\n\nlogger = logging.getLogger(__name__)\n\n# Log levels (from least to most severe)\nlogger.debug(\"Detailed debugging information\")\nlogger.info(\"General informational messages\")\nlogger.warning(\"Warning messages\")\nlogger.error(\"Error messages\")\nlogger.critical(\"Critical errors\")\n\n# Example usage\ndef divide(a, b):\n    logger.info(f\"Dividing {a} by {b}\")\n    try:\n        result = a / b\n        logger.debug(f\"Result: {result}\")\n        return result\n    except ZeroDivisionError:\n        logger.error(\"Division by zero attempted\", exc_info=True)\n        raise\n```\n\n### Advanced Logging Configuration\n\n```python\nimport logging\nfrom logging.handlers import RotatingFileHandler, TimedRotatingFileHandler\nimport sys\n\n# Create logger\nlogger = logging.getLogger('my_app')\nlogger.setLevel(logging.DEBUG)\n\n# Create formatters\ndetailed_formatter = logging.Formatter(\n    '%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s'\n)\nsimple_formatter = logging.Formatter('%(levelname)s - %(message)s')\n\n# Console handler\nconsole_handler = logging.StreamHandler(sys.stdout)\nconsole_handler.setLevel(logging.INFO)\nconsole_handler.setFormatter(simple_formatter)\n\n# File handler with rotation\nfile_handler = RotatingFileHandler(\n    'app.log',\n    maxBytes=10*1024*1024,  # 10MB\n    backupCount=5\n)\nfile_handler.setLevel(logging.DEBUG)\nfile_handler.setFormatter(detailed_formatter)\n\n# Time-based rotation\ntimed_handler = TimedRotatingFileHandler(\n    'daily.log',\n    when='midnight',\n    interval=1,\n    backupCount=7\n)\ntimed_handler.setFormatter(detailed_formatter)\n\n# Add handlers to logger\nlogger.addHandler(console_handler)\nlogger.addHandler(file_handler)\nlogger.addHandler(timed_handler)\n\n# Usage\nlogger.info(\"Application started\")\nlogger.debug(\"Debug information\")\nlogger.error(\"An error occurred\")\n```\n\n### Logging in FastAPI\n\n```python\nimport logging\nfrom fastapi import FastAPI, Request\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI()\n\n# Logging middleware\n@app.middleware(\"http\")\nasync def log_requests(request: Request, call_next):\n    start_time = time.time()\n    \n    logger.info(f\"Request: {request.method} {request.url}\")\n    \n    response = await call_next(request)\n    \n    process_time = time.time() - start_time\n    logger.info(\n        f\"Response: {response.status_code} - \"\n        f\"Completed in {process_time:.4f}s\"\n    )\n    \n    return response\n\n@app.get(\"/\")\nasync def root():\n    logger.info(\"Root endpoint called\")\n    return {\"message\": \"Hello World\"}\n\n@app.post(\"/users\")\nasync def create_user(user_data: dict):\n    logger.info(f\"Creating user: {user_data.get('name')}\")\n    try:\n        # Create user logic\n        logger.debug(f\"User data: {user_data}\")\n        return {\"status\": \"success\"}\n    except Exception as e:\n        logger.error(f\"Failed to create user: {e}\", exc_info=True)\n        raise\n```\n\n### Structured Logging (JSON)\n\n```python\nimport logging\nimport json\nfrom datetime import datetime\n\nclass JSONFormatter(logging.Formatter):\n    \"\"\"Custom JSON formatter for structured logging.\"\"\"\n    \n    def format(self, record):\n        log_data = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"level\": record.levelname,\n            \"logger\": record.name,\n            \"message\": record.getMessage(),\n            \"module\": record.module,\n            \"function\": record.funcName,\n            \"line\": record.lineno\n        }\n        \n        if record.exc_info:\n            log_data[\"exception\"] = self.formatException(record.exc_info)\n        \n        # Add custom fields\n        if hasattr(record, 'user_id'):\n            log_data[\"user_id\"] = record.user_id\n        if hasattr(record, 'request_id'):\n            log_data[\"request_id\"] = record.request_id\n        \n        return json.dumps(log_data)\n\n# Setup logger with JSON formatter\nlogger = logging.getLogger(__name__)\nhandler = logging.StreamHandler()\nhandler.setFormatter(JSONFormatter())\nlogger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n\n# Usage with custom fields\nlogger.info(\"User logged in\", extra={\"user_id\": 123, \"request_id\": \"abc-123\"})\n```\n\n---\n\n## 26. Authentication & Security\n\n### Password Hashing\n\nSecure password handling is critical for any application with user authentication. Never store passwords in plain text. Understanding password hashing, salting, and secure authentication is essential for web development interviews.\n\n```python\nfrom passlib.context import CryptContext\n\n# Password hashing configuration\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt.\"\"\"\n    return pwd_context.hash(password)\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\n# Usage\npassword = \"SecurePassword123!\"\nhashed = hash_password(password)\nprint(f\"Hashed: {hashed}\")\n\n# Verification\nis_valid = verify_password(\"SecurePassword123!\", hashed)\nprint(f\"Password valid: {is_valid}\")\n\nis_invalid = verify_password(\"WrongPassword\", hashed)\nprint(f\"Wrong password valid: {is_invalid}\")\n```\n\n### JWT Authentication\n\n```python\nfrom datetime import datetime, timedelta\nfrom jose import JWTError, jwt\nfrom typing import Optional\n\n# Configuration\nSECRET_KEY = \"your-secret-key-keep-it-secret\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    \n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\ndef decode_access_token(token: str):\n    \"\"\"Decode and validate a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            return None\n        return payload\n    except JWTError:\n        return None\n\n# Usage\n# Create token\nuser_data = {\"sub\": \"john@example.com\", \"role\": \"admin\"}\ntoken = create_access_token(user_data, timedelta(minutes=30))\nprint(f\"Token: {token}\")\n\n# Verify token\ndecoded = decode_access_token(token)\nprint(f\"Decoded: {decoded}\")\n```\n\n### FastAPI Authentication\n\n```python\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\nfrom typing import Optional\n\napp = FastAPI()\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# Models\nclass User(BaseModel):\n    username: str\n    email: str\n    full_name: Optional[str] = None\n    disabled: Optional[bool] = None\n\nclass UserInDB(User):\n    hashed_password: str\n\n# Fake database\nfake_users_db = {\n    \"john\": {\n        \"username\": \"john\",\n        \"email\": \"john@example.com\",\n        \"full_name\": \"John Doe\",\n        \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\",\n        \"disabled\": False,\n    }\n}\n\ndef get_user(username: str):\n    \"\"\"Get user from database.\"\"\"\n    if username in fake_users_db:\n        user_dict = fake_users_db[username]\n        return UserInDB(**user_dict)\n\ndef authenticate_user(username: str, password: str):\n    \"\"\"Authenticate a user.\"\"\"\n    user = get_user(username)\n    if not user:\n        return False\n    if not verify_password(password, user.hashed_password):\n        return False\n    return user\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    \"\"\"Get current user from token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    \n    payload = decode_access_token(token)\n    if payload is None:\n        raise credentials_exception\n    \n    username: str = payload.get(\"sub\")\n    if username is None:\n        raise credentials_exception\n    \n    user = get_user(username)\n    if user is None:\n        raise credentials_exception\n    \n    return user\n\nasync def get_current_active_user(current_user: User = Depends(get_current_user)):\n    \"\"\"Get current active user.\"\"\"\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n\n# Endpoints\n@app.post(\"/token\")\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"Login endpoint to get access token.\"\"\"\n    user = authenticate_user(form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    access_token = create_access_token(\n        data={\"sub\": user.username},\n        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    )\n    \n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n@app.get(\"/users/me\")\nasync def read_users_me(current_user: User = Depends(get_current_active_user)):\n    \"\"\"Get current user info.\"\"\"\n    return current_user\n\n@app.get(\"/protected\")\nasync def protected_route(current_user: User = Depends(get_current_active_user)):\n    \"\"\"Protected endpoint requiring authentication.\"\"\"\n    return {\"message\": f\"Hello {current_user.username}!\"}\n```\n\n### API Security Best Practices\n\n```python\nfrom fastapi import FastAPI, Header, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\nfrom fastapi.middleware.gzip import GZIPMiddleware\nimport secrets\n\napp = FastAPI()\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"https://yourdomain.com\"],  # Specific origins\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    allow_headers=[\"*\"],\n)\n\n# Trusted host middleware\napp.add_middleware(\n    TrustedHostMiddleware,\n    allowed_hosts=[\"yourdomain.com\", \"*.yourdomain.com\"]\n)\n\n# GZIP compression\napp.add_middleware(GZIPMiddleware, minimum_size=1000)\n\n# API Key authentication\nAPI_KEYS = {\n    \"secret-key-1\": \"user1\",\n    \"secret-key-2\": \"user2\",\n}\n\nasync def verify_api_key(x_api_key: str = Header(...)):\n    \"\"\"Verify API key.\"\"\"\n    if x_api_key not in API_KEYS:\n        raise HTTPException(status_code=403, detail=\"Invalid API Key\")\n    return API_KEYS[x_api_key]\n\n@app.get(\"/api/data\")\nasync def get_data(user: str = Depends(verify_api_key)):\n    \"\"\"Protected endpoint with API key.\"\"\"\n    return {\"data\": \"secret information\", \"user\": user}\n\n# Rate limiting (using slowapi)\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.util import get_remote_address\nfrom slowapi.errors import RateLimitExceeded\n\nlimiter = Limiter(key_func=get_remote_address)\napp.state.limiter = limiter\napp.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\n\n@app.get(\"/limited\")\n@limiter.limit(\"5/minute\")\nasync def limited_endpoint(request: Request):\n    \"\"\"Endpoint with rate limiting.\"\"\"\n    return {\"message\": \"This endpoint is rate limited\"}\n```\n\n---\n\n## 27. Docker & Deployment\n\n### Dockerfile for Python Applications\n\nDocker containerization is standard in modern development. Understanding how to containerize Python applications is essential for deployment and frequently asked in interviews for backend positions.\n\n```dockerfile\n# Dockerfile\n# Multi-stage build for Python FastAPI application\n\n# Stage 1: Builder\nFROM python:3.11-slim as builder\n\nWORKDIR /app\n\n# Install dependencies\nCOPY requirements.txt .\nRUN pip install --user --no-cache-dir -r requirements.txt\n\n# Stage 2: Runtime\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Copy only necessary files from builder\nCOPY --from=builder /root/.local /root/.local\nCOPY . .\n\n# Make sure scripts in .local are usable\nENV PATH=/root/.local/bin:$PATH\n\n# Create non-root user\nRUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app\nUSER appuser\n\n# Expose port\nEXPOSE 8000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n    CMD python -c \"import requests; requests.get('http://localhost:8000/health')\"\n\n# Run application\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n### Docker Compose for Full Stack\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  # FastAPI application\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - DATABASE_URL=postgresql://user:password@db:5432/myapp\n      - REDIS_URL=redis://redis:6379\n    depends_on:\n      - db\n      - redis\n    volumes:\n      - ./app:/app\n    networks:\n      - app-network\n\n  # PostgreSQL database\n  db:\n    image: postgres:15-alpine\n    environment:\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=password\n      - POSTGRES_DB=myapp\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n    networks:\n      - app-network\n\n  # Redis cache\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n    networks:\n      - app-network\n\n  # Nginx reverse proxy\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n      - ./ssl:/etc/nginx/ssl\n    depends_on:\n      - api\n    networks:\n      - app-network\n\nvolumes:\n  postgres-data:\n\nnetworks:\n  app-network:\n    driver: bridge\n```\n\n### Python Application with Docker Commands\n\n```bash\n# Build image\ndocker build -t myapp:latest .\n\n# Run container\ndocker run -d -p 8000:8000 --name myapp-container myapp:latest\n\n# View logs\ndocker logs myapp-container\n\n# Execute command in container\ndocker exec -it myapp-container bash\n\n# Stop and remove container\ndocker stop myapp-container\ndocker rm myapp-container\n\n# Docker Compose commands\ndocker-compose up -d          # Start all services\ndocker-compose down           # Stop all services\ndocker-compose logs -f api    # View logs\ndocker-compose ps             # List services\ndocker-compose restart api    # Restart service\n```\n\n### Production-Ready FastAPI with Docker\n\n```python\n# main.py\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nimport logging\nimport os\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(\n    title=\"My API\",\n    version=\"1.0.0\",\n    docs_url=\"/api/docs\",\n    redoc_url=\"/api/redoc\"\n)\n\n# CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=os.getenv(\"ALLOWED_ORIGINS\", \"*\").split(\",\"),\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"Run on application startup.\"\"\"\n    logger.info(\"Application starting up...\")\n    # Initialize database connections, load models, etc.\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    \"\"\"Run on application shutdown.\"\"\"\n    logger.info(\"Application shutting down...\")\n    # Close database connections, cleanup resources\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint for Docker.\"\"\"\n    return {\"status\": \"healthy\", \"version\": \"1.0.0\"}\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint.\"\"\"\n    return {\"message\": \"Welcome to My API\"}\n\n# Run with: uvicorn main:app --host 0.0.0.0 --port 8000\n```\n\n---\n\n## 28. Design Patterns\n\n### Singleton Pattern\n\nDesign patterns provide proven solutions to common programming problems. Understanding design patterns demonstrates advanced knowledge and is frequently tested in senior developer interviews. They promote code reusability, maintainability, and scalability.\n\n```python\nclass Singleton:\n    \"\"\"Singleton pattern ensures only one instance exists.\"\"\"\n    _instance = None\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n# Usage\ns1 = Singleton()\ns2 = Singleton()\nprint(s1 is s2)  # True - same instance\n\n# Thread-safe Singleton\nimport threading\n\nclass ThreadSafeSingleton:\n    _instance = None\n    _lock = threading.Lock()\n    \n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n        return cls._instance\n\n# Practical example: Database connection\nclass DatabaseConnection:\n    _instance = None\n    _lock = threading.Lock()\n    \n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n                    cls._instance._initialize()\n        return cls._instance\n    \n    def _initialize(self):\n        self.connection = \"Connected to database\"\n        print(\"Database connection initialized\")\n    \n    def query(self, sql):\n        return f\"Executing: {sql}\"\n\n# All instances share the same connection\ndb1 = DatabaseConnection()\ndb2 = DatabaseConnection()\nprint(db1 is db2)  # True\n```\n\n### Factory Pattern\n\n```python\nfrom abc import ABC, abstractmethod\n\n# Abstract product\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self):\n        pass\n\n# Concrete products\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n\nclass Bird(Animal):\n    def speak(self):\n        return \"Chirp!\"\n\n# Factory\nclass AnimalFactory:\n    \"\"\"Factory pattern creates objects without specifying exact class.\"\"\"\n    \n    @staticmethod\n    def create_animal(animal_type: str) -> Animal:\n        animals = {\n            \"dog\": Dog,\n            \"cat\": Cat,\n            \"bird\": Bird\n        }\n        \n        animal_class = animals.get(animal_type.lower())\n        if animal_class is None:\n            raise ValueError(f\"Unknown animal type: {animal_type}\")\n        \n        return animal_class()\n\n# Usage\nfactory = AnimalFactory()\ndog = factory.create_animal(\"dog\")\ncat = factory.create_animal(\"cat\")\n\nprint(dog.speak())  # \"Woof!\"\nprint(cat.speak())  # \"Meow!\"\n\n# Practical example: API Client Factory\nclass APIClient(ABC):\n    @abstractmethod\n    def request(self, endpoint: str):\n        pass\n\nclass RESTClient(APIClient):\n    def request(self, endpoint: str):\n        return f\"REST request to {endpoint}\"\n\nclass GraphQLClient(APIClient):\n    def request(self, endpoint: str):\n        return f\"GraphQL query to {endpoint}\"\n\nclass ClientFactory:\n    @staticmethod\n    def create_client(client_type: str) -> APIClient:\n        clients = {\n            \"rest\": RESTClient,\n            \"graphql\": GraphQLClient\n        }\n        return clients[client_type]()\n```\n\n### Observer Pattern\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\n# Observer interface\nclass Observer(ABC):\n    @abstractmethod\n    def update(self, message: str):\n        pass\n\n# Subject (Observable)\nclass Subject:\n    \"\"\"Subject maintains list of observers and notifies them of changes.\"\"\"\n    \n    def __init__(self):\n        self._observers: List[Observer] = []\n        self._state = None\n    \n    def attach(self, observer: Observer):\n        \"\"\"Add an observer.\"\"\"\n        if observer not in self._observers:\n            self._observers.append(observer)\n    \n    def detach(self, observer: Observer):\n        \"\"\"Remove an observer.\"\"\"\n        self._observers.remove(observer)\n    \n    def notify(self, message: str):\n        \"\"\"Notify all observers.\"\"\"\n        for observer in self._observers:\n            observer.update(message)\n    \n    def set_state(self, state):\n        \"\"\"Change state and notify observers.\"\"\"\n        self._state = state\n        self.notify(f\"State changed to: {state}\")\n\n# Concrete observers\nclass EmailNotifier(Observer):\n    def update(self, message: str):\n        print(f\"Email notification: {message}\")\n\nclass SMSNotifier(Observer):\n    def update(self, message: str):\n        print(f\"SMS notification: {message}\")\n\nclass PushNotifier(Observer):\n    def update(self, message: str):\n        print(f\"Push notification: {message}\")\n\n# Usage\nsubject = Subject()\n\nemail = EmailNotifier()\nsms = SMSNotifier()\npush = PushNotifier()\n\nsubject.attach(email)\nsubject.attach(sms)\nsubject.attach(push)\n\nsubject.set_state(\"Order shipped\")\n# Output:\n# Email notification: State changed to: Order shipped\n# SMS notification: State changed to: Order shipped\n# Push notification: State changed to: Order shipped\n\nsubject.detach(sms)\nsubject.set_state(\"Order delivered\")\n# Only email and push notifiers receive this\n```\n\n### Strategy Pattern\n\n```python\nfrom abc import ABC, abstractmethod\n\n# Strategy interface\nclass PaymentStrategy(ABC):\n    @abstractmethod\n    def pay(self, amount: float):\n        pass\n\n# Concrete strategies\nclass CreditCardPayment(PaymentStrategy):\n    def __init__(self, card_number: str, cvv: str):\n        self.card_number = card_number\n        self.cvv = cvv\n    \n    def pay(self, amount: float):\n        return f\"Paid ${amount} using Credit Card ending in {self.card_number[-4:]}\"\n\nclass PayPalPayment(PaymentStrategy):\n    def __init__(self, email: str):\n        self.email = email\n    \n    def pay(self, amount: float):\n        return f\"Paid ${amount} using PayPal account {self.email}\"\n\nclass CryptoPayment(PaymentStrategy):\n    def __init__(self, wallet_address: str):\n        self.wallet_address = wallet_address\n    \n    def pay(self, amount: float):\n        return f\"Paid ${amount} using Crypto wallet {self.wallet_address}\"\n\n# Context\nclass ShoppingCart:\n    \"\"\"Context uses Strategy pattern to allow different payment methods.\"\"\"\n    \n    def __init__(self):\n        self.items = []\n        self.payment_strategy = None\n    \n    def add_item(self, item: str, price: float):\n        self.items.append((item, price))\n    \n    def set_payment_strategy(self, strategy: PaymentStrategy):\n        self.payment_strategy = strategy\n    \n    def checkout(self):\n        total = sum(price for _, price in self.items)\n        if self.payment_strategy is None:\n            return \"No payment method selected\"\n        return self.payment_strategy.pay(total)\n\n# Usage\ncart = ShoppingCart()\ncart.add_item(\"Laptop\", 999.99)\ncart.add_item(\"Mouse\", 29.99)\n\n# Pay with credit card\ncart.set_payment_strategy(CreditCardPayment(\"1234567890123456\", \"123\"))\nprint(cart.checkout())\n\n# Pay with PayPal\ncart.set_payment_strategy(PayPalPayment(\"user@example.com\"))\nprint(cart.checkout())\n\n# Pay with Crypto\ncart.set_payment_strategy(CryptoPayment(\"0x1234...\"))\nprint(cart.checkout())\n```\n\n### Decorator Pattern\n\n```python\nfrom abc import ABC, abstractmethod\n\n# Component interface\nclass Coffee(ABC):\n    @abstractmethod\n    def cost(self) -> float:\n        pass\n    \n    @abstractmethod\n    def description(self) -> str:\n        pass\n\n# Concrete component\nclass SimpleCoffee(Coffee):\n    def cost(self) -> float:\n        return 2.0\n    \n    def description(self) -> str:\n        return \"Simple coffee\"\n\n# Decorator base class\nclass CoffeeDecorator(Coffee):\n    def __init__(self, coffee: Coffee):\n        self._coffee = coffee\n    \n    def cost(self) -> float:\n        return self._coffee.cost()\n    \n    def description(self) -> str:\n        return self._coffee.description()\n\n# Concrete decorators\nclass Milk(CoffeeDecorator):\n    def cost(self) -> float:\n        return self._coffee.cost() + 0.5\n    \n    def description(self) -> str:\n        return self._coffee.description() + \", milk\"\n\nclass Sugar(CoffeeDecorator):\n    def cost(self) -> float:\n        return self._coffee.cost() + 0.2\n    \n    def description(self) -> str:\n        return self._coffee.description() + \", sugar\"\n\nclass WhippedCream(CoffeeDecorator):\n    def cost(self) -> float:\n        return self._coffee.cost() + 0.7\n    \n    def description(self) -> str:\n        return self._coffee.description() + \", whipped cream\"\n\n# Usage\ncoffee = SimpleCoffee()\nprint(f\"{coffee.description()}: ${coffee.cost()}\")\n\n# Add milk\ncoffee = Milk(coffee)\nprint(f\"{coffee.description()}: ${coffee.cost()}\")\n\n# Add sugar\ncoffee = Sugar(coffee)\nprint(f\"{coffee.description()}: ${coffee.cost()}\")\n\n# Add whipped cream\ncoffee = WhippedCream(coffee)\nprint(f\"{coffee.description()}: ${coffee.cost()}\")\n# Output: Simple coffee, milk, sugar, whipped cream: $3.4\n```\n\n---\n\n## 29. Caching & Performance Optimization\n\n### Function Caching with functools\n\nCaching stores computed results to avoid redundant calculations, dramatically improving performance. Understanding caching strategies is crucial for building scalable applications and is a common topic in performance optimization interviews.\n\n```python\nfrom functools import lru_cache, cache\nimport time\n\n# LRU Cache (Least Recently Used)\n@lru_cache(maxsize=128)\ndef fibonacci(n):\n    \"\"\"Fibonacci with caching - O(n) instead of O(2^n).\"\"\"\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Test performance\nstart = time.time()\nresult = fibonacci(35)\nprint(f\"Result: {result}, Time: {time.time() - start:.4f}s\")\n\n# Cache info\nprint(fibonacci.cache_info())\n# CacheInfo(hits=33, misses=36, maxsize=128, currsize=36)\n\n# Clear cache\nfibonacci.cache_clear()\n\n# Simple cache (Python 3.9+) - unbounded\n@cache\ndef expensive_computation(x, y):\n    \"\"\"Cached computation with no size limit.\"\"\"\n    time.sleep(1)  # Simulate expensive operation\n    return x ** y\n\n# First call: slow\nprint(expensive_computation(2, 10))  # Takes 1 second\n\n# Second call: instant\nprint(expensive_computation(2, 10))  # Instant from cache\n```\n\n### Redis Caching\n\n```python\nimport redis\nimport json\nfrom functools import wraps\nfrom typing import Callable, Any\n\n# Redis connection\nredis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)\n\ndef redis_cache(expiration: int = 3600):\n    \"\"\"Decorator for Redis caching.\"\"\"\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> Any:\n            # Create cache key\n            cache_key = f\"{func.__name__}:{str(args)}:{str(kwargs)}\"\n            \n            # Try to get from cache\n            cached_result = redis_client.get(cache_key)\n            if cached_result is not None:\n                print(f\"Cache HIT for {cache_key}\")\n                return json.loads(cached_result)\n            \n            # Compute result\n            print(f\"Cache MISS for {cache_key}\")\n            result = func(*args, **kwargs)\n            \n            # Store in cache\n            redis_client.setex(\n                cache_key,\n                expiration,\n                json.dumps(result)\n            )\n            \n            return result\n        return wrapper\n    return decorator\n\n@redis_cache(expiration=300)  # Cache for 5 minutes\ndef get_user_data(user_id: int):\n    \"\"\"Simulate expensive database query.\"\"\"\n    time.sleep(2)  # Simulate slow query\n    return {\n        \"id\": user_id,\n        \"name\": f\"User {user_id}\",\n        \"email\": f\"user{user_id}@example.com\"\n    }\n\n# First call: slow (cache miss)\nuser = get_user_data(123)\n\n# Second call: fast (cache hit)\nuser = get_user_data(123)\n```\n\n### Caching with FastAPI\n\n```python\nfrom fastapi import FastAPI, Depends\nfrom functools import lru_cache\nimport time\n\napp = FastAPI()\n\n# Cache configuration\n@lru_cache()\ndef get_settings():\n    \"\"\"Cached settings - loaded once.\"\"\"\n    print(\"Loading settings...\")\n    return {\n        \"app_name\": \"My API\",\n        \"admin_email\": \"admin@example.com\",\n        \"items_per_page\": 50\n    }\n\n@app.get(\"/info\")\nasync def info(settings: dict = Depends(get_settings)):\n    \"\"\"Endpoint using cached settings.\"\"\"\n    return settings\n\n# Response caching middleware\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nimport hashlib\n\nclass CacheMiddleware(BaseHTTPMiddleware):\n    def __init__(self, app, cache_time: int = 60):\n        super().__init__(app)\n        self.cache = {}\n        self.cache_time = cache_time\n    \n    async def dispatch(self, request: Request, call_next):\n        # Only cache GET requests\n        if request.method != \"GET\":\n            return await call_next(request)\n        \n        # Create cache key\n        cache_key = hashlib.md5(\n            f\"{request.url.path}{request.url.query}\".encode()\n        ).hexdigest()\n        \n        # Check cache\n        if cache_key in self.cache:\n            cached_response, timestamp = self.cache[cache_key]\n            if time.time() - timestamp < self.cache_time:\n                return cached_response\n        \n        # Get fresh response\n        response = await call_next(request)\n        \n        # Cache response\n        self.cache[cache_key] = (response, time.time())\n        \n        return response\n\n# Add caching middleware\napp.add_middleware(CacheMiddleware, cache_time=60)\n\n# Manual caching for specific endpoints\ncache_store = {}\n\n@app.get(\"/expensive-operation\")\nasync def expensive_operation():\n    \"\"\"Manually cached endpoint.\"\"\"\n    cache_key = \"expensive_operation\"\n    \n    # Check cache\n    if cache_key in cache_store:\n        cached_data, timestamp = cache_store[cache_key]\n        if time.time() - timestamp < 300:  # 5 minutes\n            return {\"data\": cached_data, \"cached\": True}\n    \n    # Perform expensive operation\n    time.sleep(2)\n    result = {\"value\": 12345, \"computed\": True}\n    \n    # Cache result\n    cache_store[cache_key] = (result, time.time())\n    \n    return {\"data\": result, \"cached\": False}\n```\n\n### Cache Strategies and Best Practices\n\n```python\nimport time\nfrom typing import Dict, Any, Optional\nfrom datetime import datetime, timedelta\n\nclass CacheManager:\n    \"\"\"Advanced cache manager with multiple strategies.\"\"\"\n    \n    def __init__(self):\n        self.cache: Dict[str, Dict[str, Any]] = {}\n    \n    def get(self, key: str) -> Optional[Any]:\n        \"\"\"Get value from cache.\"\"\"\n        if key in self.cache:\n            entry = self.cache[key]\n            \n            # Check expiration\n            if entry[\"expires_at\"] > datetime.now():\n                entry[\"hits\"] += 1\n                entry[\"last_accessed\"] = datetime.now()\n                return entry[\"value\"]\n            else:\n                # Expired\n                del self.cache[key]\n        \n        return None\n    \n    def set(self, key: str, value: Any, ttl: int = 3600):\n        \"\"\"Set value in cache with TTL.\"\"\"\n        self.cache[key] = {\n            \"value\": value,\n            \"created_at\": datetime.now(),\n            \"last_accessed\": datetime.now(),\n            \"expires_at\": datetime.now() + timedelta(seconds=ttl),\n            \"hits\": 0\n        }\n    \n    def invalidate(self, key: str):\n        \"\"\"Remove key from cache.\"\"\"\n        if key in self.cache:\n            del self.cache[key]\n    \n    def clear(self):\n        \"\"\"Clear all cache.\"\"\"\n        self.cache.clear()\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get cache statistics.\"\"\"\n        total_hits = sum(entry[\"hits\"] for entry in self.cache.values())\n        return {\n            \"total_keys\": len(self.cache),\n            \"total_hits\": total_hits,\n            \"keys\": list(self.cache.keys())\n        }\n\n# Usage\ncache = CacheManager()\n\n# Cache with 5-minute TTL\ncache.set(\"user:123\", {\"name\": \"Alice\", \"email\": \"alice@example.com\"}, ttl=300)\n\n# Get from cache\nuser = cache.get(\"user:123\")\nprint(user)\n\n# Get stats\nprint(cache.get_stats())\n\n# Cache invalidation patterns\n\n# 1. Time-based expiration (TTL)\ncache.set(\"temp_data\", \"value\", ttl=60)\n\n# 2. Manual invalidation on update\ndef update_user(user_id, data):\n    # Update database\n    # ...\n    # Invalidate cache\n    cache.invalidate(f\"user:{user_id}\")\n\n# 3. Cache warming (preload)\ndef warm_cache():\n    \"\"\"Preload frequently accessed data.\"\"\"\n    popular_users = [1, 2, 3, 4, 5]\n    for user_id in popular_users:\n        user_data = get_user_from_db(user_id)\n        cache.set(f\"user:{user_id}\", user_data)\n\n# 4. Cache-aside pattern\ndef get_user_cached(user_id):\n    \"\"\"Cache-aside: Check cache first, then database.\"\"\"\n    # Try cache first\n    cached = cache.get(f\"user:{user_id}\")\n    if cached:\n        return cached\n    \n    # Cache miss: get from database\n    user = get_user_from_db(user_id)\n    \n    # Store in cache\n    cache.set(f\"user:{user_id}\", user)\n    \n    return user\n```\n\n---\n\n## üöÄ Next Steps for Mastery\n\n1. **Practice Coding Challenges**\n   - LeetCode, HackerRank, CodeSignal\n   - Focus on algorithms and data structures\n\n2. **Build Real Projects**\n   - Web applications with Django/Flask\n   - Data analysis projects with pandas\n   - Automation scripts\n\n3. **Advanced Topics**\n   - Async programming with asyncio\n   - Design patterns implementation\n   - Performance optimization\n\n4. **Testing and Quality**\n   - Test-driven development (TDD)\n   - Code coverage analysis\n   - Static type checking with mypy\n\n5. **Open Source Contribution**\n   - Contribute to Python packages\n   - Create your own packages\n   - Learn collaborative development\n\n---\n\n## üìñ Key Python Concepts Summary\n\n| Category | Key Topics |\n|----------|------------|\n| **Fundamentals** | Variables, data types, string operations |\n| **Data Structures** | Lists, dicts, sets, tuples, comprehensions |\n| **Control Flow** | Conditionals, loops, iteration patterns |\n| **Functions** | Parameters, lambdas, decorators, generators |\n| **OOP** | Classes, inheritance, special methods, SOLID principles |\n| **Advanced** | Context managers, metaclasses, descriptors, async/await |\n| **Web Development** | FastAPI, REST APIs, authentication, JWT |\n| **Database** | SQLAlchemy ORM, async database operations |\n| **Testing** | Pytest, unit testing, integration testing, mocking |\n| **Concurrency** | Threading, asyncio, multiprocessing |\n| **DevOps** | Docker, virtual environments, deployment |\n| **Security** | Password hashing, JWT, API security, authentication |\n| **Performance** | Caching strategies, Redis, optimization techniques |\n| **Best Practices** | PEP 8, type hints, logging, error handling, design patterns |\n| **Patterns** | Singleton, Factory, Observer, Strategy, Decorator |\n| **Tools** | pip, poetry, regex, environment variables |\n\n---\n\n> **üéâ Congratulations!** You now have a complete Python reference covering all concepts from beginner to expert level. This guide prepares you for any Python interview, project, or advanced development work."}