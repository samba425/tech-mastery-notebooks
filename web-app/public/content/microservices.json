{"id":"microservices","title":"ğŸ”§ Microservices Architecture Complete Guide","content":"# Microservices Architecture: Complete Guide\n## From Monolith to Microservices Mastery\n\n---\n\n## ğŸ“š Table of Contents\n\n1. [Introduction to Microservices](#introduction)\n2. [Microservices vs Monolith](#comparison)\n3. [Design Principles](#principles)\n4. [Service Communication](#communication)\n5. [API Gateway Pattern](#api-gateway)\n6. [Service Discovery](#discovery)\n7. [Data Management](#data)\n8. [Authentication & Authorization](#auth)\n9. [Observability & Monitoring](#monitoring)\n10. [Resilience Patterns](#resilience)\n11. [Container & Orchestration](#containers)\n12. [CI/CD for Microservices](#cicd)\n13. [Testing Strategies](#testing)\n14. [Best Practices](#best-practices)\n15. [Real-World Implementation](#projects)\n\n---\n\n## ğŸ¯ Introduction to Microservices {#introduction}\n\n### What are Microservices?\n\n**Microservices** is an architectural style where an application is built as a collection of small, independent services that communicate through APIs.\n\n```\nTraditional Monolith\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚     Single Application         â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚  â”‚  UI + Business + Data    â”‚ â”‚\nâ”‚  â”‚  All in one codebase     â”‚ â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nMicroservices\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  User    â”‚  â”‚ Product  â”‚  â”‚  Order   â”‚\nâ”‚ Service  â”‚  â”‚ Service  â”‚  â”‚ Service  â”‚\nâ””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜\n     â”‚             â”‚             â”‚\n     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n           API Gateway\n```\n\n### Key Characteristics\n\n- âœ… **Independently Deployable** - Each service can be deployed separately\n- âœ… **Loosely Coupled** - Services don't depend on each other's implementation\n- âœ… **Single Responsibility** - Each service does one thing well\n- âœ… **Technology Agnostic** - Different services can use different tech stacks\n- âœ… **Resilient** - Failure in one service doesn't crash entire system\n\n---\n\n## ğŸ”„ Microservices vs Monolith {#comparison}\n\n### Architecture Comparison\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚               MONOLITH                                  â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Pros:                          Cons:                   â”‚\nâ”‚  âœ… Simple to develop           âŒ Hard to scale        â”‚\nâ”‚  âœ… Easy to test               âŒ Technology lock-in   â”‚\nâ”‚  âœ… Simple deployment          âŒ Long deployments     â”‚\nâ”‚  âœ… Easy debugging             âŒ Risk of failure      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚             MICROSERVICES                               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Pros:                          Cons:                   â”‚\nâ”‚  âœ… Independent scaling        âŒ Complex to set up    â”‚\nâ”‚  âœ… Technology freedom         âŒ Distributed debugging â”‚\nâ”‚  âœ… Fault isolation            âŒ Network overhead     â”‚\nâ”‚  âœ… Team autonomy              âŒ Data consistency     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### When to Use Microservices?\n\n**Use Microservices When:**\n- Large, complex applications\n- Need to scale different parts independently\n- Multiple teams working on different features\n- Frequent deployments required\n- Different technology stacks needed\n\n**Stick with Monolith When:**\n- Small team (< 10 developers)\n- Simple application\n- Just starting out\n- Limited DevOps capacity\n- Predictable scaling needs\n\n---\n\n## ğŸ“ Design Principles {#principles}\n\n### 1. Single Responsibility\n\nEach service should do **one thing** and do it well.\n\n```\nâŒ Bad: UserService\n- User management\n- Authentication\n- Email notifications\n- Order processing\n\nâœ… Good: Separate Services\n- UserService: User CRUD operations\n- AuthService: Authentication & authorization\n- NotificationService: Email/SMS notifications\n- OrderService: Order processing\n```\n\n### 2. Service Boundaries\n\nDefine clear boundaries using Domain-Driven Design (DDD).\n\n```\nE-commerce Domain\nâ”œâ”€â”€ User Management (Bounded Context)\nâ”‚   â””â”€â”€ UserService\nâ”œâ”€â”€ Product Catalog (Bounded Context)\nâ”‚   â”œâ”€â”€ ProductService\nâ”‚   â””â”€â”€ CategoryService\nâ”œâ”€â”€ Shopping (Bounded Context)\nâ”‚   â”œâ”€â”€ CartService\nâ”‚   â””â”€â”€ OrderService\nâ””â”€â”€ Payment (Bounded Context)\n    â””â”€â”€ PaymentService\n```\n\n### 3. Data Ownership\n\nEach service owns its database - **no shared databases!**\n\n```\nâŒ Bad: Shared Database\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ UserSvc  â”‚   â”‚OrderSvc  â”‚\nâ””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜\n     â”‚              â”‚\n     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜\n            â–¼\n      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n      â”‚ Database â”‚\n      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâœ… Good: Database per Service\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ UserSvc  â”‚      â”‚OrderSvc  â”‚\nâ””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜\n     â–¼                 â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  User DB â”‚      â”‚Order DB  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### 4. Loose Coupling\n\nServices should communicate through well-defined APIs, not direct database access.\n\n```javascript\n// âŒ Bad: Direct DB access\nconst user = await db.users.findOne({ id: userId })\n\n// âœ… Good: API call\nconst user = await fetch(`http://user-service/api/users/${userId}`)\n  .then(res => res.json())\n```\n\n---\n\n## ğŸ”Œ Service Communication {#communication}\n\n### Synchronous Communication (REST)\n\n**Use for:** Request-response patterns, real-time data\n\n```\nClient â”€â”€â”€â”€â”€â”€â–¶ API Gateway â”€â”€â”€â”€â”€â”€â–¶ User Service\n                                        â”‚\n                                        â–¼\n                                   Response\n```\n\n**Example: REST API**\n\n```javascript\n// User Service - Express.js\nconst express = require('express')\nconst app = express()\n\napp.get('/api/users/:id', async (req, res) => {\n  const user = await User.findById(req.params.id)\n  res.json({ success: true, data: user })\n})\n\napp.listen(3001, () => console.log('User service on port 3001'))\n```\n\n```javascript\n// Order Service - Calling User Service\nconst axios = require('axios')\n\nasync function createOrder(userId, items) {\n  // Call User Service\n  const userResponse = await axios.get(\n    `http://user-service:3001/api/users/${userId}`\n  )\n  \n  const user = userResponse.data.data\n  \n  // Create order\n  const order = await Order.create({\n    userId: user.id,\n    userName: user.name,\n    items\n  })\n  \n  return order\n}\n```\n\n### Asynchronous Communication (Message Queue)\n\n**Use for:** Event-driven, decoupled services, background processing\n\n```\nService A â”€â”€â”€â”€â–¶ Message Queue â”€â”€â”€â”€â–¶ Service B\n                    â”‚\n                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Service C\n```\n\n**Example: RabbitMQ**\n\n```javascript\n// Producer (Order Service) - Publish Event\nconst amqp = require('amqplib')\n\nasync function publishOrderCreated(order) {\n  const connection = await amqp.connect('amqp://localhost')\n  const channel = await connection.createChannel()\n  \n  const exchange = 'orders'\n  await channel.assertExchange(exchange, 'fanout', { durable: true })\n  \n  const message = JSON.stringify({\n    event: 'ORDER_CREATED',\n    data: order\n  })\n  \n  channel.publish(exchange, '', Buffer.from(message))\n  console.log('Published ORDER_CREATED event')\n  \n  await channel.close()\n  await connection.close()\n}\n\n// After creating order\nconst order = await Order.create({ userId, items })\nawait publishOrderCreated(order)\n```\n\n```javascript\n// Consumer (Email Service) - Subscribe to Events\nasync function subscribeToOrderEvents() {\n  const connection = await amqp.connect('amqp://localhost')\n  const channel = await connection.createChannel()\n  \n  const exchange = 'orders'\n  await channel.assertExchange(exchange, 'fanout', { durable: true })\n  \n  const q = await channel.assertQueue('', { exclusive: true })\n  channel.bindQueue(q.queue, exchange, '')\n  \n  console.log('Waiting for order events...')\n  \n  channel.consume(q.queue, async (msg) => {\n    const event = JSON.parse(msg.content.toString())\n    \n    if (event.event === 'ORDER_CREATED') {\n      // Send confirmation email\n      await sendOrderConfirmationEmail(event.data)\n      console.log('Sent order confirmation email')\n    }\n    \n    channel.ack(msg)\n  })\n}\n\nsubscribeToOrderEvents()\n```\n\n### Communication Patterns\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Synchronous (REST/gRPC)                   â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  âœ… Simple to understand                   â”‚\nâ”‚  âœ… Immediate response                     â”‚\nâ”‚  âŒ Tight coupling                         â”‚\nâ”‚  âŒ Service availability dependency        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Asynchronous (Message Queue/Events)       â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  âœ… Loose coupling                         â”‚\nâ”‚  âœ… Better fault tolerance                 â”‚\nâ”‚  âœ… Load leveling                          â”‚\nâ”‚  âŒ Complex to debug                       â”‚\nâ”‚  âŒ Eventual consistency                   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## ğŸšª API Gateway Pattern {#api-gateway}\n\n### What is API Gateway?\n\nSingle entry point for all client requests that routes to appropriate microservices.\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Mobile  â”‚â”€â”\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\nâ”‚   Web    â”‚â”€â”¼â”€â”€â–¶ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ API Gateway  â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜\nâ”‚   IoT    â”‚â”€â”˜           â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”Œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\n                   â”‚     â”‚     â”‚     â”‚\n               â”Œâ”€â”€â”€â–¼â” â”Œâ”€â”€â–¼â”€â” â”Œâ”€â–¼â”€â”€â” â”Œâ–¼â”€â”€â”€â”€â”\n               â”‚Userâ”‚ â”‚Prodâ”‚ â”‚Orderâ”‚ â”‚Auth â”‚\n               â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜\n```\n\n### API Gateway Responsibilities\n\n- **Routing** - Direct requests to correct service\n- **Authentication** - Verify user identity\n- **Rate Limiting** - Prevent abuse\n- **Load Balancing** - Distribute requests\n- **Request Aggregation** - Combine multiple service calls\n- **Caching** - Reduce backend load\n\n### Example: Express API Gateway\n\n```javascript\n// api-gateway/server.js\nconst express = require('express')\nconst { createProxyMiddleware } = require('http-proxy-middleware')\nconst rateLimit = require('express-rate-limit')\n\nconst app = express()\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n})\n\napp.use(limiter)\n\n// Authentication middleware\nconst authenticate = (req, res, next) => {\n  const token = req.headers.authorization\n  \n  if (!token) {\n    return res.status(401).json({ error: 'No token provided' })\n  }\n  \n  // Verify token\n  // ... token verification logic\n  next()\n}\n\n// Route to User Service\napp.use('/api/users', authenticate, createProxyMiddleware({\n  target: 'http://user-service:3001',\n  changeOrigin: true,\n  pathRewrite: {\n    '^/api/users': '/api/users'\n  }\n}))\n\n// Route to Product Service\napp.use('/api/products', createProxyMiddleware({\n  target: 'http://product-service:3002',\n  changeOrigin: true\n}))\n\n// Route to Order Service\napp.use('/api/orders', authenticate, createProxyMiddleware({\n  target: 'http://order-service:3003',\n  changeOrigin: true\n}))\n\n// Request aggregation example\napp.get('/api/dashboard/:userId', authenticate, async (req, res) => {\n  try {\n    const userId = req.params.userId\n    \n    // Fetch data from multiple services in parallel\n    const [user, orders, recommendations] = await Promise.all([\n      fetch(`http://user-service:3001/api/users/${userId}`),\n      fetch(`http://order-service:3003/api/orders?userId=${userId}`),\n      fetch(`http://recommendation-service:3004/api/recommendations/${userId}`)\n    ])\n    \n    // Aggregate response\n    res.json({\n      user: await user.json(),\n      orders: await orders.json(),\n      recommendations: await recommendations.json()\n    })\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to fetch dashboard data' })\n  }\n})\n\napp.listen(3000, () => {\n  console.log('API Gateway running on port 3000')\n})\n```\n\n---\n\n## ğŸ” Service Discovery {#discovery}\n\n### What is Service Discovery?\n\nMechanism for services to find each other dynamically.\n\n```\nWithout Service Discovery (Hardcoded URLs)\nService A â”€â”€â–¶ http://service-b:3002 âŒ What if port changes?\n\nWith Service Discovery\nService A â”€â”€â–¶ Service Registry â”€â”€â–¶ Find Service B\n              (Consul/Eureka)       (Dynamic IP:Port)\n```\n\n### Consul Example\n\n```javascript\n// Register service with Consul\nconst Consul = require('consul')\nconst consul = new Consul()\n\n// Register User Service\nconst registerService = async () => {\n  await consul.agent.service.register({\n    name: 'user-service',\n    id: 'user-service-1',\n    address: 'localhost',\n    port: 3001,\n    check: {\n      http: 'http://localhost:3001/health',\n      interval: '10s'\n    }\n  })\n  console.log('Service registered with Consul')\n}\n\nregisterService()\n\n// Discover and call service\nconst discoverService = async (serviceName) => {\n  const services = await consul.health.service({\n    service: serviceName,\n    passing: true\n  })\n  \n  if (services.length === 0) {\n    throw new Error(`Service ${serviceName} not found`)\n  }\n  \n  // Get first healthy instance\n  const service = services[0].Service\n  return `http://${service.Address}:${service.Port}`\n}\n\n// Use service discovery\nconst userServiceUrl = await discoverService('user-service')\nconst response = await fetch(`${userServiceUrl}/api/users/123`)\n```\n\n---\n\n## ğŸ’¾ Data Management {#data}\n\n### Database Per Service Pattern\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ User Service â”‚      â”‚Product Serviceâ”‚     â”‚Order Service â”‚\nâ””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜\n       â”‚                     â”‚                     â”‚\n       â–¼                     â–¼                     â–¼\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ User DB â”‚          â”‚Product DBâ”‚          â”‚Order DB â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Saga Pattern (Distributed Transactions)\n\n**What is Saga Pattern?**\n\nSaga is a design pattern for managing distributed transactions across multiple microservices without using traditional two-phase commit. Each service performs a local transaction and publishes an event or message.\n\n**Why Use Saga?**\n\n- **No Distributed Locks**: Avoids the complexity and performance issues of 2PC (two-phase commit)\n- **High Availability**: Services remain independent, no blocking transactions\n- **Eventual Consistency**: Data becomes consistent over time, not immediately\n- **Fault Tolerance**: Built-in compensation for failures\n\n**How Saga Works:**\n\n1. **Forward Flow**: Each service completes its transaction and triggers the next\n2. **Compensation Flow**: If any step fails, execute compensating transactions to rollback previous steps\n\n**Two Implementation Approaches:**\n\n1. **Choreography**: Each service listens to events and knows what to do next (decentralized)\n2. **Orchestration**: Central coordinator tells each service what to do (centralized)\n\n**Saga Flow Example:**\n```\n[Create Order] â†’ [Reserve Inventory] â†’ [Process Payment] â†’ [Confirm Order]\n       â†“                  â†“                    âœ—               \n[Cancel Order] â† [Release Inventory] â† [Compensation Needed]\n```\n\n**When to Use Saga:**\n- Multi-step business processes across services\n- E-commerce order processing\n- Travel booking systems\n- Financial transactions\n- Any workflow requiring cross-service consistency\n\n**Challenges:**\n- Complex error handling and compensation logic\n- Eventual consistency (not immediate)\n- Debugging distributed workflows\n\n**Example: Order Processing Saga**\n\n```javascript\n// Order Service\nasync function createOrder(userId, items) {\n  // Step 1: Create order (pending)\n  const order = await Order.create({\n    userId,\n    items,\n    status: 'PENDING',\n    totalAmount: calculateTotal(items)\n  })\n  \n  try {\n    // Step 2: Reserve inventory\n    await fetch('http://inventory-service/api/reserve', {\n      method: 'POST',\n      body: JSON.stringify({ orderId: order.id, items })\n    })\n    \n    // Step 3: Process payment\n    const payment = await fetch('http://payment-service/api/charge', {\n      method: 'POST',\n      body: JSON.stringify({\n        userId,\n        amount: order.totalAmount\n      })\n    })\n    \n    // Step 4: Update order status\n    order.status = 'CONFIRMED'\n    await order.save()\n    \n    return order\n    \n  } catch (error) {\n    // Compensating transactions (rollback)\n    \n    // Release inventory\n    await fetch('http://inventory-service/api/release', {\n      method: 'POST',\n      body: JSON.stringify({ orderId: order.id })\n    })\n    \n    // Cancel order\n    order.status = 'CANCELLED'\n    await order.save()\n    \n    throw error\n  }\n}\n```\n\n### Event Sourcing\n\n**What is Event Sourcing?**\n\nEvent Sourcing stores all changes to application state as a sequence of events, rather than just storing the current state. The current state is derived by replaying all events.\n\n**Why Use Event Sourcing?**\n\n- **Complete Audit Trail**: Every change is recorded, perfect for compliance\n- **Time Travel**: Reconstruct state at any point in time\n- **Debugging**: Replay events to understand what happened\n- **Event-Driven Architecture**: Natural fit for microservices\n- **Flexibility**: Create new views/reports from historical events\n\n**How Event Sourcing Works:**\n\n1. **Command**: User action (e.g., \"Create Order\")\n2. **Event**: Result stored (e.g., \"OrderCreated\", \"PaymentProcessed\")\n3. **Event Store**: Append-only log of all events\n4. **Projection**: Current state built by replaying events\n\n**Event Sourcing Flow:**\n```\nCommand â†’ Validate â†’ Create Event â†’ Store Event â†’ Update Projection\n                                         â†“\n                                    [Event Store]\n                                    - OrderCreated\n                                    - ItemAdded\n                                    - PaymentProcessed\n```\n\n**When to Use Event Sourcing:**\n- Banking and financial systems (audit requirements)\n- Collaborative applications (version control, undo/redo)\n- Complex business domains\n- Systems requiring complete history\n\n**Challenges:**\n- Event schema evolution\n- Storage costs (all events forever)\n- Complex querying (need projections)\n- Learning curve\n\nStore all changes as a sequence of events.\n\n```javascript\n// Events\nconst events = [\n  { type: 'ORDER_CREATED', orderId: 1, items: [...] },\n  { type: 'PAYMENT_PROCESSED', orderId: 1, amount: 100 },\n  { type: 'ORDER_SHIPPED', orderId: 1, trackingId: 'ABC123' }\n]\n\n// Rebuild state from events\nfunction rebuildOrderState(events) {\n  let order = {}\n  \n  for (const event of events) {\n    switch (event.type) {\n      case 'ORDER_CREATED':\n        order = { id: event.orderId, items: event.items, status: 'CREATED' }\n        break\n      case 'PAYMENT_PROCESSED':\n        order.status = 'PAID'\n        break\n      case 'ORDER_SHIPPED':\n        order.status = 'SHIPPED'\n        order.trackingId = event.trackingId\n        break\n    }\n  }\n  \n  return order\n}\n```\n\n### CQRS (Command Query Responsibility Segregation)\n\n**What is CQRS?**\n\nCQRS separates read and write operations into different models. Commands (writes) modify data, while Queries (reads) retrieve data from optimized read models.\n\n**Why Use CQRS?**\n\n- **Optimized Performance**: Write model normalized for consistency, read model denormalized for speed\n- **Scalability**: Scale reads and writes independently\n- **Flexibility**: Different databases for reads vs writes (polyglot persistence)\n- **Complex Domains**: Clearer separation of concerns\n\n**How CQRS Works:**\n\n1. **Command Side (Write)**: Handles create/update/delete operations\n2. **Event Publishing**: Commands publish events when data changes\n3. **Read Model Sync**: Event handlers update optimized read models\n4. **Query Side (Read)**: Serves read requests from denormalized data\n\n**When to Use CQRS:**\n- High read/write ratio (different scaling needs)\n- Complex business logic\n- Need for multiple read models (different views of same data)\n- Event-driven architectures\n\n**CQRS vs Traditional:**\n\n| Aspect | Traditional | CQRS |\n|--------|------------|------|\n| Model | Single unified model | Separate read/write models |\n| Database | One database | Can use different DBs |\n| Complexity | Simple | More complex |\n| Performance | Good for simple | Optimized for each operation |\n| Scaling | Uniform | Independent scaling |\n\n**Challenges:**\n- Increased complexity\n- Eventual consistency between read/write models\n- Event synchronization overhead\n- Not needed for simple CRUD apps\n\nSeparate read and write operations.\n\n```\nWrite Side (Commands)          Read Side (Queries)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Write Model â”‚â”€â”€â”€â”€â”€Eventsâ”€â”€â”€â–¶â”‚  Read Model  â”‚\nâ”‚  (Normalized)â”‚              â”‚  (Optimized) â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n     PostgreSQL                   MongoDB\n```\n\n```javascript\n// Command Side (Write)\nclass CreateOrderCommand {\n  async execute(orderData) {\n    const order = await Order.create(orderData)\n    \n    // Publish event\n    await publishEvent({\n      type: 'ORDER_CREATED',\n      data: order\n    })\n    \n    return order\n  }\n}\n\n// Query Side (Read)\nclass OrderQueryService {\n  async getOrderById(orderId) {\n    // Optimized read model\n    return await OrderReadModel.findById(orderId)\n  }\n  \n  async getOrdersByUser(userId) {\n    // Denormalized for fast reads\n    return await OrderReadModel.find({ userId })\n  }\n}\n\n// Event Handler (Sync read model)\nasync function handleOrderCreated(event) {\n  const { data } = event\n  \n  // Update read model\n  await OrderReadModel.create({\n    id: data.id,\n    userId: data.userId,\n    userName: data.userName, // Denormalized\n    items: data.items,\n    totalAmount: data.totalAmount\n  })\n}\n```\n\n---\n\n## ğŸ” Authentication & Authorization {#auth}\n\n### JWT-Based Authentication\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Client  â”‚â”€â”€â”€ 1. Login â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Auth Serviceâ”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜\n     â”‚                                       â”‚\n     â”‚â—€â”€â”€â”€â”€ 2. JWT Token â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n     â”‚\n     â”‚â”€â”€ 3. Request + JWT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n     â”‚                                       â”‚ API Gateway  â”‚\n     â”‚                                       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜\n     â”‚                                              â”‚\n     â”‚                                    4. Verify Token\n     â”‚                                              â”‚\n     â”‚â—€â”€â”€â”€â”€ 5. Response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\n                                                  â”‚ â”‚\n                                            â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”\n                                            â”‚User Serviceâ”‚\n                                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Auth Service**\n\n```javascript\n// auth-service/server.js\nconst express = require('express')\nconst jwt = require('jsonwebtoken')\nconst bcrypt = require('bcryptjs')\n\nconst app = express()\napp.use(express.json())\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'\n\n// Login endpoint\napp.post('/api/auth/login', async (req, res) => {\n  const { email, password } = req.body\n  \n  // Find user (from database)\n  const user = await User.findOne({ email })\n  \n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' })\n  }\n  \n  // Verify password\n  const isValid = await bcrypt.compare(password, user.password)\n  \n  if (!isValid) {\n    return res.status(401).json({ error: 'Invalid credentials' })\n  }\n  \n  // Generate JWT token\n  const token = jwt.sign(\n    {\n      userId: user.id,\n      email: user.email,\n      role: user.role\n    },\n    JWT_SECRET,\n    { expiresIn: '7d' }\n  )\n  \n  res.json({\n    success: true,\n    token,\n    user: {\n      id: user.id,\n      email: user.email,\n      name: user.name\n    }\n  })\n})\n\n// Verify token endpoint (used by API Gateway)\napp.post('/api/auth/verify', (req, res) => {\n  const { token } = req.body\n  \n  try {\n    const decoded = jwt.verify(token, JWT_SECRET)\n    res.json({ success: true, user: decoded })\n  } catch (error) {\n    res.status(401).json({ success: false, error: 'Invalid token' })\n  }\n})\n\napp.listen(3005, () => console.log('Auth service on port 3005'))\n```\n\n**API Gateway - Auth Middleware**\n\n```javascript\n// Verify JWT in API Gateway\nconst verifyToken = async (req, res, next) => {\n  const token = req.headers.authorization?.replace('Bearer ', '')\n  \n  if (!token) {\n    return res.status(401).json({ error: 'No token provided' })\n  }\n  \n  try {\n    // Verify with Auth Service\n    const response = await fetch('http://auth-service:3005/api/auth/verify', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ token })\n    })\n    \n    const result = await response.json()\n    \n    if (!result.success) {\n      return res.status(401).json({ error: 'Invalid token' })\n    }\n    \n    // Attach user to request\n    req.user = result.user\n    next()\n    \n  } catch (error) {\n    res.status(500).json({ error: 'Authentication failed' })\n  }\n}\n\n// Protect routes\napp.use('/api/orders', verifyToken, orderProxy)\napp.use('/api/profile', verifyToken, userProxy)\n```\n\n---\n\n## ğŸ“Š Observability & Monitoring {#monitoring}\n\n### The Three Pillars\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. Logging                             â”‚\nâ”‚  - Application logs                     â”‚\nâ”‚  - Error logs                           â”‚\nâ”‚  - Access logs                          â”‚\nâ”‚  Tool: ELK Stack, CloudWatch            â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  2. Metrics                             â”‚\nâ”‚  - Request rate                         â”‚\nâ”‚  - Error rate                           â”‚\nâ”‚  - Latency                              â”‚\nâ”‚  - Resource usage                       â”‚\nâ”‚  Tool: Prometheus, Grafana              â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  3. Tracing                             â”‚\nâ”‚  - Request flow across services         â”‚\nâ”‚  - Performance bottlenecks              â”‚\nâ”‚  - Dependency mapping                   â”‚\nâ”‚  Tool: Jaeger, Zipkin                   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Structured Logging\n\n```javascript\nconst winston = require('winston')\n\nconst logger = winston.createLogger({\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: 'app.log' })\n  ]\n})\n\n// Log with context\nlogger.info('Order created', {\n  orderId: order.id,\n  userId: user.id,\n  amount: order.totalAmount,\n  service: 'order-service'\n})\n\n// Log errors\nlogger.error('Payment failed', {\n  orderId: order.id,\n  error: error.message,\n  stack: error.stack\n})\n```\n\n### Distributed Tracing\n\n```javascript\n// Using OpenTelemetry\nconst { trace } = require('@opentelemetry/api')\nconst tracer = trace.getTracer('order-service')\n\nasync function createOrder(userId, items) {\n  // Start span\n  const span = tracer.startSpan('createOrder')\n  \n  try {\n    span.setAttribute('userId', userId)\n    span.setAttribute('itemCount', items.length)\n    \n    // Create order\n    const order = await Order.create({ userId, items })\n    \n    // Child span for external call\n    const paymentSpan = tracer.startSpan('processPayment', { parent: span })\n    await processPayment(order.id, order.totalAmount)\n    paymentSpan.end()\n    \n    span.setStatus({ code: 0 }) // Success\n    return order\n    \n  } catch (error) {\n    span.setStatus({ code: 2, message: error.message }) // Error\n    throw error\n  } finally {\n    span.end()\n  }\n}\n```\n\n### Health Checks\n\n```javascript\n// Health check endpoint\napp.get('/health', async (req, res) => {\n  const health = {\n    status: 'UP',\n    timestamp: new Date().toISOString(),\n    service: 'order-service',\n    checks: {}\n  }\n  \n  // Check database\n  try {\n    await db.ping()\n    health.checks.database = { status: 'UP' }\n  } catch (error) {\n    health.checks.database = { status: 'DOWN', error: error.message }\n    health.status = 'DOWN'\n  }\n  \n  // Check external service\n  try {\n    await fetch('http://payment-service/health')\n    health.checks.paymentService = { status: 'UP' }\n  } catch (error) {\n    health.checks.paymentService = { status: 'DOWN' }\n  }\n  \n  const statusCode = health.status === 'UP' ? 200 : 503\n  res.status(statusCode).json(health)\n})\n```\n\n---\n\n## ğŸ›¡ï¸ Resilience Patterns {#resilience}\n\n### 1. Circuit Breaker\n\n**What is Circuit Breaker?**\n\nCircuit Breaker is a resilience pattern that prevents your application from repeatedly trying to execute an operation that's likely to fail. It acts like an electrical circuit breaker, stopping the flow when things go wrong.\n\n**Why Use Circuit Breaker?**\n\n- **Prevent Cascading Failures**: Stop failures from spreading across services\n- **Fast Failures**: Return errors immediately instead of waiting for timeouts\n- **System Recovery**: Give failing services time to recover\n- **Resource Protection**: Prevent thread exhaustion from hanging calls\n\n**How Circuit Breaker Works:**\n\n**Three States:**\n\n1. **CLOSED** (Normal): Requests pass through, failures counted\n2. **OPEN** (Failed): Requests immediately rejected, no calls to service\n3. **HALF-OPEN** (Testing): After timeout, allow few test requests\n\n**State Transitions:**\n```\nCLOSED â†’ (threshold failures) â†’ OPEN\nOPEN â†’ (timeout expires) â†’ HALF-OPEN\nHALF-OPEN â†’ (success) â†’ CLOSED\nHALF-OPEN â†’ (failure) â†’ OPEN\n```\n\n**When to Use:**\n- Calling external APIs or services\n- Database connections\n- Network operations\n- Any remote call that can fail or timeout\n\n**Benefits:**\n- Improves system resilience\n- Better user experience (fast failures vs timeouts)\n- Allows graceful degradation\n- Monitors service health\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Circuit Breaker States              â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  CLOSED â”€â”€â”€â”€â”€â–¶ Requests pass through â”‚\nâ”‚    â”‚                                 â”‚\nâ”‚    â–¼ (Too many failures)            â”‚\nâ”‚  OPEN â”€â”€â”€â”€â”€â”€â”€â–¶ Requests rejected     â”‚\nâ”‚    â”‚                                 â”‚\nâ”‚    â–¼ (After timeout)                â”‚\nâ”‚  HALF-OPEN â”€â”€â–¶ Test with few requestsâ”‚\nâ”‚    â”‚         â”‚                       â”‚\nâ”‚    â”‚         â””â”€â–¶ Success â†’ CLOSED   â”‚\nâ”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Failure â†’ OPEN     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n```javascript\nconst CircuitBreaker = require('opossum')\n\n// Circuit breaker configuration\nconst options = {\n  timeout: 3000,           // Call timeout\n  errorThresholdPercentage: 50, // Open circuit at 50% errors\n  resetTimeout: 10000      // Try again after 10 seconds\n}\n\n// Wrap function with circuit breaker\nconst callPaymentService = async (amount) => {\n  const response = await fetch('http://payment-service/api/charge', {\n    method: 'POST',\n    body: JSON.stringify({ amount })\n  })\n  return response.json()\n}\n\nconst breaker = new CircuitBreaker(callPaymentService, options)\n\n// Handle circuit open\nbreaker.on('open', () => {\n  console.log('Circuit breaker opened - payment service is down')\n})\n\n// Handle success after half-open\nbreaker.on('close', () => {\n  console.log('Circuit breaker closed - payment service recovered')\n})\n\n// Use circuit breaker\ntry {\n  const result = await breaker.fire(100)\n} catch (error) {\n  // Fallback logic\n  console.log('Payment service unavailable, using fallback')\n}\n```\n\n### 2. Retry Pattern\n\n```javascript\nconst retry = require('async-retry')\n\nasync function callServiceWithRetry() {\n  return await retry(\n    async () => {\n      const response = await fetch('http://user-service/api/users/123')\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`)\n      }\n      \n      return response.json()\n    },\n    {\n      retries: 3,\n      minTimeout: 1000,\n      maxTimeout: 5000,\n      factor: 2 // Exponential backoff\n    }\n  )\n}\n```\n\n### 3. Timeout Pattern\n\n```javascript\nasync function callWithTimeout(url, timeoutMs = 5000) {\n  const controller = new AbortController()\n  const timeout = setTimeout(() => controller.abort(), timeoutMs)\n  \n  try {\n    const response = await fetch(url, { signal: controller.signal })\n    return response.json()\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      throw new Error('Request timeout')\n    }\n    throw error\n  } finally {\n    clearTimeout(timeout)\n  }\n}\n```\n\n### 4. Bulkhead Pattern\n\nIsolate resources to prevent total system failure.\n\n```javascript\nconst { Pool } = require('pg')\n\n// Separate connection pools for different operations\nconst criticalPool = new Pool({\n  max: 10,  // 10 connections for critical operations\n  // ... other config\n})\n\nconst nonCriticalPool = new Pool({\n  max: 5,   // 5 connections for non-critical operations\n  // ... other config\n})\n\n// Critical operation uses dedicated pool\nasync function getCriticalData() {\n  const client = await criticalPool.connect()\n  try {\n    return await client.query('SELECT * FROM critical_data')\n  } finally {\n    client.release()\n  }\n}\n```\n\n---\n\n## ğŸ³ Containers & Orchestration {#containers}\n\n### Docker for Microservices\n\n**Dockerfile (User Service)**\n\n```dockerfile\nFROM node:18-alpine\n\nWORKDIR /app\n\n# Install dependencies\nCOPY package*.json ./\nRUN npm install --production\n\n# Copy source code\nCOPY . .\n\n# Expose port\nEXPOSE 3001\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s \\\n  CMD node healthcheck.js\n\n# Start service\nCMD [\"node\", \"server.js\"]\n```\n\n### Docker Compose (Local Development)\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  # API Gateway\n  api-gateway:\n    build: ./api-gateway\n    ports:\n      - \"3000:3000\"\n    environment:\n      - USER_SERVICE_URL=http://user-service:3001\n      - PRODUCT_SERVICE_URL=http://product-service:3002\n      - ORDER_SERVICE_URL=http://order-service:3003\n    depends_on:\n      - user-service\n      - product-service\n      - order-service\n  \n  # User Service\n  user-service:\n    build: ./user-service\n    environment:\n      - MONGODB_URI=mongodb://mongo:27017/users\n      - JWT_SECRET=secret\n    depends_on:\n      - mongo\n  \n  # Product Service\n  product-service:\n    build: ./product-service\n    environment:\n      - MONGODB_URI=mongodb://mongo:27017/products\n  \n  # Order Service\n  order-service:\n    build: ./order-service\n    environment:\n      - MONGODB_URI=mongodb://mongo:27017/orders\n      - RABBITMQ_URL=amqp://rabbitmq:5672\n    depends_on:\n      - mongo\n      - rabbitmq\n  \n  # MongoDB\n  mongo:\n    image: mongo:latest\n    volumes:\n      - mongo-data:/data/db\n  \n  # RabbitMQ\n  rabbitmq:\n    image: rabbitmq:3-management\n    ports:\n      - \"15672:15672\" # Management UI\n    environment:\n      - RABBITMQ_DEFAULT_USER=admin\n      - RABBITMQ_DEFAULT_PASS=admin\n\nvolumes:\n  mongo-data:\n```\n\n### Kubernetes Deployment\n\n```yaml\n# user-service-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: user-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: user-service\n  template:\n    metadata:\n      labels:\n        app: user-service\n    spec:\n      containers:\n      - name: user-service\n        image: your-registry/user-service:latest\n        ports:\n        - containerPort: 3001\n        env:\n        - name: MONGODB_URI\n          valueFrom:\n            secretKeyRef:\n              name: db-secret\n              key: mongodb-uri\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3001\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 3001\n          initialDelaySeconds: 10\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: user-service\nspec:\n  selector:\n    app: user-service\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 3001\n  type: ClusterIP\n```\n\n---\n\n## ğŸ”„ CI/CD for Microservices {#cicd}\n\n### GitHub Actions Pipeline\n\n```yaml\n# .github/workflows/user-service.yml\nname: User Service CI/CD\n\non:\n  push:\n    branches: [ main ]\n    paths:\n      - 'user-service/**'\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      \n      - name: Install dependencies\n        run: |\n          cd user-service\n          npm install\n      \n      - name: Run tests\n        run: |\n          cd user-service\n          npm test\n      \n      - name: Run linting\n        run: |\n          cd user-service\n          npm run lint\n  \n  build:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Build Docker image\n        run: |\n          cd user-service\n          docker build -t ${{ secrets.DOCKER_REGISTRY }}/user-service:${{ github.sha }} .\n      \n      - name: Push to registry\n        run: |\n          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin\n          docker push ${{ secrets.DOCKER_REGISTRY }}/user-service:${{ github.sha }}\n  \n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to Kubernetes\n        run: |\n          kubectl set image deployment/user-service \\\n            user-service=${{ secrets.DOCKER_REGISTRY }}/user-service:${{ github.sha }}\n```\n\n---\n\n## ğŸ§ª Testing Strategies {#testing}\n\n### 1. Unit Tests (Service Level)\n\n```javascript\n// user-service/tests/user.test.js\nconst User = require('../models/User')\nconst { createUser, getUser } = require('../controllers/userController')\n\ndescribe('User Service', () => {\n  describe('createUser', () => {\n    it('should create a new user', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123'\n      }\n      \n      const user = await createUser(userData)\n      \n      expect(user.name).toBe('John Doe')\n      expect(user.email).toBe('john@example.com')\n      expect(user.password).not.toBe('password123') // Should be hashed\n    })\n    \n    it('should reject duplicate email', async () => {\n      await createUser({\n        name: 'John',\n        email: 'john@example.com',\n        password: 'pass'\n      })\n      \n      await expect(createUser({\n        name: 'Jane',\n        email: 'john@example.com',\n        password: 'pass'\n      })).rejects.toThrow('Email already exists')\n    })\n  })\n})\n```\n\n### 2. Integration Tests\n\n```javascript\n// order-service/tests/integration.test.js\nconst request = require('supertest')\nconst app = require('../app')\n\ndescribe('Order API Integration', () => {\n  it('should create order with valid user', async () => {\n    const res = await request(app)\n      .post('/api/orders')\n      .set('Authorization', 'Bearer valid-token')\n      .send({\n        items: [\n          { productId: '123', quantity: 2 }\n        ]\n      })\n    \n    expect(res.status).toBe(201)\n    expect(res.body.success).toBe(true)\n    expect(res.body.data.status).toBe('PENDING')\n  })\n})\n```\n\n### 3. Contract Tests (Pact)\n\n```javascript\n// Consumer test (Order Service)\nconst { Pact } = require('@pact-foundation/pact')\n\nconst provider = new Pact({\n  consumer: 'OrderService',\n  provider: 'UserService'\n})\n\ndescribe('User Service Contract', () => {\n  beforeAll(() => provider.setup())\n  afterAll(() => provider.finalize())\n  \n  it('should get user by ID', async () => {\n    await provider.addInteraction({\n      state: 'user 123 exists',\n      uponReceiving: 'a request for user 123',\n      withRequest: {\n        method: 'GET',\n        path: '/api/users/123'\n      },\n      willRespondWith: {\n        status: 200,\n        body: {\n          id: '123',\n          name: 'John Doe',\n          email: 'john@example.com'\n        }\n      }\n    })\n    \n    // Test implementation\n    const user = await getUserFromService('123')\n    expect(user.id).toBe('123')\n  })\n})\n```\n\n### 4. End-to-End Tests\n\n```javascript\n// e2e/order-flow.test.js\ndescribe('Complete Order Flow', () => {\n  it('should complete order from creation to delivery', async () => {\n    // 1. Login\n    const loginRes = await request(apiGateway)\n      .post('/api/auth/login')\n      .send({ email: 'test@example.com', password: 'password' })\n    \n    const token = loginRes.body.token\n    \n    // 2. Create order\n    const orderRes = await request(apiGateway)\n      .post('/api/orders')\n      .set('Authorization', `Bearer ${token}`)\n      .send({ items: [{ productId: '123', quantity: 1 }] })\n    \n    expect(orderRes.status).toBe(201)\n    const orderId = orderRes.body.data.id\n    \n    // 3. Process payment\n    const paymentRes = await request(apiGateway)\n      .post(`/api/orders/${orderId}/pay`)\n      .set('Authorization', `Bearer ${token}`)\n    \n    expect(paymentRes.status).toBe(200)\n    \n    // 4. Check order status\n    const statusRes = await request(apiGateway)\n      .get(`/api/orders/${orderId}`)\n      .set('Authorization', `Bearer ${token}`)\n    \n    expect(statusRes.body.data.status).toBe('PAID')\n  })\n})\n```\n\n---\n\n## âœ… Best Practices {#best-practices}\n\n### 1. Start Small\n\n```\nâŒ Don't: Build 20 microservices from day one\nâœ… Do: Start with monolith, extract services gradually\n```\n\n### 2. Define Service Boundaries\n\n```\nâœ… Good Boundaries (by Business Capability)\n- User Management\n- Product Catalog\n- Order Processing\n- Payment\n\nâŒ Bad Boundaries (by Technical Layer)\n- Database Service\n- Validation Service\n- Email Service\n```\n\n### 3. API Versioning\n\n```javascript\n// Version in URL\napp.use('/api/v1/users', usersRouterV1)\napp.use('/api/v2/users', usersRouterV2)\n\n// Version in header\napp.use('/api/users', (req, res, next) => {\n  const version = req.headers['api-version'] || 'v1'\n  if (version === 'v2') {\n    return usersRouterV2(req, res, next)\n  }\n  return usersRouterV1(req, res, next)\n})\n```\n\n### 4. Graceful Shutdown\n\n```javascript\nconst server = app.listen(3001)\n\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, closing server...')\n  \n  server.close(() => {\n    console.log('Server closed')\n    \n    // Close database connections\n    mongoose.connection.close(false, () => {\n      console.log('MongoDB connection closed')\n      process.exit(0)\n    })\n  })\n})\n```\n\n### 5. Configuration Management\n\n```javascript\n// Use environment variables\nrequire('dotenv').config()\n\nconst config = {\n  port: process.env.PORT || 3001,\n  database: {\n    uri: process.env.MONGODB_URI,\n    options: {\n      useNewUrlParser: true,\n      useUnifiedTopology: true\n    }\n  },\n  services: {\n    userService: process.env.USER_SERVICE_URL,\n    paymentService: process.env.PAYMENT_SERVICE_URL\n  },\n  jwt: {\n    secret: process.env.JWT_SECRET,\n    expiresIn: '7d'\n  }\n}\n\nmodule.exports = config\n```\n\n---\n\n## ğŸ¯ Real-World Implementation {#projects}\n\n### Complete E-commerce Microservices\n\n```\nmicroservices/\nâ”œâ”€â”€ api-gateway/\nâ”‚   â”œâ”€â”€ Dockerfile\nâ”‚   â”œâ”€â”€ server.js\nâ”‚   â””â”€â”€ package.json\nâ”œâ”€â”€ auth-service/\nâ”‚   â”œâ”€â”€ Dockerfile\nâ”‚   â”œâ”€â”€ controllers/\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â””â”€â”€ server.js\nâ”œâ”€â”€ user-service/\nâ”‚   â”œâ”€â”€ Dockerfile\nâ”‚   â”œâ”€â”€ controllers/\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â””â”€â”€ server.js\nâ”œâ”€â”€ product-service/\nâ”‚   â”œâ”€â”€ Dockerfile\nâ”‚   â”œâ”€â”€ controllers/\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â””â”€â”€ server.js\nâ”œâ”€â”€ order-service/\nâ”‚   â”œâ”€â”€ Dockerfile\nâ”‚   â”œâ”€â”€ controllers/\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”œâ”€â”€ sagas/\nâ”‚   â””â”€â”€ server.js\nâ”œâ”€â”€ payment-service/\nâ”‚   â”œâ”€â”€ Dockerfile\nâ”‚   â”œâ”€â”€ controllers/\nâ”‚   â””â”€â”€ server.js\nâ”œâ”€â”€ notification-service/\nâ”‚   â”œâ”€â”€ Dockerfile\nâ”‚   â”œâ”€â”€ consumers/\nâ”‚   â””â”€â”€ server.js\nâ”œâ”€â”€ inventory-service/\nâ”‚   â”œâ”€â”€ Dockerfile\nâ”‚   â”œâ”€â”€ controllers/\nâ”‚   â””â”€â”€ server.js\nâ”œâ”€â”€ docker-compose.yml\nâ””â”€â”€ kubernetes/\n    â”œâ”€â”€ deployments/\n    â”œâ”€â”€ services/\n    â””â”€â”€ ingress.yaml\n```\n\n---\n\n## ğŸ•¸ï¸ Service Mesh {#servicemesh}\n\n**What is a Service Mesh?**\n\nA service mesh is an infrastructure layer that handles service-to-service communication, providing features like traffic management, security, and observability without changing application code.\n\n**Why Use Service Mesh?**\n\n- **Traffic Control**: Advanced routing, load balancing, retries\n- **Security**: Mutual TLS (mTLS) for all service communication\n- **Observability**: Automatic metrics, logs, traces\n- **Policy Enforcement**: Rate limiting, access control\n- **No Code Changes**: Features added via sidecar proxies\n\n**How Service Mesh Works:**\n\nEach service gets a \"sidecar\" proxy (usually Envoy). All traffic goes through these proxies, which enforce policies and collect metrics.\n\n```\nService A â”€â”€â–¶ Sidecar Proxy â”€â”€â–¶ Network â”€â”€â–¶ Sidecar Proxy â”€â”€â–¶ Service B\n              (Envoy)                         (Envoy)\n```\n\n**Service Mesh Architecture:**\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚        Control Plane (Istio)            â”‚\nâ”‚  - Configuration                        â”‚\nâ”‚  - Service Discovery                    â”‚\nâ”‚  - Certificate Management               â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n             â”‚\n    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”‚                 â”‚\nâ”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”\nâ”‚ Pod A  â”‚      â”‚  Pod B   â”‚\nâ”‚â”Œâ”€â”€â”€â”€â”€â”€â”â”‚      â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚\nâ”‚â”‚Serviceâ”‚â”‚      â”‚â”‚ Serviceâ”‚â”‚\nâ”‚â””â”€â”€â”€â”€â”€â”€â”˜â”‚      â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\nâ”‚â”Œâ”€â”€â”€â”€â”€â”€â”â”‚      â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚\nâ”‚â”‚ Envoyâ”‚â”‚â—€â”€â”€â”€â”€â–¶â”‚â”‚  Envoy â”‚â”‚\nâ”‚â””â”€â”€â”€â”€â”€â”€â”˜â”‚      â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nData Plane      Data Plane\n```\n\n**Popular Service Meshes:**\n\n| Service Mesh | Pros | Cons |\n|--------------|------|------|\n| **Istio** | Feature-rich, mature | Complex, heavy |\n| **Linkerd** | Lightweight, simple | Fewer features |\n| **Consul** | Multi-cloud, HashiCorp ecosystem | Learning curve |\n| **AWS App Mesh** | AWS-native | AWS only |\n\n**When to Use Service Mesh:**\n- Many microservices (10+)\n- Need advanced traffic management\n- Security requirements (mTLS)\n- Polyglot architecture (multiple languages)\n- Need observability without code changes\n\n**Istio Traffic Management**\n\n```yaml\n# Canary deployment with Istio\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: product-service\nspec:\n  hosts:\n  - product-service\n  http:\n  - route:\n    - destination:\n        host: product-service\n        subset: v1\n      weight: 90  # 90% to stable version\n    - destination:\n        host: product-service\n        subset: v2\n      weight: 10  # 10% to canary\n```\n\n**Service Mesh vs Library Approach:**\n\n| Feature | Service Mesh (Istio) | Library (Resilience4j) |\n|---------|----------------------|------------------------|\n| Implementation | Sidecar proxy | Application library |\n| Language | Any language | Language-specific |\n| Code Changes | None | Modify code |\n| Overhead | Higher (extra container) | Lower |\n| Features | Traffic, security, observability | Resilience patterns only |\n\n---\n\n## ğŸš€ Deployment Strategies {#deployment}\n\n**What are Deployment Strategies?**\n\nDeployment strategies are methods to release new versions of services while minimizing risk and downtime.\n\n### 1. Blue-Green Deployment\n\n**What it is:** Run two identical environments (Blue = current, Green = new). Switch traffic when ready.\n\n**Why use it:**\n- **Zero Downtime**: Instant cutover\n- **Easy Rollback**: Switch back to blue if issues\n- **Full Testing**: Test green in production environment\n\n**How it works:**\n\n```\nStep 1: Blue (v1) serves 100% traffic\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Blue   â”‚ â—€â”€â”€â”€â”€ 100% Traffic\nâ”‚  (v1)  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Green  â”‚       (Idle)\nâ”‚  (v2)  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nStep 2: Deploy to Green, test\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Blue   â”‚ â—€â”€â”€â”€â”€ 100% Traffic\nâ”‚  (v1)  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Green  â”‚       Testing\nâ”‚  (v2)  â”‚ â—€â”€â”€â”€â”€ Internal tests\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nStep 3: Switch traffic to Green\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Blue   â”‚       (Standby)\nâ”‚  (v1)  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Green  â”‚ â—€â”€â”€â”€â”€ 100% Traffic\nâ”‚  (v2)  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Kubernetes Blue-Green**\n\n```yaml\n# Service (switch by changing selector)\napiVersion: v1\nkind: Service\nmetadata:\n  name: product-service\nspec:\n  selector:\n    app: product-service\n    version: v1  # Change to v2 to switch\n  ports:\n  - port: 80\n    targetPort: 3000\n```\n\n### 2. Canary Deployment\n\n**What it is:** Gradually roll out to a small percentage of users, then increase if successful.\n\n**Why use it:**\n- **Risk Reduction**: Test with small user subset\n- **Performance Validation**: Monitor metrics on real traffic\n- **Easy Rollback**: Affect minimal users if issues\n- **A/B Testing**: Compare versions\n\n**How it works:**\n\n```\nStep 1: 95% v1, 5% v2 (Canary)\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   v1   â”‚ â—€â”€â”€â”€â”€ 95% Traffic\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   v2   â”‚ â—€â”€â”€â”€â”€ 5% Traffic (Canary)\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nStep 2: If healthy, 50% v1, 50% v2\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   v1   â”‚ â—€â”€â”€â”€â”€ 50% Traffic\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   v2   â”‚ â—€â”€â”€â”€â”€ 50% Traffic\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nStep 3: All traffic to v2\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   v2   â”‚ â—€â”€â”€â”€â”€ 100% Traffic\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Deployment Strategy Comparison:**\n\n| Strategy | Downtime | Risk | Complexity | Rollback Speed | Cost |\n|----------|----------|------|------------|----------------|------|\n| **Blue-Green** | None | Medium | Medium | Instant | High (2x resources) |\n| **Canary** | None | Low | High | Fast | Medium |\n| **Rolling** | None | Medium | Low | Slow | Low |\n\n**When to Use Each:**\n\n- **Blue-Green**: Critical services, need instant rollback\n- **Canary**: User-facing services, want gradual validation\n- **Rolling**: Internal services, cost-conscious\n\n---\n\n## ğŸ† Congratulations!\n\nYou've completed the Microservices Architecture guide! You now know:\n\n- âœ… Microservices patterns and principles\n- âœ… Service communication (sync & async)\n- âœ… API Gateway and service discovery\n- âœ… Data management strategies (Saga, Event Sourcing, CQRS)\n- âœ… Resilience patterns (Circuit Breaker, Retry, Timeout, Bulkhead)\n- âœ… Security (JWT, OAuth, mTLS)\n- âœ… Observability (Logging, Metrics, Tracing)\n- âœ… Service Mesh (Istio, traffic management, mTLS)\n- âœ… Deployment Strategies (Blue-Green, Canary, Rolling)\n- âœ… Container orchestration with Kubernetes\n- âœ… Testing microservices\n- âœ… Production best practices\n\n**Next Steps:**\n- Build a real microservices project (e-commerce, booking system)\n- Master Kubernetes and Helm charts\n- Study event-driven architecture in depth\n- Implement full observability stack (ELK + Prometheus + Jaeger)\n- Explore serverless microservices (AWS Lambda, Cloud Functions)\n\nHappy coding! ğŸš€\n\n"}