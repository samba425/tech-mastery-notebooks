{"id":"js-challenges","title":"üéØ JavaScript Challenges","content":"# üöÄ JavaScript Programming Challenges - Interview Mastery Edition\n\n**A comprehensive collection of JavaScript programming challenges designed to ace technical interviews and boost your career!**\n\n## üìö What You'll Master\n\nThis notebook covers the same interview-critical algorithms from the Python version, but implemented in JavaScript:\n\n### üéØ **Core Learning Objectives:**\n- **JavaScript ES6+ Features** - Modern syntax and best practices\n- **Algorithm Implementation** - Classic interview problems in JS\n- **Data Structures** - Arrays, Objects, Maps, Sets, Classes\n- **Functional Programming** - Higher-order functions, closures\n- **Asynchronous JavaScript** - Promises, async/await\n- **Performance Optimization** - Time/space complexity analysis\n- **Interview Techniques** - Problem-solving patterns\n\n### üèÜ **Career Impact:**\n- ‚úÖ **Frontend Developer Positions** - React, Vue, Angular interviews\n- ‚úÖ **Full-Stack Roles** - Node.js backend development\n- ‚úÖ **JavaScript Engineer** - Specialized JS positions\n- ‚úÖ **Technical Leadership** - Algorithm design and optimization\n- ‚úÖ **Startup Opportunities** - Versatile programming skills\n\n### üõ† **How to Use This Notebook:**\n1. **Run each cell individually** to see outputs and test results\n2. **Modify the code** to experiment with different approaches\n3. **Time yourself** solving each challenge\n4. **Practice explaining** your solutions out loud\n5. **Master the patterns** for interview success\n\n---\n\n**üî• Pro Tip: JavaScript interviews often focus on array methods, closures, and async programming. Master these concepts to stand out!**\n\n## Challenge 1: Hello World & Environment Setup\n\n**Problem:** Set up JavaScript environment and create a hello world function with multiple variations.\n\n**Learning Goals:**\n- JavaScript function syntax\n- Console output methods  \n- String interpolation\n- Modern ES6+ features\n\n```python\n// Solution for Challenge 1: Hello World & Environment Setup\n\n// Method 1: Basic function declaration\nfunction sayHello() {\n    return \"Hello, World!\";\n}\n\n// Method 2: Function expression\nconst sayHelloExpression = function() {\n    return \"Hello, World!\";\n};\n\n// Method 3: Arrow function (ES6+)\nconst sayHelloArrow = () => \"Hello, World!\";\n\n// Method 4: Parameterized hello function\nconst greetPerson = (name = \"World\") => `Hello, ${name}!`;\n\n// Method 5: Class-based approach\nclass Greeter {\n    constructor(greeting = \"Hello\") {\n        this.greeting = greeting;\n    }\n    \n    greet(name = \"World\") {\n        return `${this.greeting}, ${name}!`;\n    }\n}\n\n// Method 6: Higher-order function\nconst createGreeter = (greeting) => (name) => `${greeting}, ${name}!`;\n\n// Test all methods\nconsole.log(\"üöÄ JavaScript Hello World Challenge Results:\");\nconsole.log(\"=\".repeat(50));\n\nconsole.log(\"1. Function Declaration:\", sayHello());\nconsole.log(\"2. Function Expression:\", sayHelloExpression());\nconsole.log(\"3. Arrow Function:\", sayHelloArrow());\nconsole.log(\"4. Parameterized Function:\", greetPerson(\"JavaScript\"));\nconsole.log(\"5. Default Parameter:\", greetPerson());\n\n// Test class approach\nconst greeter = new Greeter();\nconsole.log(\"6. Class Method:\", greeter.greet(\"Developer\"));\n\nconst customGreeter = new Greeter(\"Welcome\");\nconsole.log(\"7. Custom Greeting:\", customGreeter.greet(\"Coder\"));\n\n// Test higher-order function\nconst sayHi = createGreeter(\"Hi\");\nconst sayWelcome = createGreeter(\"Welcome\");\nconsole.log(\"8. Higher-order Function (Hi):\", sayHi(\"Friend\"));\nconsole.log(\"9. Higher-order Function (Welcome):\", sayWelcome(\"Team\"));\n\n// Demonstrate modern JavaScript features\nconst features = {\n    templateLiterals: `Template literals with ${2 + 3} = 5`,\n    destructuring: (() => {\n        const [first, ...rest] = [1, 2, 3, 4, 5];\n        return `First: ${first}, Rest: [${rest.join(', ')}]`;\n    })(),\n    spread: (() => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [4, 5, 6];\n        return `Spread: [${[...arr1, ...arr2].join(', ')}]`;\n    })()\n};\n\nconsole.log(\"\\nüî• Modern JavaScript Features:\");\nconsole.log(\"=\".repeat(50));\nObject.entries(features).forEach(([key, value]) => {\n    console.log(`${key}: ${value}`);\n});\n\n// Environment check\nconsole.log(\"\\nüíª Environment Information:\");\nconsole.log(\"=\".repeat(50));\nconsole.log(\"JavaScript Engine: Node.js\");\nconsole.log(\"ES6+ Support: ‚úÖ Enabled\");\nconsole.log(\"Console Output: ‚úÖ Working\");\nconsole.log(\"Ready for Interview Challenges! üéØ\");\n```\n\n## Challenge 2: Two Sum ‚≠ê‚≠ê‚≠ê\n\n**‚ö° Interview Frequency: EXTREMELY HIGH** | **Companies: ALL major tech companies**\n\n**Problem:** Given an array of integers and a target sum, return indices of two numbers that add up to target.\n\n**Example:**\n```javascript\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1] // Because nums[0] + nums[1] = 2 + 7 = 9\n```\n\n**Career Impact:** This is THE most famous algorithm interview question. Master this to demonstrate hash map proficiency!\n\n```python\n// Solution for Challenge 2: Two Sum - INTERVIEW GOLD!\n\n// Method 1: Hash Map approach (OPTIMAL - O(n) time)\nfunction twoSum(nums, target) {\n    /**\n     * Find two numbers that add up to target using hash map.\n     * This is THE solution interviewers want to see!\n     * Time: O(n), Space: O(n)\n     */\n    const numMap = new Map();\n    \n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        \n        if (numMap.has(complement)) {\n            return [numMap.get(complement), i];\n        }\n        \n        numMap.set(nums[i], i);\n    }\n    \n    return []; // No solution found\n}\n\n// Method 2: Hash Map with object (alternative)\nfunction twoSumObject(nums, target) {\n    const numObj = {};\n    \n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        \n        if (complement in numObj) {\n            return [numObj[complement], i];\n        }\n        \n        numObj[nums[i]] = i;\n    }\n    \n    return [];\n}\n\n// Method 3: Brute force approach (for comparison)\nfunction twoSumBruteForce(nums, target) {\n    /**\n     * Brute force O(n¬≤) approach - mention this but don't use it!\n     */\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] === target) {\n                return [i, j];\n            }\n        }\n    }\n    \n    return [];\n}\n\n// Method 4: Using Array methods (functional approach)\nfunction twoSumFunctional(nums, target) {\n    const result = [];\n    \n    nums.find((num, i) => {\n        const complement = target - num;\n        const complementIndex = nums.indexOf(complement, i + 1);\n        \n        if (complementIndex !== -1) {\n            result.push(i, complementIndex);\n            return true;\n        }\n        return false;\n    });\n    \n    return result;\n}\n\n// Method 5: ES6 destructuring approach\nfunction twoSumES6(nums, target) {\n    const map = new Map();\n    \n    for (const [index, num] of nums.entries()) {\n        const complement = target - num;\n        \n        if (map.has(complement)) {\n            return [map.get(complement), index];\n        }\n        \n        map.set(num, index);\n    }\n    \n    return [];\n}\n\n// Method 6: Recursive approach (educational)\nfunction twoSumRecursive(nums, target, index = 0, map = new Map()) {\n    if (index >= nums.length) return [];\n    \n    const complement = target - nums[index];\n    \n    if (map.has(complement)) {\n        return [map.get(complement), index];\n    }\n    \n    map.set(nums[index], index);\n    return twoSumRecursive(nums, target, index + 1, map);\n}\n\n// üéØ COMPREHENSIVE TEST CASES\nconsole.log(\"üéØ TWO SUM - THE LEGENDARY INTERVIEW PROBLEM!\");\nconsole.log(\"=\".repeat(60));\n\nconst testCases = [\n    // Basic cases\n    { nums: [2, 7, 11, 15], target: 9, expected: [0, 1], description: \"Classic example\" },\n    { nums: [3, 2, 4], target: 6, expected: [1, 2], description: \"Target at end\" },\n    { nums: [3, 3], target: 6, expected: [0, 1], description: \"Duplicate numbers\" },\n    \n    // Edge cases\n    { nums: [1, 2], target: 3, expected: [0, 1], description: \"Minimum input\" },\n    { nums: [1, 2, 3, 4, 5], target: 9, expected: [3, 4], description: \"Target at end\" },\n    \n    // Tricky cases\n    { nums: [0, 4, 3, 0], target: 0, expected: [0, 3], description: \"Zero values\" },\n    { nums: [-1, -2, -3, -4, -5], target: -8, expected: [2, 4], description: \"Negative numbers\" },\n    { nums: [1, 5, 3, 7, 9], target: 12, expected: [1, 3], description: \"Multiple possibilities\" }\n];\n\nconst methods = [\n    { name: \"Hash Map (Primary)\", func: twoSum },\n    { name: \"Object-based\", func: twoSumObject },\n    { name: \"ES6 Destructuring\", func: twoSumES6 },\n    { name: \"Brute Force\", func: twoSumBruteForce },\n    { name: \"Functional\", func: twoSumFunctional },\n    { name: \"Recursive\", func: twoSumRecursive }\n];\n\ntestCases.forEach((test, i) => {\n    console.log(`\\nüìù Test ${i + 1}: ${test.description}`);\n    console.log(`Input: nums = [${test.nums.join(', ')}], target = ${test.target}`);\n    console.log(`Expected: [${test.expected.join(', ')}]`);\n    \n    let allCorrect = true;\n    \n    methods.forEach(({ name, func }) => {\n        try {\n            const result = func([...test.nums], test.target);\n            const isCorrect = JSON.stringify(result.sort()) === JSON.stringify(test.expected.sort());\n            \n            if (!isCorrect) allCorrect = false;\n            \n            console.log(`  ${name}: [${result.join(', ')}] ${isCorrect ? '‚úÖ' : '‚ùå'}`);\n        } catch (error) {\n            console.log(`  ${name}: Error - ${error.message} ‚ùå`);\n            allCorrect = false;\n        }\n    });\n    \n    console.log(`‚úÖ All methods correct: ${allCorrect}`);\n});\n\n// üéØ INTERVIEW WALKTHROUGH\nconsole.log(`\\nüéØ STEP-BY-STEP WALKTHROUGH:`);\nconsole.log(\"Input: [2, 7, 11, 15], target = 9\");\nconsole.log(\"1. i=0, num=2, complement=7, map={} ‚Üí Add 2:0 to map\");\nconsole.log(\"2. i=1, num=7, complement=2, map={2:0} ‚Üí Found! Return [0,1]\");\nconsole.log(\"Result: [0, 1] ‚úÖ\");\n\n// üíº CAREER SUCCESS METRICS\nconsole.log(`\\nüíº CAREER IMPACT OF MASTERING TWO SUM:`);\nconsole.log(\"üèÜ Asked in 99% of algorithm interviews\");\nconsole.log(\"üèÜ Tests hash map/object understanding\");\nconsole.log(\"üèÜ Gateway to advanced array problems\");\nconsole.log(\"üèÜ Demonstrates optimization thinking\");\nconsole.log(\"üèÜ Foundation for multiple variations\");\n\n// üöÄ JAVASCRIPT-SPECIFIC TIPS\nconsole.log(`\\nüöÄ JAVASCRIPT INTERVIEW TIPS:`);\nconsole.log(\"1. ‚ö° Use Map() for better performance than objects\");\nconsole.log(\"2. ‚ö° Know the difference: Map vs Object vs Set\");\nconsole.log(\"3. ‚ö° Understand array destructuring: [a, b] = array\");\nconsole.log(\"4. ‚ö° Use const/let appropriately (never var)\");\nconsole.log(\"5. ‚ö° Mention time/space complexity clearly\");\n\nconsole.log(\"\\n\" + \"=\".repeat(60));\nconsole.log(\"‚≠ê MASTERY GOAL: Solve in < 3 minutes with perfect explanation\");\nconsole.log(\"‚≠ê Know Map vs Object performance differences\");\nconsole.log(\"‚≠ê Be ready for follow-ups: Three Sum, Four Sum, etc.\");\nconsole.log(\"=\".repeat(60));\n```\n\n## Challenge 3: Valid Parentheses ‚≠ê‚≠ê‚≠ê\n\n**‚ö° Interview Frequency: EXTREMELY HIGH** | **Companies: ALL major tech companies**\n\n**Problem:** Given a string containing just parentheses '(', ')', '{', '}', '[' and ']', determine if input is valid.\n\n**Example:**\n```javascript\nInput: \"({[]})\"\nOutput: true\n\nInput: \"({[}])\" \nOutput: false\n```\n\n**Career Impact:** The #1 stack problem. Master this to show data structure expertise!\n\n```python\n// Solution for Challenge 3: Valid Parentheses - STACK MASTERY!\n\n// Method 1: Classic stack approach (STANDARD SOLUTION)\nfunction isValidParentheses(s) {\n    /**\n     * Check if parentheses are valid using stack.\n     * This is THE solution every JavaScript developer must know!\n     * Time: O(n), Space: O(n)\n     */\n    // Edge case: odd length can't be valid\n    if (s.length % 2 !== 0) return false;\n    \n    // Mapping of closing to opening brackets\n    const bracketMap = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n    \n    const stack = [];\n    \n    for (const char of s) {\n        if (char in bracketMap) {\n            // Closing bracket\n            if (stack.length === 0 || stack.pop() !== bracketMap[char]) {\n                return false;\n            }\n        } else {\n            // Opening bracket\n            stack.push(char);\n        }\n    }\n    \n    // Valid if stack is empty\n    return stack.length === 0;\n}\n\n// Method 2: Using Set for opening brackets\nfunction isValidSet(s) {\n    if (s.length % 2 !== 0) return false;\n    \n    const opening = new Set(['(', '{', '[']);\n    const pairs = { ')': '(', '}': '{', ']': '[' };\n    const stack = [];\n    \n    for (const char of s) {\n        if (opening.has(char)) {\n            stack.push(char);\n        } else if (char in pairs) {\n            if (stack.length === 0 || stack.pop() !== pairs[char]) {\n                return false;\n            }\n        }\n    }\n    \n    return stack.length === 0;\n}\n\n// Method 3: Array methods approach\nfunction isValidArrayMethods(s) {\n    const pairs = { '(': ')', '{': '}', '[': ']' };\n    const opening = Object.keys(pairs);\n    const stack = [];\n    \n    return [...s].every(char => {\n        if (opening.includes(char)) {\n            stack.push(char);\n            return true;\n        } else {\n            const last = stack.pop();\n            return last && pairs[last] === char;\n        }\n    }) && stack.length === 0;\n}\n\n// Method 4: Replace approach (inefficient but educational)\nfunction isValidReplace(s) {\n    /**\n     * Replace pairs until no more pairs exist - O(n¬≤) but intuitive.\n     * Good for explaining the concept!\n     */\n    while (s.includes('()') || s.includes('{}') || s.includes('[]')) {\n        s = s.replace(/\\(\\)|\\{\\}|\\[\\]/g, '');\n    }\n    return s === '';\n}\n\n// Method 5: Recursive approach\nfunction isValidRecursive(s, stack = []) {\n    if (s.length === 0) return stack.length === 0;\n    \n    const char = s[0];\n    const rest = s.slice(1);\n    const pairs = { ')': '(', '}': '{', ']': '[' };\n    \n    if (['(', '{', '['].includes(char)) {\n        return isValidRecursive(rest, [...stack, char]);\n    } else if (char in pairs) {\n        if (stack.length === 0 || stack[stack.length - 1] !== pairs[char]) {\n            return false;\n        }\n        return isValidRecursive(rest, stack.slice(0, -1));\n    }\n    \n    return false;\n}\n\n// Method 6: Counter approach (works only for simple nesting)\nfunction isValidCounter(s) {\n    let round = 0, curly = 0, square = 0;\n    \n    for (const char of s) {\n        switch (char) {\n            case '(': round++; break;\n            case ')': round--; if (round < 0) return false; break;\n            case '{': curly++; break;\n            case '}': curly--; if (curly < 0) return false; break;\n            case '[': square++; break;\n            case ']': square--; if (square < 0) return false; break;\n        }\n    }\n    \n    return round === 0 && curly === 0 && square === 0;\n}\n\n// üéØ COMPREHENSIVE INTERVIEW TEST CASES\nconsole.log(\"üéØ VALID PARENTHESES - STACK MASTERY TESTS!\");\nconsole.log(\"=\".repeat(60));\n\nconst testCases = [\n    // Basic cases\n    { input: \"()\", expected: true, description: \"Simple pair\" },\n    { input: \"()[]{}\", expected: true, description: \"Multiple types\" },\n    { input: \"(]\", expected: false, description: \"Mismatched types\" },\n    { input: \"([)]\", expected: false, description: \"Wrong nesting order\" },\n    { input: \"{[]}\", expected: true, description: \"Proper nesting\" },\n    \n    // Edge cases (CRITICAL!)\n    { input: \"\", expected: true, description: \"Empty string\" },\n    { input: \"(\", expected: false, description: \"Single opening\" },\n    { input: \")\", expected: false, description: \"Single closing\" },\n    { input: \"((\", expected: false, description: \"Only opening\" },\n    { input: \"))\", expected: false, description: \"Only closing\" },\n    \n    // Complex patterns\n    { input: \"((()))\", expected: true, description: \"Nested same type\" },\n    { input: \"({[]})\", expected: true, description: \"Perfect nesting\" },\n    { input: \"({[}])\", expected: false, description: \"Cross nesting\" },\n    { input: \"((((()))))\", expected: true, description: \"Deep nesting\" },\n    \n    // Tricky cases\n    { input: \"))(\", expected: false, description: \"Wrong order\" },\n    { input: \"({[\", expected: false, description: \"All opening\" },\n    { input: \"]})\", expected: false, description: \"All closing\" }\n];\n\nconst methods = [\n    { name: \"Stack (Primary)\", func: isValidParentheses },\n    { name: \"Set-based\", func: isValidSet },\n    { name: \"Array Methods\", func: isValidArrayMethods },\n    { name: \"Replace\", func: isValidReplace },\n    { name: \"Recursive\", func: isValidRecursive },\n    { name: \"Counter\", func: isValidCounter }\n];\n\ntestCases.forEach((test, i) => {\n    console.log(`\\nüìù Test ${i + 1}: ${test.description}`);\n    console.log(`Input: \"${test.input}\"`);\n    console.log(`Expected: ${test.expected}`);\n    \n    let allCorrect = true;\n    \n    methods.forEach(({ name, func }) => {\n        try {\n            const result = func(test.input);\n            const isCorrect = result === test.expected;\n            \n            if (!isCorrect) allCorrect = false;\n            \n            console.log(`  ${name}: ${result} ${isCorrect ? '‚úÖ' : '‚ùå'}`);\n        } catch (error) {\n            console.log(`  ${name}: Error - ${error.message} ‚ùå`);\n            allCorrect = false;\n        }\n    });\n    \n    console.log(`‚úÖ All methods correct: ${allCorrect}`);\n});\n\n// üéØ STEP-BY-STEP WALKTHROUGH\nconsole.log(`\\nüéØ STEP-BY-STEP WALKTHROUGH:`);\nconsole.log(\"Input: '({[]})'\");\nconsole.log(\"1. '(' ‚Üí Push to stack: ['(']\");\nconsole.log(\"2. '{' ‚Üí Push to stack: ['(', '{']\");\nconsole.log(\"3. '[' ‚Üí Push to stack: ['(', '{', '[']\");\nconsole.log(\"4. ']' ‚Üí Matches '[', pop: ['(', '{']\");\nconsole.log(\"5. '}' ‚Üí Matches '{', pop: ['(']\");\nconsole.log(\"6. ')' ‚Üí Matches '(', pop: []\");\nconsole.log(\"7. Stack empty ‚Üí Valid! ‚úÖ\");\n\n// üíº CAREER SUCCESS METRICS\nconsole.log(`\\nüíº WHY THIS PROBLEM IS CAREER-DEFINING:`);\nconsole.log(\"üèÜ Asked in 95%+ of coding interviews\");\nconsole.log(\"üèÜ Gateway to senior developer roles\");\nconsole.log(\"üèÜ Foundation for parsing algorithms\");\nconsole.log(\"üèÜ Tests fundamental data structure knowledge\");\nconsole.log(\"üèÜ Demonstrates clean, bug-free coding\");\n\n// üöÄ JAVASCRIPT-SPECIFIC MASTERY\nconsole.log(`\\nüöÄ JAVASCRIPT INTERVIEW MASTERY TIPS:`);\nconsole.log(\"1. ‚ö° Use const/let appropriately\");\nconsole.log(\"2. ‚ö° Know array.push() and array.pop() performance\");\nconsole.log(\"3. ‚ö° Understand for...of vs for...in loops\");\nconsole.log(\"4. ‚ö° Use Set and Map when appropriate\");\nconsole.log(\"5. ‚ö° Handle edge cases with early returns\");\nconsole.log(\"6. ‚ö° Explain time/space complexity clearly\");\n\n// üéØ FOLLOW-UP QUESTIONS\nconsole.log(`\\nüéØ COMMON FOLLOW-UP QUESTIONS:`);\nconsole.log(\"‚Ä¢ Minimum removals to make valid\");\nconsole.log(\"‚Ä¢ Generate all valid parentheses of length n\");\nconsole.log(\"‚Ä¢ Longest valid parentheses substring\");\nconsole.log(\"‚Ä¢ Remove invalid parentheses\");\nconsole.log(\"‚Ä¢ Different bracket priorities\");\n\nconsole.log(\"\\n\" + \"=\".repeat(60));\nconsole.log(\"‚≠ê JAVASCRIPT STACK MASTERY ACHIEVED!\");\nconsole.log(\"‚≠ê This problem pattern applies to 20+ variations!\");\nconsole.log(\"‚≠ê Perfect for demonstrating clean JS coding style!\");\nconsole.log(\"=\".repeat(60));\n```\n\n## Challenge 4: Maximum Subarray (Kadane's Algorithm) ‚≠ê‚≠ê‚≠ê\n\n**‚ö° Interview Frequency: EXTREMELY HIGH** | **Companies: Google, Amazon, Microsoft, Facebook**\n\n**Problem:** Find the contiguous subarray with the largest sum.\n\n**Example:**\n```javascript\nInput: [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6 // subarray [4,-1,2,1]\n```\n\n**Career Game-Changer:** This legendary algorithm demonstrates dynamic programming mastery and optimization thinking!\n\n```python\n// Solution for Challenge 4: Maximum Subarray - KADANE'S ALGORITHM IN JS!\n\n// Method 1: Kadane's Algorithm (THE LEGENDARY SOLUTION!)\nfunction maxSubarray(nums) {\n    /**\n     * Kadane's Algorithm - THE algorithm every programmer must know!\n     * Time: O(n), Space: O(1) - Optimal!\n     * This algorithm can make or break your JavaScript interview.\n     */\n    if (nums.length === 0) return 0;\n    \n    let maxEndingHere = maxSoFar = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        // Key insight: either extend existing subarray or start new one\n        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n        maxSoFar = Math.max(maxSoFar, maxEndingHere);\n    }\n    \n    return maxSoFar;\n}\n\n// Method 2: Kadane's with subarray indices (for follow-ups)\nfunction maxSubarrayWithIndices(nums) {\n    /**\n     * Returns [maxSum, startIndex, endIndex]\n     */\n    if (nums.length === 0) return [0, 0, 0];\n    \n    let maxSum = maxEndingHere = nums[0];\n    let start = end = tempStart = 0;\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (maxEndingHere < 0) {\n            maxEndingHere = nums[i];\n            tempStart = i;\n        } else {\n            maxEndingHere += nums[i];\n        }\n        \n        if (maxEndingHere > maxSum) {\n            maxSum = maxEndingHere;\n            start = tempStart;\n            end = i;\n        }\n    }\n    \n    return [maxSum, start, end];\n}\n\n// Method 3: Functional programming approach\nfunction maxSubarrayFunctional(nums) {\n    if (nums.length === 0) return 0;\n    \n    const result = nums.reduce(\n        (acc, num) => {\n            const maxEndingHere = Math.max(num, acc.maxEndingHere + num);\n            const maxSoFar = Math.max(acc.maxSoFar, maxEndingHere);\n            return { maxEndingHere, maxSoFar };\n        },\n        { maxEndingHere: nums[0], maxSoFar: nums[0] }\n    );\n    \n    return result.maxSoFar;\n}\n\n// Method 4: ES6 with destructuring\nfunction maxSubarrayES6(nums) {\n    if (nums.length === 0) return 0;\n    \n    let [maxEndingHere, maxSoFar] = [nums[0], nums[0]];\n    \n    for (const [i, num] of nums.entries()) {\n        if (i === 0) continue;\n        \n        maxEndingHere = Math.max(num, maxEndingHere + num);\n        maxSoFar = Math.max(maxSoFar, maxEndingHere);\n    }\n    \n    return maxSoFar;\n}\n\n// Method 5: Divide and conquer (O(n log n))\nfunction maxSubarrayDivideConquer(nums) {\n    function maxCrossingSum(nums, left, mid, right) {\n        let leftSum = -Infinity;\n        let sum = 0;\n        \n        for (let i = mid; i >= left; i--) {\n            sum += nums[i];\n            if (sum > leftSum) leftSum = sum;\n        }\n        \n        let rightSum = -Infinity;\n        sum = 0;\n        \n        for (let i = mid + 1; i <= right; i++) {\n            sum += nums[i];\n            if (sum > rightSum) rightSum = sum;\n        }\n        \n        return leftSum + rightSum;\n    }\n    \n    function maxSubarrayRec(nums, left, right) {\n        if (left === right) return nums[left];\n        \n        const mid = Math.floor((left + right) / 2);\n        \n        return Math.max(\n            maxSubarrayRec(nums, left, mid),\n            maxSubarrayRec(nums, mid + 1, right),\n            maxCrossingSum(nums, left, mid, right)\n        );\n    }\n    \n    if (nums.length === 0) return 0;\n    return maxSubarrayRec(nums, 0, nums.length - 1);\n}\n\n// Method 6: Brute force (for comparison)\nfunction maxSubarrayBruteForce(nums) {\n    if (nums.length === 0) return 0;\n    \n    let maxSum = -Infinity;\n    \n    for (let i = 0; i < nums.length; i++) {\n        let currentSum = 0;\n        for (let j = i; j < nums.length; j++) {\n            currentSum += nums[j];\n            maxSum = Math.max(maxSum, currentSum);\n        }\n    }\n    \n    return maxSum;\n}\n\n// üéØ COMPREHENSIVE INTERVIEW TEST CASES\nconsole.log(\"üéØ MAXIMUM SUBARRAY - LEGENDARY ALGORITHM IN JAVASCRIPT!\");\nconsole.log(\"=\".repeat(70));\n\nconst testCases = [\n    // Classic examples\n    { nums: [-2, 1, -3, 4, -1, 2, 1, -5, 4], expected: 6, description: \"Classic example [4,-1,2,1]\" },\n    { nums: [1], expected: 1, description: \"Single positive element\" },\n    { nums: [5, 4, -1, 7, 8], expected: 23, description: \"Mostly positive\" },\n    \n    // Edge cases\n    { nums: [-1], expected: -1, description: \"Single negative element\" },\n    { nums: [-2, -1], expected: -1, description: \"All negative\" },\n    { nums: [1, 2, 3, 4, 5], expected: 15, description: \"All positive\" },\n    { nums: [], expected: 0, description: \"Empty array\" },\n    \n    // Tricky patterns\n    { nums: [1, -1, 1, -1, 1], expected: 1, description: \"Alternating pattern\" },\n    { nums: [-1, -2, -3, -4], expected: -1, description: \"All negative descending\" },\n    { nums: [2, -8, 3, -2, 4, -10, 6], expected: 6, description: \"Single element wins\" },\n    \n    // Complex scenarios\n    { nums: [1, 2, -1, -2, 2, 1, -2, 1], expected: 4, description: \"Complex mixed\" },\n    { nums: [100, -2, -3, -4, 1, 2, 3], expected: 100, description: \"Large single vs small sum\" }\n];\n\nconst methods = [\n    { name: \"Kadane's Algorithm\", func: maxSubarray },\n    { name: \"With Indices\", func: (nums) => maxSubarrayWithIndices(nums)[0] },\n    { name: \"Functional\", func: maxSubarrayFunctional },\n    { name: \"ES6 Style\", func: maxSubarrayES6 },\n    { name: \"Divide & Conquer\", func: maxSubarrayDivideConquer },\n    { name: \"Brute Force\", func: maxSubarrayBruteForce }\n];\n\ntestCases.forEach((test, i) => {\n    console.log(`\\nüìù Test ${i + 1}: ${test.description}`);\n    console.log(`Array: [${test.nums.join(', ')}]`);\n    console.log(`Expected: ${test.expected}`);\n    \n    let allCorrect = true;\n    \n    methods.forEach(({ name, func }) => {\n        try {\n            const result = func([...test.nums]);\n            const isCorrect = result === test.expected;\n            \n            if (!isCorrect) allCorrect = false;\n            \n            console.log(`  ${name}: ${result} ${isCorrect ? '‚úÖ' : '‚ùå'}`);\n        } catch (error) {\n            console.log(`  ${name}: Error - ${error.message} ‚ùå`);\n            allCorrect = false;\n        }\n    });\n    \n    console.log(`‚úÖ All methods correct: ${allCorrect}`);\n});\n\n// üéØ DETAILED WALKTHROUGH\nconsole.log(`\\nüéØ KADANE'S ALGORITHM WALKTHROUGH:`);\nconst nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4];\nconsole.log(`Array: [${nums.join(', ')}]`);\nconsole.log(\"Step-by-step execution:\");\n\nlet maxEndingHere = maxSoFar = nums[0];\nconsole.log(`Initialize: maxEndingHere = ${maxEndingHere}, maxSoFar = ${maxSoFar}`);\n\nfor (let i = 1; i < nums.length; i++) {\n    const oldMaxEnding = maxEndingHere;\n    maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n    maxSoFar = Math.max(maxSoFar, maxEndingHere);\n    \n    const decision = maxEndingHere === oldMaxEnding + nums[i] ? \"extend\" : \"restart\";\n    console.log(`i=${i}, nums[${i}]=${nums[i].toString().padStart(2)}: ${decision.padEnd(7)} ‚Üí maxEnding=${maxEndingHere.toString().padStart(2)}, maxSoFar=${maxSoFar}`);\n}\n\n// Show the actual subarray\nconst [maxSum, start, end] = maxSubarrayWithIndices(nums);\nconsole.log(`\\nOptimal subarray: [${nums.slice(start, end + 1).join(', ')}] = ${maxSum}`);\n\n// üíº CAREER TRANSFORMATION IMPACT\nconsole.log(`\\nüíº CAREER TRANSFORMATION METRICS:`);\nconsole.log(\"üèÜ Asked in 90%+ of array/DP interviews\");\nconsole.log(\"üèÜ Demonstrates algorithmic thinking mastery\");\nconsole.log(\"üèÜ Gateway to advanced DP problems\");\nconsole.log(\"üèÜ Shows optimization skills (O(n¬≤) ‚Üí O(n))\");\nconsole.log(\"üèÜ Required for senior+ JavaScript engineering roles\");\n\n// üöÄ JAVASCRIPT INTERVIEW MASTERY\nconsole.log(`\\nüöÄ JAVASCRIPT INTERVIEW DOMINATION:`);\nconsole.log(\"1. ‚ö° Use Math.max() for clean comparisons\");\nconsole.log(\"2. ‚ö° Know array destructuring: const [a, b] = array\");\nconsole.log(\"3. ‚ö° Understand reduce() for functional approach\");\nconsole.log(\"4. ‚ö° Use const/let appropriately (never var)\");\nconsole.log(\"5. ‚ö° Handle edge cases (empty arrays)\");\nconsole.log(\"6. ‚ö° Explain the 'extend vs restart' concept clearly\");\n\n// üî• FOLLOW-UP VARIATIONS\nconsole.log(`\\nüî• COMMON JAVASCRIPT FOLLOW-UPS:`);\nconsole.log(\"‚Ä¢ Return the actual subarray (not just sum)\");\nconsole.log(\"‚Ä¢ Maximum subarray of size exactly k\");\nconsole.log(\"‚Ä¢ Maximum circular subarray\");\nconsole.log(\"‚Ä¢ Maximum product subarray\");\nconsole.log(\"‚Ä¢ Use array methods: map, filter, reduce\");\nconsole.log(\"‚Ä¢ Handle async arrays with promises\");\n\n// üöÄ PERFORMANCE COMPARISON\nconsole.log(`\\nüöÄ ALGORITHM PERFORMANCE:`);\nconsole.log(\"‚Ä¢ Kadane's: O(n) time, O(1) space - OPTIMAL! üèÜ\");\nconsole.log(\"‚Ä¢ Functional: O(n) time, O(1) space - Clean code\");\nconsole.log(\"‚Ä¢ Divide & Conquer: O(n log n) time, O(log n) space\");\nconsole.log(\"‚Ä¢ Brute Force: O(n¬≤) time, O(1) space - Too slow!\");\n\nconsole.log(\"\\n\" + \"=\".repeat(70));\nconsole.log(\"‚≠ê JAVASCRIPT LEGEND STATUS: Master Kadane's = Master DP!\");\nconsole.log(\"‚≠ê This algorithm showcases your optimization thinking!\");\nconsole.log(\"‚≠ê Perfect for demonstrating modern JS techniques!\");\nconsole.log(\"=\".repeat(70));\n```\n\n## Challenge 5: Merge Intervals ‚≠ê‚≠ê‚≠ê\n\n**‚ö° Interview Frequency: VERY HIGH** | **Companies: Google, Facebook, Amazon, Microsoft**\n\n**Problem:** Given a collection of intervals, merge all overlapping intervals.\n\n**Example:**\n```javascript\nInput: [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\n```\n\n**Career Impact:** Tests algorithm design and demonstrates systematic problem-solving skills!\n\n```python\n// Solution for Challenge 5: Merge Intervals - ALGORITHM DESIGN MASTERY!\n\n// Method 1: Optimal sorting approach (MOST COMMON IN INTERVIEWS)\nfunction mergeIntervals(intervals) {\n    /**\n     * Merge overlapping intervals - O(n log n) time, O(1) space.\n     * This is THE solution interviewers expect!\n     */\n    if (intervals.length === 0) return [];\n    \n    // Step 1: Sort by start time (CRITICAL!)\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    // Step 2: Initialize result with first interval\n    const merged = [intervals[0]];\n    \n    // Step 3: Iterate and merge\n    for (let i = 1; i < intervals.length; i++) {\n        const current = intervals[i];\n        const lastMerged = merged[merged.length - 1];\n        \n        // Check for overlap: current start <= last end\n        if (current[0] <= lastMerged[1]) {\n            // Merge: extend the end time\n            lastMerged[1] = Math.max(lastMerged[1], current[1]);\n        } else {\n            // No overlap: add new interval\n            merged.push(current);\n        }\n    }\n    \n    return merged;\n}\n\n// Method 2: Functional programming approach\nfunction mergeIntervalsFunctional(intervals) {\n    if (intervals.length === 0) return [];\n    \n    return intervals\n        .sort((a, b) => a[0] - b[0])\n        .reduce((merged, current) => {\n            const last = merged[merged.length - 1];\n            \n            if (merged.length === 0 || current[0] > last[1]) {\n                merged.push(current);\n            } else {\n                last[1] = Math.max(last[1], current[1]);\n            }\n            \n            return merged;\n        }, []);\n}\n\n// Method 3: ES6 with destructuring\nfunction mergeIntervalsES6(intervals) {\n    if (intervals.length === 0) return [];\n    \n    const sorted = intervals.sort(([a], [b]) => a - b);\n    const result = [sorted[0]];\n    \n    for (const [start, end] of sorted.slice(1)) {\n        const lastInterval = result[result.length - 1];\n        const [, lastEnd] = lastInterval;\n        \n        if (start <= lastEnd) {\n            lastInterval[1] = Math.max(lastEnd, end);\n        } else {\n            result.push([start, end]);\n        }\n    }\n    \n    return result;\n}\n\n// Method 4: Using Map for tracking (alternative approach)\nfunction mergeIntervalsMap(intervals) {\n    if (intervals.length === 0) return [];\n    \n    // Sort intervals\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    const merged = new Map();\n    let mergedIndex = 0;\n    \n    for (const [start, end] of intervals) {\n        if (merged.size === 0) {\n            merged.set(mergedIndex, [start, end]);\n        } else {\n            const lastInterval = merged.get(mergedIndex);\n            \n            if (start <= lastInterval[1]) {\n                lastInterval[1] = Math.max(lastInterval[1], end);\n            } else {\n                mergedIndex++;\n                merged.set(mergedIndex, [start, end]);\n            }\n        }\n    }\n    \n    return Array.from(merged.values());\n}\n\n// Method 5: In-place merging (space optimized)\nfunction mergeIntervalsInPlace(intervals) {\n    if (intervals.length === 0) return [];\n    \n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    let writeIndex = 0;\n    \n    for (let readIndex = 1; readIndex < intervals.length; readIndex++) {\n        const current = intervals[readIndex];\n        const lastMerged = intervals[writeIndex];\n        \n        if (current[0] <= lastMerged[1]) {\n            // Merge\n            lastMerged[1] = Math.max(lastMerged[1], current[1]);\n        } else {\n            // Move to next position\n            writeIndex++;\n            intervals[writeIndex] = current;\n        }\n    }\n    \n    return intervals.slice(0, writeIndex + 1);\n}\n\n// Method 6: Recursive approach (educational)\nfunction mergeIntervalsRecursive(intervals, index = 0, merged = []) {\n    if (index >= intervals.length) return merged;\n    \n    if (index === 0) {\n        intervals.sort((a, b) => a[0] - b[0]);\n        merged.push(intervals[0]);\n        return mergeIntervalsRecursive(intervals, 1, merged);\n    }\n    \n    const current = intervals[index];\n    const last = merged[merged.length - 1];\n    \n    if (current[0] <= last[1]) {\n        last[1] = Math.max(last[1], current[1]);\n    } else {\n        merged.push(current);\n    }\n    \n    return mergeIntervalsRecursive(intervals, index + 1, merged);\n}\n\n// üéØ COMPREHENSIVE INTERVIEW TEST CASES\nconsole.log(\"üéØ MERGE INTERVALS - ALGORITHM DESIGN EXCELLENCE!\");\nconsole.log(\"=\".repeat(65));\n\nconst testCases = [\n    // Basic cases\n    { \n        input: [[1,3],[2,6],[8,10],[15,18]], \n        expected: [[1,6],[8,10],[15,18]], \n        description: \"Basic overlap\" \n    },\n    { \n        input: [[1,4],[4,5]], \n        expected: [[1,5]], \n        description: \"Adjacent intervals (edge case!)\" \n    },\n    { \n        input: [[1,2],[3,4],[5,6]], \n        expected: [[1,2],[3,4],[5,6]], \n        description: \"No overlaps\" \n    },\n    { \n        input: [[1,4],[2,3]], \n        expected: [[1,4]], \n        description: \"Contained interval\" \n    },\n    \n    // Edge cases\n    { \n        input: [], \n        expected: [], \n        description: \"Empty input\" \n    },\n    { \n        input: [[1,4]], \n        expected: [[1,4]], \n        description: \"Single interval\" \n    },\n    \n    // Complex cases\n    { \n        input: [[4,5],[1,3],[0,1]], \n        expected: [[0,3],[4,5]], \n        description: \"Unsorted input\" \n    },\n    { \n        input: [[1,3],[2,6],[8,10],[9,12],[15,18]], \n        expected: [[1,6],[8,12],[15,18]], \n        description: \"Complex pattern\" \n    },\n    { \n        input: [[1,2],[2,3],[3,4],[4,5]], \n        expected: [[1,5]], \n        description: \"Chain merging\" \n    },\n    { \n        input: [[1,3],[1,3],[2,4]], \n        expected: [[1,4]], \n        description: \"Duplicates\" \n    }\n];\n\nconst methods = [\n    { name: \"Optimal Sorting\", func: mergeIntervals },\n    { name: \"Functional\", func: mergeIntervalsFunctional },\n    { name: \"ES6 Destructuring\", func: mergeIntervalsES6 },\n    { name: \"Map-based\", func: mergeIntervalsMap },\n    { name: \"In-place\", func: mergeIntervalsInPlace },\n    { name: \"Recursive\", func: mergeIntervalsRecursive }\n];\n\ntestCases.forEach((test, i) => {\n    console.log(`\\nüìù Test ${i + 1}: ${test.description}`);\n    console.log(`Input: ${JSON.stringify(test.input)}`);\n    console.log(`Expected: ${JSON.stringify(test.expected)}`);\n    \n    let allCorrect = true;\n    \n    methods.forEach(({ name, func }) => {\n        try {\n            // Deep copy to avoid mutation\n            const inputCopy = JSON.parse(JSON.stringify(test.input));\n            const result = func(inputCopy);\n            const isCorrect = JSON.stringify(result) === JSON.stringify(test.expected);\n            \n            if (!isCorrect) allCorrect = false;\n            \n            console.log(`  ${name}: ${JSON.stringify(result)} ${isCorrect ? '‚úÖ' : '‚ùå'}`);\n        } catch (error) {\n            console.log(`  ${name}: Error - ${error.message} ‚ùå`);\n            allCorrect = false;\n        }\n    });\n    \n    console.log(`‚úÖ All methods correct: ${allCorrect}`);\n});\n\n// üéØ INTERVIEW WALKTHROUGH\nconsole.log(`\\nüéØ STEP-BY-STEP WALKTHROUGH:`);\nconsole.log(\"Input: [[1,3],[2,6],[8,10],[15,18]]\");\nconsole.log(\"Step 1: Sort by start time ‚Üí [[1,3],[2,6],[8,10],[15,18]]\");\nconsole.log(\"Step 2: Start with first interval [1,3]\");\nconsole.log(\"Step 3: Check [2,6] - 2 <= 3? YES ‚Üí Merge to [1,6]\");\nconsole.log(\"Step 4: Check [8,10] - 8 <= 6? NO ‚Üí Add [8,10]\");\nconsole.log(\"Step 5: Check [15,18] - 15 <= 10? NO ‚Üí Add [15,18]\");\nconsole.log(\"Result: [[1,6],[8,10],[15,18]] ‚úÖ\");\n\n// üíº CAREER SUCCESS METRICS\nconsole.log(`\\nüíº CAREER IMPACT OF MASTERING MERGE INTERVALS:`);\nconsole.log(\"üèÜ Appears in 85%+ of algorithm interviews\");\nconsole.log(\"üèÜ Tests sorting, greedy algorithms, and edge cases\");\nconsole.log(\"üèÜ Foundation for harder problems (Meeting Rooms, etc.)\");\nconsole.log(\"üèÜ Demonstrates systematic problem-solving\");\nconsole.log(\"üèÜ Shows ability to optimize (time/space tradeoffs)\");\n\n// üöÄ JAVASCRIPT INTERVIEW EXCELLENCE\nconsole.log(`\\nüöÄ JAVASCRIPT INTERVIEW SUCCESS STRATEGIES:`);\nconsole.log(\"1. ‚ö° Use array.sort() with custom comparator\");\nconsole.log(\"2. ‚ö° Know array destructuring: const [start, end] = interval\");\nconsole.log(\"3. ‚ö° Use Math.max() for clean comparisons\");\nconsole.log(\"4. ‚ö° Understand reduce() for functional approach\");\nconsole.log(\"5. ‚ö° Handle edge cases (empty arrays)\");\nconsole.log(\"6. ‚ö° Use JSON.parse/stringify for deep copying\");\n\n// üéØ FOLLOW-UP QUESTIONS\nconsole.log(`\\nüéØ COMMON FOLLOW-UP QUESTIONS:`);\nconsole.log(\"‚Ä¢ Insert interval into sorted list\");\nconsole.log(\"‚Ä¢ Remove intervals that overlap with given interval\");\nconsole.log(\"‚Ä¢ Find minimum number of meeting rooms needed\");\nconsole.log(\"‚Ä¢ Merge intervals in different formats\");\nconsole.log(\"‚Ä¢ Handle intervals with different priorities\");\n\n// üî• PERFORMANCE ANALYSIS\nconsole.log(`\\nüî• PERFORMANCE & COMPLEXITY:`);\nconsole.log(\"Time Complexity: O(n log n) - dominated by sorting\");\nconsole.log(\"Space Complexity: O(1) - if we don't count output array\");\nconsole.log(\"Best Case: Already sorted intervals\");\nconsole.log(\"Worst Case: Reverse sorted intervals\");\n\nconsole.log(\"\\n\" + \"=\".repeat(65));\nconsole.log(\"‚≠ê ALGORITHM DESIGN MASTERY ACHIEVED!\");\nconsole.log(\"‚≠ê This pattern solves 15+ interval problems!\");\nconsole.log(\"‚≠ê Perfect showcase of JavaScript array methods!\");\nconsole.log(\"=\".repeat(65));\n```\n\n## üéØ JavaScript-Specific Interview Challenges\n\n**These challenges showcase JavaScript's unique features and are commonly asked in frontend/fullstack interviews.**\n\n## Challenge 6: Closures & Scope ‚≠ê‚≠ê‚≠ê\n\n**‚ö° Interview Frequency: VERY HIGH** | **Companies: All JavaScript-focused roles**\n\n**Problem:** Demonstrate understanding of closures, scope, and variable hoisting.\n\n**Why It Matters:** Closures are fundamental to JavaScript and separate junior from senior developers!\n\n```python\n// Solution for Challenge 6: Closures & Scope - JAVASCRIPT MASTERY!\n\nconsole.log(\"üéØ CLOSURES & SCOPE - JAVASCRIPT FUNDAMENTALS!\");\nconsole.log(\"=\".repeat(60));\n\n// Example 1: Basic Closure\nfunction createCounter() {\n    let count = 0;\n    \n    return function() {\n        return ++count;\n    };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\n\nconsole.log(\"\\nüìù Example 1: Basic Closure\");\nconsole.log(\"counter1():\", counter1()); // 1\nconsole.log(\"counter1():\", counter1()); // 2\nconsole.log(\"counter2():\", counter2()); // 1 (separate closure!)\nconsole.log(\"counter1():\", counter1()); // 3\n\n// Example 2: Closure with Parameters\nfunction createMultiplier(multiplier) {\n    return function(x) {\n        return x * multiplier;\n    };\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(\"\\nüìù Example 2: Closure with Parameters\");\nconsole.log(\"double(5):\", double(5)); // 10\nconsole.log(\"triple(5):\", triple(5)); // 15\n\n// Example 3: Classic Loop Problem (Hoisting Issue)\nconsole.log(\"\\nüìù Example 3: Classic Loop Problem\");\n\n// Problem: All functions print 3\nconsole.log(\"‚ùå Broken version (var):\");\nvar funcs = [];\nfor (var i = 0; i < 3; i++) {\n    funcs[i] = function() {\n        return i; // All will return 3!\n    };\n}\nfuncs.forEach((func, index) => {\n    console.log(`funcs[${index}]():`, func());\n});\n\n// Solution 1: Using let (block scope)\nconsole.log(\"\\n‚úÖ Fixed with let:\");\nconst funcsLet = [];\nfor (let i = 0; i < 3; i++) {\n    funcsLet[i] = function() {\n        return i; // Each has its own i\n    };\n}\nfuncsLet.forEach((func, index) => {\n    console.log(`funcsLet[${index}]():`, func());\n});\n\n// Solution 2: Using closure (IIFE)\nconsole.log(\"\\n‚úÖ Fixed with IIFE:\");\nconst funcsIIFE = [];\nfor (var i = 0; i < 3; i++) {\n    funcsIIFE[i] = (function(j) {\n        return function() {\n            return j;\n        };\n    })(i);\n}\nfuncsIIFE.forEach((func, index) => {\n    console.log(`funcsIIFE[${index}]():`, func());\n});\n\n// Example 4: Module Pattern\nconsole.log(\"\\nüìù Example 4: Module Pattern\");\n\nconst calculator = (function() {\n    let result = 0; // Private variable\n    \n    return {\n        add: function(x) {\n            result += x;\n            return this;\n        },\n        subtract: function(x) {\n            result -= x;\n            return this;\n        },\n        multiply: function(x) {\n            result *= x;\n            return this;\n        },\n        getResult: function() {\n            return result;\n        },\n        reset: function() {\n            result = 0;\n            return this;\n        }\n    };\n})();\n\nconsole.log(\"Calculator result:\", \n    calculator.add(10).multiply(2).subtract(5).getResult()); // 15\n\n// Example 5: Function Factory\nconsole.log(\"\\nüìù Example 5: Function Factory\");\n\nfunction createValidator(type) {\n    const validators = {\n        email: (email) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email),\n        phone: (phone) => /^\\d{10}$/.test(phone.replace(/\\D/g, '')),\n        password: (pwd) => pwd.length >= 8 && /[A-Z]/.test(pwd) && /[0-9]/.test(pwd)\n    };\n    \n    return function(value) {\n        return validators[type] ? validators[type](value) : false;\n    };\n}\n\nconst validateEmail = createValidator('email');\nconst validatePassword = createValidator('password');\n\nconsole.log(\"validateEmail('test@example.com'):\", validateEmail('test@example.com'));\nconsole.log(\"validatePassword('Password123'):\", validatePassword('Password123'));\nconsole.log(\"validatePassword('weak'):\", validatePassword('weak'));\n\n// Example 6: Memoization with Closures\nconsole.log(\"\\nüìù Example 6: Memoization\");\n\nfunction memoize(fn) {\n    const cache = new Map();\n    \n    return function(...args) {\n        const key = JSON.stringify(args);\n        \n        if (cache.has(key)) {\n            console.log(`Cache hit for ${key}`);\n            return cache.get(key);\n        }\n        \n        console.log(`Computing ${key}`);\n        const result = fn.apply(this, args);\n        cache.set(key, result);\n        return result;\n    };\n}\n\nconst memoizedFib = memoize(function fibonacci(n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n});\n\nconsole.log(\"memoizedFib(10):\", memoizedFib(10));\nconsole.log(\"memoizedFib(10) again:\", memoizedFib(10)); // Cache hit!\n\n// Example 7: Debounce Function\nconsole.log(\"\\nüìù Example 7: Debounce Function\");\n\nfunction debounce(func, delay) {\n    let timeoutId;\n    \n    return function(...args) {\n        clearTimeout(timeoutId);\n        \n        timeoutId = setTimeout(() => {\n            func.apply(this, args);\n        }, delay);\n    };\n}\n\nconst debouncedLog = debounce((message) => {\n    console.log(\"Debounced:\", message);\n}, 100);\n\n// Only the last call will execute after 100ms\ndebouncedLog(\"First call\");\ndebouncedLog(\"Second call\");\ndebouncedLog(\"Third call\");\n\n// Example 8: Private Methods with Closures\nconsole.log(\"\\nüìù Example 8: Private Methods\");\n\nfunction createBankAccount(initialBalance) {\n    let balance = initialBalance;\n    \n    // Private methods\n    function validateAmount(amount) {\n        return typeof amount === 'number' && amount > 0;\n    }\n    \n    function formatCurrency(amount) {\n        return `$${amount.toFixed(2)}`;\n    }\n    \n    // Public API\n    return {\n        deposit(amount) {\n            if (!validateAmount(amount)) {\n                throw new Error('Invalid amount');\n            }\n            balance += amount;\n            return formatCurrency(balance);\n        },\n        \n        withdraw(amount) {\n            if (!validateAmount(amount)) {\n                throw new Error('Invalid amount');\n            }\n            if (amount > balance) {\n                throw new Error('Insufficient funds');\n            }\n            balance -= amount;\n            return formatCurrency(balance);\n        },\n        \n        getBalance() {\n            return formatCurrency(balance);\n        }\n    };\n}\n\nconst account = createBankAccount(100);\nconsole.log(\"Initial balance:\", account.getBalance());\nconsole.log(\"After deposit $50:\", account.deposit(50));\nconsole.log(\"After withdraw $25:\", account.withdraw(25));\n\n// üíº CAREER SUCCESS IMPACT\nconsole.log(`\\nüíº CLOSURE MASTERY CAREER IMPACT:`);\nconsole.log(\"üèÜ Distinguishes senior from junior developers\");\nconsole.log(\"üèÜ Essential for React hooks understanding\");\nconsole.log(\"üèÜ Critical for functional programming\");\nconsole.log(\"üèÜ Required for module patterns\");\nconsole.log(\"üèÜ Foundation for async programming\");\n\n// üöÄ INTERVIEW MASTERY TIPS\nconsole.log(`\\nüöÄ CLOSURE INTERVIEW SUCCESS:`);\nconsole.log(\"1. ‚ö° Explain lexical scoping clearly\");\nconsole.log(\"2. ‚ö° Know the difference: var vs let vs const\");\nconsole.log(\"3. ‚ö° Understand function vs block scope\");\nconsole.log(\"4. ‚ö° Demonstrate practical use cases\");\nconsole.log(\"5. ‚ö° Explain memory implications\");\nconsole.log(\"6. ‚ö° Show module pattern knowledge\");\n\n// üéØ COMMON INTERVIEW QUESTIONS\nconsole.log(`\\nüéØ COMMON CLOSURE INTERVIEW QUESTIONS:`);\nconsole.log(\"‚Ä¢ What is a closure and how does it work?\");\nconsole.log(\"‚Ä¢ Fix the loop + setTimeout problem\");\nconsole.log(\"‚Ä¢ Implement a private variable\");\nconsole.log(\"‚Ä¢ Create a function that remembers its calls\");\nconsole.log(\"‚Ä¢ Explain the module pattern\");\nconsole.log(\"‚Ä¢ What are the performance implications?\");\n\nconsole.log(\"\\n\" + \"=\".repeat(60));\nconsole.log(\"‚≠ê CLOSURE MASTERY = JAVASCRIPT SENIOR LEVEL!\");\nconsole.log(\"‚≠ê This concept unlocks advanced JS patterns!\");\nconsole.log(\"=\".repeat(60));\n```\n\n## üéØ Final JavaScript Interview Success Guide\n\n**Congratulations! You now have a powerful JavaScript interview toolkit!**\n\n### üèÜ **JavaScript Mastery Achieved:**\n\n1. **‚úÖ Two Sum** - Hash Map/Object mastery\n2. **‚úÖ Valid Parentheses** - Stack and data structures\n3. **‚úÖ Maximum Subarray** - Algorithm optimization\n4. **‚úÖ Merge Intervals** - Systematic problem solving\n5. **‚úÖ Closures & Scope** - JavaScript fundamentals\n\n### üöÄ **Your JavaScript Interview Strategy:**\n\n**Technical Preparation:**\n- **Master ES6+ features**: Arrow functions, destructuring, spread operator\n- **Understand async programming**: Promises, async/await, event loop\n- **Know functional programming**: map, filter, reduce, higher-order functions\n- **Practice array methods**: sort, slice, splice, forEach, find\n\n**Interview Performance:**\n- **Think out loud** - explain your approach\n- **Start with brute force** - then optimize\n- **Handle edge cases** - empty arrays, null values\n- **Write clean code** - use const/let, meaningful names\n- **Analyze complexity** - time and space\n\n### üíº **Career Advancement Opportunities:**\n\n**Frontend Developer Roles:**\n- React, Vue, Angular development\n- State management (Redux, Vuex)\n- Modern build tools (Webpack, Vite)\n\n**Full-Stack JavaScript:**\n- Node.js backend development\n- Express.js and API design\n- Database integration (MongoDB, PostgreSQL)\n\n**Senior JavaScript Engineer:**\n- Performance optimization\n- Architecture design\n- Mentoring junior developers\n\n### üéØ **Next Steps for Continued Growth:**\n\n1. **Practice regularly** on LeetCode, HackerRank, Codewars\n2. **Build projects** showcasing these algorithms\n3. **Contribute to open source** JavaScript projects\n4. **Study frameworks** like React, Vue, or Angular\n5. **Learn TypeScript** for type safety\n6. **Master testing** with Jest, Mocha, or Cypress\n\n### üî• **Quick Reference for Interviews:**\n\n**Array Methods:** `map()`, `filter()`, `reduce()`, `sort()`, `find()`\n**Object Methods:** `Object.keys()`, `Object.values()`, `Object.entries()`\n**Modern Syntax:** Arrow functions, template literals, destructuring\n**Async Patterns:** Promises, async/await, event handling\n**Performance:** Time/space complexity, memoization, debouncing\n\n---\n\n**Remember: JavaScript interviews test both algorithmic thinking AND language-specific knowledge. Master both to excel!**\n\nüéØ **Pro Tip:** Always explain WHY you chose a particular JavaScript feature or method - it shows deep understanding!\n\n## Challenge 7: Async/Await & Promises ‚≠ê‚≠ê‚≠ê\n\n**‚ö° Interview Frequency: EXTREMELY HIGH** | **Companies: All modern JavaScript roles**\n\n**Problem:** Demonstrate mastery of asynchronous JavaScript patterns and error handling.\n\n**Example:**\n```javascript\n// Fetch user data and posts concurrently\nconst userData = await Promise.all([getUser(id), getUserPosts(id)]);\n```\n\n**Career Impact:** Async programming is essential for modern JavaScript development and separates experienced developers from beginners!\n\n```python\n// Solution for Challenge 7: Async/Await & Promises - MODERN JS MASTERY!\n\nconsole.log(\"üéØ ASYNC/AWAIT & PROMISES - MODERN JAVASCRIPT!\");\nconsole.log(\"=\".repeat(60));\n\n// Example 1: Basic Promise Creation and Handling\nfunction createPromise(value, delay = 1000) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (value > 0) {\n                resolve(`Success: ${value}`);\n            } else {\n                reject(new Error(`Error: ${value} is not positive`));\n            }\n        }, delay);\n    });\n}\n\n// Example 2: Async/Await vs Promise.then()\nasync function demonstrateAsyncAwait() {\n    console.log(\"\\nüìù Example 1: Async/Await vs Promise.then()\");\n    \n    // Using async/await (cleaner)\n    try {\n        console.log(\"Using async/await:\");\n        const result1 = await createPromise(42, 500);\n        console.log(\"‚úÖ\", result1);\n        \n        const result2 = await createPromise(100, 300);\n        console.log(\"‚úÖ\", result2);\n    } catch (error) {\n        console.log(\"‚ùå\", error.message);\n    }\n    \n    // Using Promise.then() (traditional)\n    console.log(\"\\nUsing Promise.then():\");\n    createPromise(84, 200)\n        .then(result => console.log(\"‚úÖ\", result))\n        .catch(error => console.log(\"‚ùå\", error.message));\n}\n\n// Example 3: Promise.all() for Concurrent Execution\nasync function demonstratePromiseAll() {\n    console.log(\"\\nüìù Example 2: Promise.all() for Concurrency\");\n    \n    const startTime = Date.now();\n    \n    try {\n        // Sequential execution (slower)\n        console.log(\"Sequential execution:\");\n        const seq1 = await createPromise(1, 200);\n        const seq2 = await createPromise(2, 200);\n        const seq3 = await createPromise(3, 200);\n        console.log(\"Sequential results:\", [seq1, seq2, seq3]);\n        console.log(\"Sequential time:\", Date.now() - startTime + \"ms\");\n        \n        // Concurrent execution (faster)\n        const concurrentStart = Date.now();\n        console.log(\"\\nConcurrent execution:\");\n        const [con1, con2, con3] = await Promise.all([\n            createPromise(4, 200),\n            createPromise(5, 200),\n            createPromise(6, 200)\n        ]);\n        console.log(\"Concurrent results:\", [con1, con2, con3]);\n        console.log(\"Concurrent time:\", Date.now() - concurrentStart + \"ms\");\n        \n    } catch (error) {\n        console.log(\"‚ùå Promise.all failed:\", error.message);\n    }\n}\n\n// Example 4: Promise.allSettled() for Handling Mixed Results\nasync function demonstratePromiseAllSettled() {\n    console.log(\"\\nüìù Example 3: Promise.allSettled() for Error Handling\");\n    \n    const promises = [\n        createPromise(10, 100),\n        createPromise(-5, 100), // This will reject\n        createPromise(20, 100),\n        createPromise(-3, 100)  // This will also reject\n    ];\n    \n    const results = await Promise.allSettled(promises);\n    \n    console.log(\"All settled results:\");\n    results.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n            console.log(`‚úÖ Promise ${index + 1}:`, result.value);\n        } else {\n            console.log(`‚ùå Promise ${index + 1}:`, result.reason.message);\n        }\n    });\n}\n\n// Example 5: Promise.race() for Timeout Implementation\nasync function demonstratePromiseRace() {\n    console.log(\"\\nüìù Example 4: Promise.race() for Timeouts\");\n    \n    function withTimeout(promise, timeoutMs) {\n        const timeout = new Promise((_, reject) => {\n            setTimeout(() => reject(new Error('Operation timed out')), timeoutMs);\n        });\n        \n        return Promise.race([promise, timeout]);\n    }\n    \n    try {\n        // This should succeed (fast operation)\n        const quickResult = await withTimeout(createPromise(100, 200), 500);\n        console.log(\"‚úÖ Quick operation:\", quickResult);\n        \n        // This should timeout (slow operation)\n        const slowResult = await withTimeout(createPromise(200, 1000), 500);\n        console.log(\"‚úÖ Slow operation:\", slowResult);\n    } catch (error) {\n        console.log(\"‚ùå Operation failed:\", error.message);\n    }\n}\n\n// Example 6: Retry Pattern with Exponential Backoff\nasync function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n            return await fn();\n        } catch (error) {\n            if (attempt === maxRetries) {\n                throw error;\n            }\n            \n            const delay = baseDelay * Math.pow(2, attempt - 1);\n            console.log(`‚ùå Attempt ${attempt} failed. Retrying in ${delay}ms...`);\n            await new Promise(resolve => setTimeout(resolve, delay));\n        }\n    }\n}\n\nasync function demonstrateRetryPattern() {\n    console.log(\"\\nüìù Example 5: Retry Pattern with Exponential Backoff\");\n    \n    let attempts = 0;\n    const unreliableOperation = () => {\n        attempts++;\n        console.log(`Attempting operation... (attempt ${attempts})`);\n        \n        // Simulate 70% failure rate\n        if (Math.random() < 0.7) {\n            throw new Error(\"Random failure\");\n        }\n        \n        return Promise.resolve(\"Success!\");\n    };\n    \n    try {\n        const result = await retryWithBackoff(unreliableOperation, 3, 100);\n        console.log(\"‚úÖ Final result:\", result);\n    } catch (error) {\n        console.log(\"‚ùå All retries failed:\", error.message);\n    }\n}\n\n// Example 7: Async Generators\nasync function* asyncNumberGenerator(count, delay = 100) {\n    for (let i = 1; i <= count; i++) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n        yield i;\n    }\n}\n\nasync function demonstrateAsyncGenerators() {\n    console.log(\"\\nüìù Example 6: Async Generators\");\n    \n    console.log(\"Generating numbers asynchronously:\");\n    for await (const num of asyncNumberGenerator(5, 200)) {\n        console.log(\"Generated:\", num);\n    }\n}\n\n// Example 8: Parallel Processing with Worker-like Pattern\nasync function processInParallel(items, processor, concurrency = 3) {\n    const results = [];\n    const executing = [];\n    \n    for (const item of items) {\n        const promise = processor(item).then(result => {\n            results.push(result);\n            return result;\n        });\n        \n        executing.push(promise);\n        \n        if (executing.length >= concurrency) {\n            await Promise.race(executing);\n            executing.splice(executing.findIndex(p => p === promise), 1);\n        }\n    }\n    \n    await Promise.all(executing);\n    return results;\n}\n\nasync function demonstrateParallelProcessing() {\n    console.log(\"\\nüìù Example 7: Parallel Processing with Concurrency Control\");\n    \n    const items = [1, 2, 3, 4, 5, 6, 7, 8];\n    const processor = async (item) => {\n        await new Promise(resolve => setTimeout(resolve, 200));\n        return item * 2;\n    };\n    \n    const startTime = Date.now();\n    const results = await processInParallel(items, processor, 3);\n    const endTime = Date.now();\n    \n    console.log(\"Processed results:\", results);\n    console.log(\"Processing time:\", endTime - startTime + \"ms\");\n    console.log(\"(Should be ~400-600ms with concurrency=3, not 1600ms)\");\n}\n\n// Example 9: Error Handling Patterns\nasync function demonstrateErrorHandling() {\n    console.log(\"\\nüìù Example 8: Advanced Error Handling\");\n    \n    // Pattern 1: Try-catch with specific error types\n    class NetworkError extends Error {\n        constructor(message) {\n            super(message);\n            this.name = 'NetworkError';\n        }\n    }\n    \n    class ValidationError extends Error {\n        constructor(message) {\n            super(message);\n            this.name = 'ValidationError';\n        }\n    }\n    \n    async function riskyOperation(scenario) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n        \n        switch (scenario) {\n            case 'network':\n                throw new NetworkError('Network connection failed');\n            case 'validation':\n                throw new ValidationError('Invalid input data');\n            case 'success':\n                return 'Operation successful';\n            default:\n                throw new Error('Unknown error');\n        }\n    }\n    \n    const scenarios = ['success', 'network', 'validation', 'unknown'];\n    \n    for (const scenario of scenarios) {\n        try {\n            const result = await riskyOperation(scenario);\n            console.log(`‚úÖ ${scenario}:`, result);\n        } catch (error) {\n            if (error instanceof NetworkError) {\n                console.log(`üåê Network error for ${scenario}:`, error.message);\n            } else if (error instanceof ValidationError) {\n                console.log(`‚ö†Ô∏è  Validation error for ${scenario}:`, error.message);\n            } else {\n                console.log(`‚ùå Unknown error for ${scenario}:`, error.message);\n            }\n        }\n    }\n}\n\n// Run all demonstrations\nasync function runAllDemonstrations() {\n    await demonstrateAsyncAwait();\n    await demonstratePromiseAll();\n    await demonstratePromiseAllSettled();\n    await demonstratePromiseRace();\n    await demonstrateRetryPattern();\n    await demonstrateAsyncGenerators();\n    await demonstrateParallelProcessing();\n    await demonstrateErrorHandling();\n    \n    console.log(\"\\n\" + \"=\".repeat(60));\n    console.log(\"üéØ ALL ASYNC PATTERNS DEMONSTRATED!\");\n    console.log(\"=\".repeat(60));\n}\n\n// Execute all examples\nrunAllDemonstrations().catch(console.error);\n\n// üíº CAREER SUCCESS METRICS\nsetTimeout(() => {\n    console.log(`\\nüíº ASYNC/AWAIT MASTERY CAREER IMPACT:`);\n    console.log(\"üèÜ Essential for all modern JavaScript roles\");\n    console.log(\"üèÜ Required for React, Vue, Angular development\");\n    console.log(\"üèÜ Critical for Node.js backend work\");\n    console.log(\"üèÜ Foundation for API integration\");\n    console.log(\"üèÜ Separates senior from junior developers\");\n\n    // üöÄ INTERVIEW MASTERY TIPS\n    console.log(`\\nüöÄ ASYNC INTERVIEW SUCCESS STRATEGIES:`);\n    console.log(\"1. ‚ö° Explain event loop and call stack\");\n    console.log(\"2. ‚ö° Know Promise states: pending, fulfilled, rejected\");\n    console.log(\"3. ‚ö° Understand Promise.all vs Promise.allSettled vs Promise.race\");\n    console.log(\"4. ‚ö° Demonstrate error handling patterns\");\n    console.log(\"5. ‚ö° Show concurrency vs parallelism understanding\");\n    console.log(\"6. ‚ö° Explain async/await vs .then() tradeoffs\");\n\n    // üéØ COMMON INTERVIEW QUESTIONS\n    console.log(`\\nüéØ COMMON ASYNC INTERVIEW QUESTIONS:`);\n    console.log(\"‚Ä¢ Explain the JavaScript event loop\");\n    console.log(\"‚Ä¢ Difference between Promise.all and Promise.allSettled\");\n    console.log(\"‚Ä¢ How to handle multiple async operations concurrently\");\n    console.log(\"‚Ä¢ Implement a retry mechanism with exponential backoff\");\n    console.log(\"‚Ä¢ How to cancel a Promise or async operation\");\n    console.log(\"‚Ä¢ What are async generators and when to use them\");\n\n    console.log(\"\\n\" + \"=\".repeat(60));\n    console.log(\"‚≠ê ASYNC MASTERY = MODERN JAVASCRIPT EXPERT!\");\n    console.log(\"‚≠ê This knowledge is essential for 99% of JS roles!\");\n    console.log(\"=\".repeat(60));\n}, 1000);\n```\n\n## Challenge 8: FizzBuzz Variations ‚≠ê‚≠ê\n\n**‚ö° Interview Frequency: HIGH** | **Companies: Entry-level to senior positions**\n\n**Problem:** Print numbers 1-100, but print \"Fizz\" for multiples of 3, \"Buzz\" for multiples of 5, and \"FizzBuzz\" for multiples of both.\n\n**Career Impact:** Tests basic programming logic and problem-solving creativity!\n\n```python\n// Solution for Challenge 8: FizzBuzz Variations - JAVASCRIPT STYLE!\n\nconsole.log(\"üéØ FIZZBUZZ VARIATIONS - CREATIVE PROBLEM SOLVING!\");\nconsole.log(\"=\".repeat(60));\n\n// Method 1: Classic approach\nfunction fizzBuzzClassic(n = 100) {\n    const result = [];\n    \n    for (let i = 1; i <= n; i++) {\n        if (i % 15 === 0) {\n            result.push(\"FizzBuzz\");\n        } else if (i % 3 === 0) {\n            result.push(\"Fizz\");\n        } else if (i % 5 === 0) {\n            result.push(\"Buzz\");\n        } else {\n            result.push(i);\n        }\n    }\n    \n    return result;\n}\n\n// Method 2: String concatenation approach\nfunction fizzBuzzConcat(n = 100) {\n    const result = [];\n    \n    for (let i = 1; i <= n; i++) {\n        let output = \"\";\n        \n        if (i % 3 === 0) output += \"Fizz\";\n        if (i % 5 === 0) output += \"Buzz\";\n        \n        result.push(output || i);\n    }\n    \n    return result;\n}\n\n// Method 3: Functional programming approach\nfunction fizzBuzzFunctional(n = 100) {\n    return Array.from({ length: n }, (_, i) => {\n        const num = i + 1;\n        return (num % 15 === 0 && \"FizzBuzz\") ||\n               (num % 3 === 0 && \"Fizz\") ||\n               (num % 5 === 0 && \"Buzz\") ||\n               num;\n    });\n}\n\n// Method 4: Object-driven approach (extensible)\nfunction fizzBuzzConfigurable(n = 100, rules = { 3: \"Fizz\", 5: \"Buzz\" }) {\n    return Array.from({ length: n }, (_, i) => {\n        const num = i + 1;\n        const output = Object.entries(rules)\n            .filter(([divisor]) => num % divisor === 0)\n            .map(([, word]) => word)\n            .join(\"\");\n        \n        return output || num;\n    });\n}\n\n// Method 5: Generator approach\nfunction* fizzBuzzGenerator(n = 100) {\n    for (let i = 1; i <= n; i++) {\n        if (i % 15 === 0) yield \"FizzBuzz\";\n        else if (i % 3 === 0) yield \"Fizz\";\n        else if (i % 5 === 0) yield \"Buzz\";\n        else yield i;\n    }\n}\n\n// Method 6: One-liner (show-off approach)\nconst fizzBuzzOneLiner = (n = 100) => \n    [...Array(n)].map((_, i) => \n        (++i % 15 === 0 && \"FizzBuzz\") || \n        (i % 3 === 0 && \"Fizz\") || \n        (i % 5 === 0 && \"Buzz\") || \n        i\n    );\n\n// Method 7: Class-based approach\nclass FizzBuzzGame {\n    constructor(rules = { 3: \"Fizz\", 5: \"Buzz\" }) {\n        this.rules = rules;\n    }\n    \n    play(n = 100) {\n        return Array.from({ length: n }, (_, i) => {\n            const num = i + 1;\n            return this.evaluateNumber(num);\n        });\n    }\n    \n    evaluateNumber(num) {\n        const output = Object.entries(this.rules)\n            .filter(([divisor]) => num % divisor === 0)\n            .map(([, word]) => word)\n            .join(\"\");\n        \n        return output || num;\n    }\n    \n    addRule(divisor, word) {\n        this.rules[divisor] = word;\n        return this;\n    }\n}\n\n// Test all methods\nconsole.log(\"\\nüìù Testing FizzBuzz Methods (first 20 numbers):\");\n\nconst testMethods = [\n    { name: \"Classic\", func: fizzBuzzClassic },\n    { name: \"Concatenation\", func: fizzBuzzConcat },\n    { name: \"Functional\", func: fizzBuzzFunctional },\n    { name: \"Configurable\", func: fizzBuzzConfigurable },\n    { name: \"Generator\", func: (n) => [...fizzBuzzGenerator(n)] },\n    { name: \"One-liner\", func: fizzBuzzOneLiner }\n];\n\ntestMethods.forEach(({ name, func }) => {\n    const result = func(20);\n    console.log(`${name}: [${result.slice(0, 20).join(', ')}]`);\n});\n\n// Test class-based approach\nconst game = new FizzBuzzGame();\nconsole.log(`Class-based: [${game.play(20).join(', ')}]`);\n\n// Extended FizzBuzz with more rules\nconsole.log(\"\\nüìù Extended FizzBuzz with Multiple Rules:\");\nconst extendedRules = { 3: \"Fizz\", 5: \"Buzz\", 7: \"Pop\" };\nconst extendedResult = fizzBuzzConfigurable(35, extendedRules);\nconsole.log(\"Extended (1-35):\", extendedResult.slice(0, 35));\n\n// Performance comparison\nconsole.log(\"\\nüìù Performance Comparison (n=100000):\");\nconst n = 100000;\n\ntestMethods.forEach(({ name, func }) => {\n    const start = performance.now();\n    func(n);\n    const end = performance.now();\n    console.log(`${name}: ${(end - start).toFixed(2)}ms`);\n});\n\n// Creative variations\nconsole.log(\"\\nüìù Creative FizzBuzz Variations:\");\n\n// Variation 1: Reverse FizzBuzz\nfunction reverseFizzBuzz(n = 20) {\n    return Array.from({ length: n }, (_, i) => {\n        const num = n - i;\n        return (num % 15 === 0 && \"FizzBuzz\") ||\n               (num % 3 === 0 && \"Fizz\") ||\n               (num % 5 === 0 && \"Buzz\") ||\n               num;\n    });\n}\n\nconsole.log(\"Reverse FizzBuzz:\", reverseFizzBuzz(20));\n\n// Variation 2: Prime FizzBuzz\nfunction isPrime(n) {\n    if (n < 2) return false;\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) return false;\n    }\n    return true;\n}\n\nfunction primeFizzBuzz(n = 30) {\n    return Array.from({ length: n }, (_, i) => {\n        const num = i + 1;\n        if (isPrime(num)) return \"Prime\";\n        return (num % 15 === 0 && \"FizzBuzz\") ||\n               (num % 3 === 0 && \"Fizz\") ||\n               (num % 5 === 0 && \"Buzz\") ||\n               num;\n    });\n}\n\nconsole.log(\"Prime FizzBuzz:\", primeFizzBuzz(30));\n\n// Variation 3: Fibonacci FizzBuzz\nfunction fibonacciFizzBuzz(n = 25) {\n    const fib = [0, 1];\n    while (fib[fib.length - 1] < n) {\n        fib.push(fib[fib.length - 1] + fib[fib.length - 2]);\n    }\n    const fibSet = new Set(fib);\n    \n    return Array.from({ length: n }, (_, i) => {\n        const num = i + 1;\n        if (fibSet.has(num)) return \"Fib\";\n        return (num % 15 === 0 && \"FizzBuzz\") ||\n               (num % 3 === 0 && \"Fizz\") ||\n               (num % 5 === 0 && \"Buzz\") ||\n               num;\n    });\n}\n\nconsole.log(\"Fibonacci FizzBuzz:\", fibonacciFizzBuzz(25));\n\n// üíº CAREER SUCCESS METRICS\nconsole.log(`\\nüíº FIZZBUZZ MASTERY CAREER IMPACT:`);\nconsole.log(\"üèÜ Tests fundamental programming logic\");\nconsole.log(\"üèÜ Shows creativity and problem-solving\");\nconsole.log(\"üèÜ Demonstrates code organization skills\");\nconsole.log(\"üèÜ Gateway to more complex problems\");\nconsole.log(\"üèÜ Often used as warm-up in interviews\");\n\n// üöÄ JAVASCRIPT INTERVIEW TIPS\nconsole.log(`\\nüöÄ FIZZBUZZ JAVASCRIPT INTERVIEW TIPS:`);\nconsole.log(\"1. ‚ö° Start with classic approach, then optimize\");\nconsole.log(\"2. ‚ö° Show multiple solutions (functional, OOP, etc.)\");\nconsole.log(\"3. ‚ö° Discuss extensibility and maintainability\");\nconsole.log(\"4. ‚ö° Use modern JS features appropriately\");\nconsole.log(\"5. ‚ö° Consider performance for large inputs\");\nconsole.log(\"6. ‚ö° Handle edge cases (n=0, negative numbers)\");\n\n// üéØ FOLLOW-UP VARIATIONS\nconsole.log(`\\nüéØ COMMON FIZZBUZZ FOLLOW-UPS:`);\nconsole.log(\"‚Ä¢ Add more rules (e.g., 7 -> 'Pop')\");\nconsole.log(\"‚Ä¢ Make it configurable/extensible\");\nconsole.log(\"‚Ä¢ Reverse the sequence\");\nconsole.log(\"‚Ä¢ Handle different number ranges\");\nconsole.log(\"‚Ä¢ Optimize for very large numbers\");\nconsole.log(\"‚Ä¢ Implement without using modulo operator\");\n\nconsole.log(\"\\n\" + \"=\".repeat(60));\nconsole.log(\"‚≠ê FIZZBUZZ MASTERY: Simple problem, multiple solutions!\");\nconsole.log(\"‚≠ê Perfect for demonstrating JavaScript versatility!\");\nconsole.log(\"=\".repeat(60));\n```\n\n## Challenge 9: Palindrome Checker ‚≠ê‚≠ê\n\n**‚ö° Interview Frequency: HIGH** | **Companies: String manipulation interviews**\n\n**Problem:** Check if a string reads the same forwards and backwards, ignoring spaces, punctuation, and case.\n\n**Example:**\n```javascript\nInput: \"A man a plan a canal Panama\"\nOutput: true\n```\n\n**Career Impact:** Tests string manipulation and optimization skills!\n\n```python\n// Solution for Challenge 9: Palindrome Checker - STRING MASTERY!\n\nconsole.log(\"üéØ PALINDROME CHECKER - STRING MANIPULATION EXCELLENCE!\");\nconsole.log(\"=\".repeat(65));\n\n// Method 1: Two-pointer approach (OPTIMAL)\nfunction isPalindromeOptimal(s) {\n    /**\n     * Two-pointer approach - O(n) time, O(1) space\n     * Most efficient solution for interviews!\n     */\n    if (!s) return true;\n    \n    // Clean the string: only alphanumeric, lowercase\n    const cleanStr = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    \n    let left = 0;\n    let right = cleanStr.length - 1;\n    \n    while (left < right) {\n        if (cleanStr[left] !== cleanStr[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\n// Method 2: Reverse and compare\nfunction isPalindromeReverse(s) {\n    if (!s) return true;\n    \n    const cleanStr = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    const reversed = cleanStr.split('').reverse().join('');\n    \n    return cleanStr === reversed;\n}\n\n// Method 3: Recursive approach\nfunction isPalindromeRecursive(s) {\n    function helper(str, left, right) {\n        if (left >= right) return true;\n        \n        if (str[left] !== str[right]) return false;\n        \n        return helper(str, left + 1, right - 1);\n    }\n    \n    if (!s) return true;\n    const cleanStr = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    return helper(cleanStr, 0, cleanStr.length - 1);\n}\n\n// Method 4: Functional programming approach\nfunction isPalindromeFunctional(s) {\n    if (!s) return true;\n    \n    const chars = s.toLowerCase()\n        .split('')\n        .filter(char => /[a-z0-9]/.test(char));\n    \n    return chars.every((char, index) => \n        char === chars[chars.length - 1 - index]\n    );\n}\n\n// Method 5: Using Array.from with comparison\nfunction isPalindromeArrayFrom(s) {\n    if (!s) return true;\n    \n    const cleanStr = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    const chars = Array.from(cleanStr);\n    \n    return chars.join('') === chars.reverse().join('');\n}\n\n// Method 6: Regular expression approach\nfunction isPalindromeRegex(s) {\n    if (!s) return true;\n    \n    const alphaNum = s.replace(/[^A-Za-z0-9]/g, '').toLowerCase();\n    \n    return alphaNum === alphaNum.split('').reverse().join('');\n}\n\n// Method 7: Generator approach (memory efficient)\nfunction* getCharsReversed(s) {\n    const cleanStr = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    for (let i = cleanStr.length - 1; i >= 0; i--) {\n        yield cleanStr[i];\n    }\n}\n\nfunction isPalindromeGenerator(s) {\n    if (!s) return true;\n    \n    const cleanStr = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    const reversedGen = getCharsReversed(s);\n    \n    for (let i = 0; i < cleanStr.length; i++) {\n        const { value } = reversedGen.next();\n        if (cleanStr[i] !== value) return false;\n    }\n    \n    return true;\n}\n\n// üéØ COMPREHENSIVE TEST CASES\nconst testCases = [\n    // Basic cases\n    { input: \"racecar\", expected: true, description: \"Simple palindrome\" },\n    { input: \"race a car\", expected: false, description: \"Not a palindrome\" },\n    { input: \"A man a plan a canal Panama\", expected: true, description: \"Classic example\" },\n    \n    // Edge cases\n    { input: \"\", expected: true, description: \"Empty string\" },\n    { input: \"a\", expected: true, description: \"Single character\" },\n    { input: \"Aa\", expected: true, description: \"Case insensitive\" },\n    \n    // Special characters\n    { input: \"race a e-car\", expected: false, description: \"With special chars\" },\n    { input: \"A Santa at NASA\", expected: true, description: \"Spaces and case\" },\n    { input: \"Was it a car or a cat I saw?\", expected: true, description: \"Complex palindrome\" },\n    \n    // Numbers and mixed\n    { input: \"No 'x' in Nixon\", expected: true, description: \"With apostrophe\" },\n    { input: \"Mr. Owl ate my metal worm\", expected: true, description: \"Long palindrome\" },\n    { input: \"1234321\", expected: true, description: \"Numeric palindrome\" },\n    { input: \"12345\", expected: false, description: \"Not numeric palindrome\" }\n];\n\nconsole.log(\"\\nüìù Testing Palindrome Methods:\");\n\nconst methods = [\n    { name: \"Two-pointer (Optimal)\", func: isPalindromeOptimal },\n    { name: \"Reverse & Compare\", func: isPalindromeReverse },\n    { name: \"Recursive\", func: isPalindromeRecursive },\n    { name: \"Functional\", func: isPalindromeFunctional },\n    { name: \"Array.from\", func: isPalindromeArrayFrom },\n    { name: \"Regex\", func: isPalindromeRegex },\n    { name: \"Generator\", func: isPalindromeGenerator }\n];\n\ntestCases.forEach((test, i) => {\n    console.log(`\\nTest ${i + 1}: ${test.description}`);\n    console.log(`Input: \"${test.input}\"`);\n    console.log(`Expected: ${test.expected}`);\n    \n    let allCorrect = true;\n    \n    methods.forEach(({ name, func }) => {\n        try {\n            const result = func(test.input);\n            const isCorrect = result === test.expected;\n            \n            if (!isCorrect) allCorrect = false;\n            \n            console.log(`  ${name}: ${result} ${isCorrect ? '‚úÖ' : '‚ùå'}`);\n        } catch (error) {\n            console.log(`  ${name}: Error - ${error.message} ‚ùå`);\n            allCorrect = false;\n        }\n    });\n    \n    console.log(`‚úÖ All methods correct: ${allCorrect}`);\n});\n\n// üéØ PERFORMANCE COMPARISON\nconsole.log(`\\nüìù Performance Comparison (large palindromes):`);\n\n// Create large palindromes for testing\nconst createLargePalindrome = (size) => {\n    const half = 'a'.repeat(size / 2);\n    return half + (size % 2 ? 'x' : '') + half.split('').reverse().join('');\n};\n\nconst largePalindrome = createLargePalindrome(10000);\n\nmethods.forEach(({ name, func }) => {\n    const start = performance.now();\n    const result = func(largePalindrome);\n    const end = performance.now();\n    \n    console.log(`${name}: ${(end - start).toFixed(3)}ms (result: ${result})`);\n});\n\n// Advanced Palindrome Variations\nconsole.log(`\\nüìù Advanced Palindrome Variations:`);\n\n// Variation 1: Longest Palindromic Substring\nfunction longestPalindromicSubstring(s) {\n    if (!s) return \"\";\n    \n    let longest = \"\";\n    \n    function expandAroundCenter(left, right) {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            const current = s.substring(left, right + 1);\n            if (current.length > longest.length) {\n                longest = current;\n            }\n            left--;\n            right++;\n        }\n    }\n    \n    for (let i = 0; i < s.length; i++) {\n        expandAroundCenter(i, i);     // Odd length palindromes\n        expandAroundCenter(i, i + 1); // Even length palindromes\n    }\n    \n    return longest;\n}\n\nconsole.log(\"Longest palindromic substring in 'babad':\", \n    longestPalindromicSubstring(\"babad\"));\nconsole.log(\"Longest palindromic substring in 'raceacar':\", \n    longestPalindromicSubstring(\"raceacar\"));\n\n// Variation 2: Valid Palindrome with One Deletion\nfunction validPalindromeOneDelete(s) {\n    function isPalindrome(str, left, right) {\n        while (left < right) {\n            if (str[left] !== str[right]) return false;\n            left++;\n            right--;\n        }\n        return true;\n    }\n    \n    let left = 0, right = s.length - 1;\n    \n    while (left < right) {\n        if (s[left] !== s[right]) {\n            // Try deleting left character or right character\n            return isPalindrome(s, left + 1, right) || \n                   isPalindrome(s, left, right - 1);\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nconsole.log(\"Valid palindrome with one deletion 'raceacar':\", \n    validPalindromeOneDelete(\"raceacar\"));\nconsole.log(\"Valid palindrome with one deletion 'abcddcbea':\", \n    validPalindromeOneDelete(\"abcddcbea\"));\n\n// üíº CAREER SUCCESS METRICS\nconsole.log(`\\nüíº PALINDROME MASTERY CAREER IMPACT:`);\nconsole.log(\"üèÜ Tests string manipulation skills\");\nconsole.log(\"üèÜ Demonstrates algorithm optimization\");\nconsole.log(\"üèÜ Shows edge case handling\");\nconsole.log(\"üèÜ Foundation for complex string problems\");\nconsole.log(\"üèÜ Common in technical screenings\");\n\n// üöÄ JAVASCRIPT INTERVIEW TIPS\nconsole.log(`\\nüöÄ PALINDROME JAVASCRIPT INTERVIEW TIPS:`);\nconsole.log(\"1. ‚ö° Know string methods: split, reverse, join\");\nconsole.log(\"2. ‚ö° Understand regex for cleaning input\");\nconsole.log(\"3. ‚ö° Use two-pointer technique for efficiency\");\nconsole.log(\"4. ‚ö° Handle case sensitivity and special characters\");\nconsole.log(\"5. ‚ö° Consider space complexity implications\");\nconsole.log(\"6. ‚ö° Be ready for variations and follow-ups\");\n\n// üéØ FOLLOW-UP QUESTIONS\nconsole.log(`\\nüéØ COMMON PALINDROME FOLLOW-UPS:`);\nconsole.log(\"‚Ä¢ Find longest palindromic substring\");\nconsole.log(\"‚Ä¢ Valid palindrome with one character deletion\");\nconsole.log(\"‚Ä¢ Count all palindromic substrings\");\nconsole.log(\"‚Ä¢ Palindrome partitioning\");\nconsole.log(\"‚Ä¢ Shortest palindrome (add characters to front)\");\nconsole.log(\"‚Ä¢ Case-sensitive palindrome checking\");\n\nconsole.log(\"\\n\" + \"=\".repeat(65));\nconsole.log(\"‚≠ê PALINDROME MASTERY: String manipulation excellence!\");\nconsole.log(\"‚≠ê Perfect for demonstrating algorithm thinking!\");\nconsole.log(\"=\".repeat(65));\n```\n\n## Challenge 10: Binary Tree Operations ‚≠ê‚≠ê‚≠ê\n\n**‚ö° Interview Frequency: EXTREMELY HIGH** | **Companies: All major tech companies**\n\n**Problem:** Implement various binary tree operations including traversals, search, and manipulation.\n\n**Example:**\n```javascript\nTree:     3\n         / \\\n        9   20\n           /  \\\n          15   7\n```\n\n**Career Impact:** Tree problems are fundamental to computer science and appear in 80%+ of technical interviews!\n\n```python\n// Solution for Challenge 10: Binary Tree Operations - TREE MASTERY!\n\nconsole.log(\"üéØ BINARY TREE OPERATIONS - DATA STRUCTURE EXCELLENCE!\");\nconsole.log(\"=\".repeat(65));\n\n// TreeNode class definition\nclass TreeNode {\n    constructor(val = 0, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n    \n    toString() {\n        return `TreeNode(${this.val})`;\n    }\n}\n\n// Tree Operations Class\nclass BinaryTree {\n    constructor(root = null) {\n        this.root = root;\n    }\n    \n    // Method 1: In-order Traversal (Left, Root, Right)\n    inorderTraversal(node = this.root) {\n        const result = [];\n        \n        function traverse(node) {\n            if (!node) return;\n            \n            traverse(node.left);\n            result.push(node.val);\n            traverse(node.right);\n        }\n        \n        traverse(node);\n        return result;\n    }\n    \n    // Method 2: Pre-order Traversal (Root, Left, Right)\n    preorderTraversal(node = this.root) {\n        const result = [];\n        \n        function traverse(node) {\n            if (!node) return;\n            \n            result.push(node.val);\n            traverse(node.left);\n            traverse(node.right);\n        }\n        \n        traverse(node);\n        return result;\n    }\n    \n    // Method 3: Post-order Traversal (Left, Right, Root)\n    postorderTraversal(node = this.root) {\n        const result = [];\n        \n        function traverse(node) {\n            if (!node) return;\n            \n            traverse(node.left);\n            traverse(node.right);\n            result.push(node.val);\n        }\n        \n        traverse(node);\n        return result;\n    }\n    \n    // Method 4: Level Order Traversal (BFS)\n    levelOrderTraversal(node = this.root) {\n        if (!node) return [];\n        \n        const result = [];\n        const queue = [node];\n        \n        while (queue.length > 0) {\n            const levelSize = queue.length;\n            const currentLevel = [];\n            \n            for (let i = 0; i < levelSize; i++) {\n                const current = queue.shift();\n                currentLevel.push(current.val);\n                \n                if (current.left) queue.push(current.left);\n                if (current.right) queue.push(current.right);\n            }\n            \n            result.push(currentLevel);\n        }\n        \n        return result;\n    }\n    \n    // Method 5: Maximum Depth\n    maxDepth(node = this.root) {\n        if (!node) return 0;\n        \n        const leftDepth = this.maxDepth(node.left);\n        const rightDepth = this.maxDepth(node.right);\n        \n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n    \n    // Method 6: Minimum Depth\n    minDepth(node = this.root) {\n        if (!node) return 0;\n        \n        if (!node.left && !node.right) return 1;\n        \n        if (!node.left) return this.minDepth(node.right) + 1;\n        if (!node.right) return this.minDepth(node.left) + 1;\n        \n        return Math.min(this.minDepth(node.left), this.minDepth(node.right)) + 1;\n    }\n    \n    // Method 7: Tree Height (same as max depth)\n    height(node = this.root) {\n        return this.maxDepth(node);\n    }\n    \n    // Method 8: Check if tree is balanced\n    isBalanced(node = this.root) {\n        function checkBalance(node) {\n            if (!node) return 0;\n            \n            const leftHeight = checkBalance(node.left);\n            if (leftHeight === -1) return -1;\n            \n            const rightHeight = checkBalance(node.right);\n            if (rightHeight === -1) return -1;\n            \n            if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n            \n            return Math.max(leftHeight, rightHeight) + 1;\n        }\n        \n        return checkBalance(node) !== -1;\n    }\n    \n    // Method 9: Invert/Mirror the tree\n    invertTree(node = this.root) {\n        if (!node) return null;\n        \n        // Swap left and right children\n        [node.left, node.right] = [node.right, node.left];\n        \n        // Recursively invert subtrees\n        this.invertTree(node.left);\n        this.invertTree(node.right);\n        \n        return node;\n    }\n    \n    // Method 10: Check if two trees are identical\n    isSameTree(p, q) {\n        if (!p && !q) return true;\n        if (!p || !q) return false;\n        \n        return p.val === q.val && \n               this.isSameTree(p.left, q.left) && \n               this.isSameTree(p.right, q.right);\n    }\n    \n    // Method 11: Find all paths from root to leaves\n    rootToLeafPaths(node = this.root) {\n        const paths = [];\n        \n        function findPaths(node, currentPath) {\n            if (!node) return;\n            \n            currentPath.push(node.val);\n            \n            // If leaf node, add path to results\n            if (!node.left && !node.right) {\n                paths.push([...currentPath]);\n            } else {\n                findPaths(node.left, currentPath);\n                findPaths(node.right, currentPath);\n            }\n            \n            currentPath.pop(); // Backtrack\n        }\n        \n        findPaths(node, []);\n        return paths;\n    }\n    \n    // Method 12: Zigzag Level Order Traversal\n    zigzagLevelOrder(node = this.root) {\n        if (!node) return [];\n        \n        const result = [];\n        const queue = [node];\n        let leftToRight = true;\n        \n        while (queue.length > 0) {\n            const levelSize = queue.length;\n            const currentLevel = [];\n            \n            for (let i = 0; i < levelSize; i++) {\n                const current = queue.shift();\n                \n                if (leftToRight) {\n                    currentLevel.push(current.val);\n                } else {\n                    currentLevel.unshift(current.val);\n                }\n                \n                if (current.left) queue.push(current.left);\n                if (current.right) queue.push(current.right);\n            }\n            \n            result.push(currentLevel);\n            leftToRight = !leftToRight;\n        }\n        \n        return result;\n    }\n}\n\n// Helper function to build tree from array\nfunction buildTreeFromArray(arr) {\n    if (!arr || arr.length === 0) return null;\n    \n    const root = new TreeNode(arr[0]);\n    const queue = [root];\n    let i = 1;\n    \n    while (queue.length > 0 && i < arr.length) {\n        const node = queue.shift();\n        \n        // Left child\n        if (i < arr.length && arr[i] !== null) {\n            node.left = new TreeNode(arr[i]);\n            queue.push(node.left);\n        }\n        i++;\n        \n        // Right child\n        if (i < arr.length && arr[i] !== null) {\n            node.right = new TreeNode(arr[i]);\n            queue.push(node.right);\n        }\n        i++;\n    }\n    \n    return root;\n}\n\n// üéØ COMPREHENSIVE TESTING\nconsole.log(\"\\nüìù Testing Binary Tree Operations:\");\n\n// Test tree: [3, 9, 20, null, null, 15, 7]\n//       3\n//      / \\\n//     9   20\n//        /  \\\n//       15   7\n\nconst testArray = [3, 9, 20, null, null, 15, 7];\nconst root = buildTreeFromArray(testArray);\nconst tree = new BinaryTree(root);\n\nconsole.log(\"\\nTree structure: [3, 9, 20, null, null, 15, 7]\");\nconsole.log(\"Visual:\");\nconsole.log(\"       3\");\nconsole.log(\"      / \\\\\");\nconsole.log(\"     9   20\");\nconsole.log(\"        /  \\\\\");\nconsole.log(\"       15   7\");\n\n// Test all traversal methods\nconsole.log(\"\\nüìù Tree Traversals:\");\nconsole.log(\"In-order (Left, Root, Right):\", tree.inorderTraversal());\nconsole.log(\"Pre-order (Root, Left, Right):\", tree.preorderTraversal());\nconsole.log(\"Post-order (Left, Right, Root):\", tree.postorderTraversal());\nconsole.log(\"Level-order (BFS):\", tree.levelOrderTraversal());\nconsole.log(\"Zigzag Level Order:\", tree.zigzagLevelOrder());\n\n// Test tree properties\nconsole.log(\"\\nüìù Tree Properties:\");\nconsole.log(\"Maximum Depth:\", tree.maxDepth());\nconsole.log(\"Minimum Depth:\", tree.minDepth());\nconsole.log(\"Height:\", tree.height());\nconsole.log(\"Is Balanced:\", tree.isBalanced());\n\n// Test tree operations\nconsole.log(\"\\nüìù Tree Operations:\");\nconst paths = tree.rootToLeafPaths();\nconsole.log(\"Root to Leaf Paths:\", paths);\n\n// Test tree comparison\nconst tree2Array = [3, 9, 20, null, null, 15, 7];\nconst root2 = buildTreeFromArray(tree2Array);\nconst tree2 = new BinaryTree(root2);\nconsole.log(\"Trees are identical:\", tree.isSameTree(tree.root, tree2.root));\n\n// Test with different tree structures\nconsole.log(\"\\nüìù Testing Different Tree Structures:\");\n\nconst testCases = [\n    {\n        name: \"Complete Binary Tree\",\n        array: [1, 2, 3, 4, 5, 6, 7],\n        description: \"All levels filled\"\n    },\n    {\n        name: \"Left Skewed Tree\",\n        array: [1, 2, null, 3, null, 4],\n        description: \"Only left children\"\n    },\n    {\n        name: \"Right Skewed Tree\", \n        array: [1, null, 2, null, 3, null, 4],\n        description: \"Only right children\"\n    },\n    {\n        name: \"Single Node\",\n        array: [42],\n        description: \"Just root\"\n    },\n    {\n        name: \"Empty Tree\",\n        array: [],\n        description: \"No nodes\"\n    }\n];\n\ntestCases.forEach(({ name, array, description }) => {\n    console.log(`\\n${name} (${description}):`);\n    const testRoot = buildTreeFromArray(array);\n    const testTree = new BinaryTree(testRoot);\n    \n    console.log(`  Array: [${array.join(', ')}]`);\n    console.log(`  Level Order: ${JSON.stringify(testTree.levelOrderTraversal())}`);\n    console.log(`  Max Depth: ${testTree.maxDepth()}`);\n    console.log(`  Is Balanced: ${testTree.isBalanced()}`);\n    console.log(`  Paths: ${JSON.stringify(testTree.rootToLeafPaths())}`);\n});\n\n// üéØ ITERATIVE IMPLEMENTATIONS\nconsole.log(\"\\nüìù Iterative Implementations:\");\n\n// Iterative In-order Traversal\nfunction inorderIterative(root) {\n    const result = [];\n    const stack = [];\n    let current = root;\n    \n    while (current || stack.length > 0) {\n        while (current) {\n            stack.push(current);\n            current = current.left;\n        }\n        \n        current = stack.pop();\n        result.push(current.val);\n        current = current.right;\n    }\n    \n    return result;\n}\n\n// Iterative Pre-order Traversal\nfunction preorderIterative(root) {\n    if (!root) return [];\n    \n    const result = [];\n    const stack = [root];\n    \n    while (stack.length > 0) {\n        const node = stack.pop();\n        result.push(node.val);\n        \n        if (node.right) stack.push(node.right);\n        if (node.left) stack.push(node.left);\n    }\n    \n    return result;\n}\n\n// Iterative Post-order Traversal\nfunction postorderIterative(root) {\n    if (!root) return [];\n    \n    const result = [];\n    const stack = [root];\n    \n    while (stack.length > 0) {\n        const node = stack.pop();\n        result.unshift(node.val);\n        \n        if (node.left) stack.push(node.left);\n        if (node.right) stack.push(node.right);\n    }\n    \n    return result;\n}\n\nconsole.log(\"Iterative In-order:\", inorderIterative(root));\nconsole.log(\"Iterative Pre-order:\", preorderIterative(root));\nconsole.log(\"Iterative Post-order:\", postorderIterative(root));\n\n// üíº CAREER SUCCESS METRICS\nconsole.log(`\\nüíº BINARY TREE MASTERY CAREER IMPACT:`);\nconsole.log(\"üèÜ Foundation for 80%+ of tree interview problems\");\nconsole.log(\"üèÜ Required for senior developer positions\");\nconsole.log(\"üèÜ Demonstrates recursive thinking\");\nconsole.log(\"üèÜ Critical for system design (file systems, databases)\");\nconsole.log(\"üèÜ Shows data structure expertise\");\n\n// üöÄ JAVASCRIPT TREE INTERVIEW TIPS\nconsole.log(`\\nüöÄ BINARY TREE JAVASCRIPT INTERVIEW TIPS:`);\nconsole.log(\"1. ‚ö° Master recursive patterns\");\nconsole.log(\"2. ‚ö° Know when to use BFS vs DFS\");\nconsole.log(\"3. ‚ö° Understand iterative implementations\");\nconsole.log(\"4. ‚ö° Handle null/undefined nodes gracefully\");\nconsole.log(\"5. ‚ö° Use destructuring for elegant swaps\");\nconsole.log(\"6. ‚ö° Practice drawing trees to visualize\");\n\n// üéØ COMMON TREE INTERVIEW VARIATIONS\nconsole.log(`\\nüéØ COMMON TREE INTERVIEW VARIATIONS:`);\nconsole.log(\"‚Ä¢ Binary Tree Right Side View\");\nconsole.log(\"‚Ä¢ Lowest Common Ancestor\");\nconsole.log(\"‚Ä¢ Validate Binary Search Tree\");\nconsole.log(\"‚Ä¢ Serialize and Deserialize Binary Tree\");\nconsole.log(\"‚Ä¢ Path Sum and Path Sum II\");\nconsole.log(\"‚Ä¢ Binary Tree Maximum Path Sum\");\nconsole.log(\"‚Ä¢ Convert Sorted Array to Binary Search Tree\");\n\nconsole.log(\"\\n\" + \"=\".repeat(65));\nconsole.log(\"‚≠ê BINARY TREE MASTERY: Data structure excellence!\");\nconsole.log(\"‚≠ê Foundation for countless algorithm problems!\");\nconsole.log(\"=\".repeat(65));\n```\n\n## üéØ Complete JavaScript Challenge Collection Summary\n\n**üèÜ Congratulations! You now have ALL the Python challenges converted to JavaScript plus JavaScript-specific features!**\n\n### üìö **Your Complete JavaScript Arsenal:**\n\n#### **üî• Core Algorithm Challenges:**\n1. **‚úÖ Hello World & Setup** - Modern JS environment and syntax\n2. **‚úÖ Two Sum** - Hash Map mastery with JavaScript objects/Maps\n3. **‚úÖ Valid Parentheses** - Stack operations with arrays\n4. **‚úÖ Maximum Subarray (Kadane's)** - Dynamic programming excellence\n5. **‚úÖ Merge Intervals** - Algorithm design with ES6+ features\n6. **‚úÖ FizzBuzz Variations** - Creative problem solving\n7. **‚úÖ Palindrome Checker** - String manipulation mastery\n8. **‚úÖ Binary Tree Operations** - Data structure excellence\n\n#### **üöÄ JavaScript-Specific Mastery:**\n- **‚úÖ Closures & Scope** - JavaScript fundamentals\n- **‚úÖ Async/Await & Promises** - Modern asynchronous programming\n- **‚úÖ ES6+ Features** - Arrow functions, destructuring, spread operator\n- **‚úÖ Functional Programming** - map, filter, reduce, higher-order functions\n- **‚úÖ Performance Optimization** - Memoization, debouncing\n\n### üíº **Career Impact Achieved:**\n\n**Frontend Developer Ready:**\n- React/Vue/Angular interview preparation ‚úÖ\n- Modern JavaScript proficiency ‚úÖ\n- Asynchronous programming mastery ‚úÖ\n\n**Full-Stack JavaScript Ready:**\n- Node.js backend concepts ‚úÖ\n- API integration patterns ‚úÖ\n- Database interaction foundations ‚úÖ\n\n**Senior JavaScript Engineer Ready:**\n- Algorithm optimization thinking ‚úÖ\n- Code architecture understanding ‚úÖ\n- Performance analysis skills ‚úÖ\n\n### üéØ **Interactive Learning Features:**\n\n- **‚úÖ Runnable code cells** - Execute each challenge individually\n- **‚úÖ Multiple solution approaches** - 4-7 different methods per problem\n- **‚úÖ Real interview test cases** - Based on actual company questions\n- **‚úÖ Performance comparisons** - Understanding time/space complexity\n- **‚úÖ Career success metrics** - Why each problem matters\n- **‚úÖ Follow-up variations** - Ready for extended questions\n\n### üöÄ **Next Level Preparation:**\n\n**For Continued Growth:**\n1. **Practice timing** - Solve each challenge in under 5 minutes\n2. **Explain out loud** - Practice articulating your thought process\n3. **Handle variations** - Be ready for follow-up questions\n4. **Build projects** - Implement these algorithms in real applications\n5. **Contribute to open source** - Showcase your skills\n\n**Advanced Topics to Explore:**\n- **Graph algorithms** (DFS, BFS, shortest path)\n- **Dynamic programming** (memoization, tabulation)\n- **System design** (scalability, performance)\n- **TypeScript** (type safety and modern development)\n\n---\n\n**üéØ You're now equipped with a comprehensive JavaScript interview toolkit that covers both algorithmic thinking AND JavaScript-specific knowledge - the perfect combination for landing your dream job!**\n\n"}