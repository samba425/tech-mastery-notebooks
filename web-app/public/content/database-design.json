{"id":"database-design","title":"üíæ Database Design","content":"# üíæ Database Design & Architecture Guide\n\n**Master database design, normalization, indexing, and scalability**\n\n---\n\n## üìö Table of Contents\n\n1. [Database Fundamentals](#1-database-fundamentals)\n2. [SQL vs NoSQL](#2-sql-vs-nosql)\n3. [Database Normalization](#3-database-normalization)\n4. [Indexing Strategies](#4-indexing-strategies)\n5. [Query Optimization](#5-query-optimization)\n6. [Transactions & ACID](#6-transactions--acid)\n7. [Sharding & Partitioning](#7-sharding--partitioning)\n8. [Replication](#8-replication)\n9. [Real-World Examples](#9-real-world-examples)\n\n---\n\n## 1. Database Fundamentals\n\n### Database Types\n\n**Relational (SQL)**\n- Structure: Tables with rows and columns\n- Schema: Fixed schema\n- Examples: MySQL, PostgreSQL, Oracle, SQL Server\n- Use cases: Banking, E-commerce, ERP systems\n\n**NoSQL**\n\n1. **Key-Value**: Redis, DynamoDB\n   - Use: Caching, session storage\n\n2. **Document**: MongoDB, Firestore\n   - Use: Content management, user profiles\n\n3. **Wide-Column**: Cassandra, HBase, Bigtable\n   - Use: Time-series data, IoT, analytics\n\n4. **Graph**: Neo4j, Amazon Neptune\n   - Use: Social networks, recommendations\n\n**NewSQL**: Google Spanner, CockroachDB\n- Combines SQL with NoSQL scalability\n\n## 2. SQL vs NoSQL\n\n### When to Use SQL\n\n‚úÖ Complex queries with JOINs\n‚úÖ ACID compliance required (banking, finance)\n‚úÖ Fixed schema with clear relationships\n‚úÖ Data integrity critical (foreign keys, constraints)\n\n**Example: E-commerce Schema**\n\n```sql\nCREATE TABLE users (\n    user_id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    name VARCHAR(100),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE products (\n    product_id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    stock INT DEFAULT 0\n);\n\nCREATE TABLE orders (\n    order_id SERIAL PRIMARY KEY,\n    user_id INT REFERENCES users(user_id),\n    total_amount DECIMAL(10, 2),\n    status VARCHAR(50),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE order_items (\n    order_id INT REFERENCES orders(order_id),\n    product_id INT REFERENCES products(product_id),\n    quantity INT NOT NULL,\n    price DECIMAL(10, 2) NOT NULL,\n    PRIMARY KEY (order_id, product_id)\n);\n\n-- Complex JOIN query\nSELECT \n    u.name,\n    COUNT(o.order_id) as total_orders,\n    SUM(o.total_amount) as total_spent\nFROM users u\nJOIN orders o ON u.user_id = o.user_id\nWHERE o.created_at >= NOW() - INTERVAL '30 days'\nGROUP BY u.name\nORDER BY total_spent DESC;\n```\n\n### When to Use NoSQL\n\n‚úÖ Flexible schema (data structure evolves)\n‚úÖ Horizontal scaling (millions of ops/sec)\n‚úÖ Unstructured data (JSON, documents)\n‚úÖ High throughput requirements\n\n**Example: MongoDB Document**\n\n```json\n{\n  \"_id\": \"user123\",\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"profile\": {\n    \"age\": 30,\n    \"location\": \"San Francisco\",\n    \"interests\": [\"coding\", \"music\"]\n  },\n  \"orders\": [\n    {\n      \"order_id\": \"ord1\",\n      \"items\": [\n        {\"product\": \"Laptop\", \"price\": 1200}\n      ],\n      \"total\": 1200,\n      \"date\": \"2024-01-15\"\n    }\n  ]\n}\n```\n\n**Query Example**\n\n```javascript\n// Find users with orders > $1000\ndb.users.find({ \"orders.total\": { $gt: 1000 } })\n\n// Aggregation\ndb.users.aggregate([\n  { $unwind: \"$orders\" },\n  { $group: {\n      _id: \"$_id\",\n      total_spent: { $sum: \"$orders.total\" }\n  }}\n])\n```\n\n## 3. Database Normalization\n\n### Normal Forms\n\n**1NF (First Normal Form)**\n- Each column contains atomic values (no lists)\n- Each row is unique\n- No repeating groups\n\n**2NF (Second Normal Form)**\n- Must be in 1NF\n- All non-key columns depend on entire primary key\n\n**3NF (Third Normal Form)**\n- Must be in 2NF\n- No transitive dependencies\n\n**Example: Unnormalized ‚Üí Normalized**\n\n```sql\n-- ‚ùå BAD (Unnormalized)\nCREATE TABLE orders (\n    order_id INT,\n    customer_name VARCHAR(100),\n    customer_email VARCHAR(100),\n    customer_address TEXT,\n    product_names TEXT,    -- \"Laptop, Mouse\"\n    product_prices TEXT    -- \"1200, 25\"\n);\n\n-- ‚úÖ GOOD (Normalized)\nCREATE TABLE customers (\n    customer_id SERIAL PRIMARY KEY,\n    name VARCHAR(100),\n    email VARCHAR(100),\n    address TEXT\n);\n\nCREATE TABLE products (\n    product_id SERIAL PRIMARY KEY,\n    name VARCHAR(100),\n    price DECIMAL(10,2)\n);\n\nCREATE TABLE orders (\n    order_id SERIAL PRIMARY KEY,\n    customer_id INT REFERENCES customers(customer_id),\n    order_date DATE\n);\n\nCREATE TABLE order_items (\n    order_id INT REFERENCES orders(order_id),\n    product_id INT REFERENCES products(product_id),\n    quantity INT,\n    PRIMARY KEY (order_id, product_id)\n);\n```\n\n## 4. Indexing Strategies\n\n### What is an Index?\n\nIndex = Fast lookup structure (like a book index)\n\n**Without Index**: Full table scan O(n)\n**With Index**: B-tree lookup O(log n)\n\n### Index Types\n\n**1. B-Tree (Default)**\n```sql\nCREATE INDEX idx_created_at ON orders(created_at);\n\n-- Efficient for:\nSELECT * FROM orders WHERE created_at > '2024-01-01';\nSELECT * FROM orders ORDER BY created_at DESC;\n```\n\n**2. Hash Index**\n```sql\nCREATE INDEX idx_user_id USING HASH ON sessions(user_id);\n\n-- Fast for equality:\nSELECT * FROM sessions WHERE user_id = 123;\n\n-- Won't use index:\nSELECT * FROM sessions WHERE user_id > 100;\n```\n\n**3. Composite Index**\n```sql\nCREATE INDEX idx_user_status ON orders(user_id, status);\n\n-- Uses index (left-to-right):\nSELECT * FROM orders WHERE user_id = 123;\nSELECT * FROM orders WHERE user_id = 123 AND status = 'pending';\n\n-- Won't use index:\nSELECT * FROM orders WHERE status = 'pending';\n```\n\n**4. Unique Index**\n```sql\nCREATE UNIQUE INDEX idx_email ON users(email);\n-- Prevents duplicate emails\n```\n\n### Index Best Practices\n\n‚úÖ **DO Index**:\n- Primary keys (automatic)\n- Foreign keys (JOIN columns)\n- WHERE clause columns\n- ORDER BY columns\n- High-cardinality columns\n\n‚ùå **DON'T Index**:\n- Small tables (< 1000 rows)\n- Low-cardinality columns (gender, boolean)\n- Rarely queried columns\n- Frequently updated columns\n\n## 5. Query Optimization\n\n### Slow Query Patterns\n\n```sql\n-- ‚ùå BAD: SELECT *\nSELECT * FROM users WHERE id = 123;\n-- Fetches all columns\n\n-- ‚úÖ GOOD: Select only needed columns\nSELECT id, name, email FROM users WHERE id = 123;\n\n-- ‚ùå BAD: N+1 Query Problem\nSELECT * FROM users;  -- 100 rows\n-- Then for each user:\nSELECT * FROM orders WHERE user_id = 1;  -- 100 queries!\n\n-- ‚úÖ GOOD: Single JOIN\nSELECT u.*, o.*\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id;\n\n-- ‚ùå BAD: Function on indexed column\nSELECT * FROM users WHERE YEAR(created_at) = 2024;\n-- Index not used!\n\n-- ‚úÖ GOOD: Range query\nSELECT * FROM users \nWHERE created_at >= '2024-01-01' \n  AND created_at < '2025-01-01';\n-- Index used!\n\n-- ‚ùå BAD: OR with different columns\nSELECT * FROM users WHERE name = 'John' OR email = 'john@example.com';\n\n-- ‚úÖ GOOD: UNION\nSELECT * FROM users WHERE name = 'John'\nUNION\nSELECT * FROM users WHERE email = 'john@example.com';\n```\n\n### Analyze Queries\n\n```sql\nEXPLAIN ANALYZE \nSELECT * FROM users WHERE email = 'john@example.com';\n\n-- Output shows:\n-- Index Scan using idx_users_email (cost=0.29..8.30)\n-- Seq Scan on users (cost=0.00..1000.00)  ‚Üê No index!\n```\n\n## 6. Transactions & ACID\n\n### ACID Properties\n\n**Atomicity**: All or nothing\n```sql\nBEGIN TRANSACTION;\n\nUPDATE accounts SET balance = balance - 100 WHERE account_id = 'A';\nUPDATE accounts SET balance = balance + 100 WHERE account_id = 'B';\n\nCOMMIT;\n-- Both operations succeed or both fail\n```\n\n**Consistency**: Database moves from one valid state to another\n- Foreign keys enforced\n- Constraints maintained\n\n**Isolation**: Concurrent transactions don't interfere\n- Levels: Read Uncommitted, Read Committed, Repeatable Read, Serializable\n\n**Durability**: Once committed, data persists\n- Write-ahead logging (WAL)\n\n## 7. Sharding & Partitioning\n\n### Partitioning (Vertical/Horizontal)\n\n**Horizontal Partitioning**: Split rows\n```sql\n-- Split by date range\nCREATE TABLE orders_2023 PARTITION OF orders\n    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');\n\nCREATE TABLE orders_2024 PARTITION OF orders\n    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');\n```\n\n**Vertical Partitioning**: Split columns\n```sql\n-- Frequently accessed columns\nCREATE TABLE users_core (\n    user_id INT PRIMARY KEY,\n    email VARCHAR(255),\n    name VARCHAR(100)\n);\n\n-- Rarely accessed columns\nCREATE TABLE users_profile (\n    user_id INT PRIMARY KEY,\n    bio TEXT,\n    preferences JSONB\n);\n```\n\n### Sharding\n\nDistribute data across multiple databases\n\n**Strategies**:\n1. **Hash-based**: `shard = hash(user_id) % num_shards`\n2. **Range-based**: `user_id 1-1000` ‚Üí Shard 1, `1001-2000` ‚Üí Shard 2\n3. **Geographic**: US users ‚Üí US shard, EU users ‚Üí EU shard\n\n**Trade-offs**:\n- ‚úÖ Horizontal scalability\n- ‚úÖ Better performance\n- ‚ùå Complex JOINs across shards\n- ‚ùå Difficult rebalancing\n\n## 8. Replication\n\n### Master-Slave Replication\n\n```\nMaster (Write)\n    |\n    +-- Slave 1 (Read)\n    +-- Slave 2 (Read)\n    +-- Slave 3 (Read)\n```\n\n**Benefits**:\n- Read scaling\n- High availability\n- Backup and disaster recovery\n\n**Challenges**:\n- Replication lag\n- Eventual consistency\n\n### Multi-Master Replication\n\n```\nMaster 1 ‚Üê‚Üí Master 2\n    ‚Üì           ‚Üì\n Slaves      Slaves\n```\n\n**Benefits**:\n- Write scaling\n- No single point of failure\n\n**Challenges**:\n- Conflict resolution\n- Complex setup\n\n## 9. Real-World Examples\n\n### Instagram Architecture\n\n**Database Setup**:\n- PostgreSQL (sharded by user_id)\n- Cassandra (for feeds, time-series data)\n- Redis (caching layer)\n\n**Sharding Strategy**:\n```python\n# Instagram uses hash-based sharding\nshard_id = user_id % 4096\n# 4096 logical shards mapped to physical databases\n```\n\n### Twitter Feed Architecture\n\n**Fan-out on Write**:\n```python\n# When user tweets:\n1. Store tweet in tweets table\n2. Fan-out to all followers' timelines (Redis)\n3. For users with millions of followers, fan-out on read\n```\n\n**Technologies**:\n- MySQL (tweets, users)\n- Manhattan (distributed key-value for timelines)\n- Redis (caching)\n\n### Uber Database Design\n\n**Geo-Sharding**:\n- Data sharded by geographic region\n- Riders/drivers ‚Üí closest shard\n- Reduces latency\n\n**Technologies**:\n- MySQL (sharded)\n- Cassandra (trip data)\n- Redis (driver locations)\n\n---\n\n## Best Practices\n\n1. **Design for your access patterns**\n2. **Index wisely** (read/write trade-off)\n3. **Normalize first, denormalize only when needed**\n4. **Use appropriate database for use case** (polyglot persistence)\n5. **Monitor query performance** (EXPLAIN ANALYZE)\n6. **Plan for scalability** (sharding, replication)\n7. **Implement caching** (Redis, Memcached)\n8. **Regular backups and disaster recovery**\n\n"}