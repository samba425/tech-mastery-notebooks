{"id":"python-challenges","title":"ðŸŽ¯ Python Challenges","content":"# Python Programming Challenges & Data Structures\n\nThis notebook contains Python implementations of programming challenges, data structures, and algorithms. Each challenge includes:\n\n- **Problem Description**: Clear explanation of the challenge\n- **Function Signature**: Expected input/output types\n- **Examples**: Sample inputs and expected outputs\n- **Python Solution**: Complete implementation with explanations\n- **Time & Space Complexity**: Algorithm analysis\n- **Test Cases**: Verification of the solution\n\n## Learning Objectives\n- Master fundamental programming concepts\n- Practice algorithm design and optimization\n- Understand data structures implementation\n- Develop problem-solving skills\n- Learn Python best practices\n\n## Challenge Categories\n1. **Basic Challenges 1**: Loops, conditionals, string manipulation\n2. **Basic Challenges 2**: Advanced string/array operations\n3. **Higher-Order Functions**: List comprehensions, map, filter, reduce\n4. **Recursion**: Recursive algorithms and thinking\n5. **Complexity**: Time and space complexity analysis\n6. **Data Structures**: Stacks, queues, linked lists, trees\n7. **Sorting Algorithms**: Various sorting techniques\n\n---\n\n# ðŸ“š Section 1: Basic Challenges - Part 1\n\nThese challenges focus on fundamental programming concepts including loops, conditionals, and string manipulation.\n\n## Challenge 1: Hello World\n\n**Problem**: Write a function called `hello_world` that returns the string 'Hello World!'.\n\n**Function Signature**: \n```python\ndef hello_world() -> str:\n    \"\"\"Returns a string containing 'Hello World!'.\"\"\"\n    pass\n```\n\n**Examples**:\n- `hello_world()` â†’ `'Hello World!'`\n\n**Constraints**:\n- Function must return a string\n\n**Time Complexity**: O(1)  \n**Space Complexity**: O(1)\n\n```python\n# Solution for Challenge 1: Hello World\ndef hello_world() -> str:\n    \"\"\"Returns a string containing 'Hello World!'.\"\"\"\n    return 'Hello World!'\n\n# Test the function\nprint(\"Testing hello_world():\")\nresult = hello_world()\nprint(f\"Result: {result}\")\nprint(f\"Expected: 'Hello World!'\")\nprint(f\"Test passed: {result == 'Hello World!'}\")\nprint(\"-\" * 50)\n```\n\n## Challenge 2: Get Sum\n\n**Problem**: Write a function called `get_sum` that takes two numbers and returns their sum.\n\n**Function Signature**: \n```python\ndef get_sum(a: int, b: int) -> int:\n    \"\"\"Returns the sum of two numbers.\"\"\"\n    pass\n```\n\n**Examples**:\n- `get_sum(1, 2)` â†’ `3`\n- `get_sum(10, 5)` â†’ `15`\n- `get_sum(2, 2)` â†’ `4`\n\n**Constraints**:\n- Function must return a number\n\n**Time Complexity**: O(1)  \n**Space Complexity**: O(1)\n\n```python\n# Solution for Challenge 2: Get Sum\ndef get_sum(a: int, b: int) -> int:\n    \"\"\"Returns the sum of two numbers.\"\"\"\n    return a + b\n\n# Test the function\nprint(\"Testing get_sum():\")\ntest_cases = [(1, 2, 3), (10, 5, 15), (2, 2, 4), (-5, 3, -2)]\n\nfor a, b, expected in test_cases:\n    result = get_sum(a, b)\n    print(f\"get_sum({a}, {b}) = {result}, Expected: {expected}, Passed: {result == expected}\")\n\nprint(\"-\" * 50)\n```\n\n## Challenge 3: Calculator\n\n**Problem**: Write a function called `calculator` that takes two numbers and an operator (+, -, *, /) and returns the result of the calculation.\n\n**Function Signature**: \n```python\ndef calculator(num1: float, num2: float, operator: str) -> float:\n    \"\"\"Returns the result of a calculation.\"\"\"\n    pass\n```\n\n**Examples**:\n- `calculator(1, 2, '+')` â†’ `3`\n- `calculator(10, 5, '-')` â†’ `5`\n- `calculator(2, 2, '*')` â†’ `4`\n- `calculator(10, 5, '/')` â†’ `2.0`\n\n**Constraints**:\n- Function must return a number\n- Function must handle invalid operators\n- Handle division by zero\n\n**Time Complexity**: O(1)  \n**Space Complexity**: O(1)\n\n```python\n# Solution for Challenge 3: Calculator\ndef calculator(num1: float, num2: float, operator: str) -> float:\n    \"\"\"Returns the result of a calculation.\"\"\"\n    if operator == '+':\n        return num1 + num2\n    elif operator == '-':\n        return num1 - num2\n    elif operator == '*':\n        return num1 * num2\n    elif operator == '/':\n        if num2 == 0:\n            raise ValueError(\"Division by zero is not allowed\")\n        return num1 / num2\n    else:\n        raise ValueError(f\"Invalid operator: {operator}\")\n\n# Alternative solution using dictionary\ndef calculator_v2(num1: float, num2: float, operator: str) -> float:\n    \"\"\"Calculator using dictionary approach.\"\"\"\n    operations = {\n        '+': lambda x, y: x + y,\n        '-': lambda x, y: x - y,\n        '*': lambda x, y: x * y,\n        '/': lambda x, y: x / y if y != 0 else None\n    }\n    \n    if operator not in operations:\n        raise ValueError(f\"Invalid operator: {operator}\")\n    \n    result = operations[operator](num1, num2)\n    if result is None:\n        raise ValueError(\"Division by zero is not allowed\")\n    \n    return result\n\n# Test the function\nprint(\"Testing calculator():\")\ntest_cases = [\n    (1, 2, '+', 3),\n    (10, 5, '-', 5),\n    (2, 2, '*', 4),\n    (10, 5, '/', 2.0),\n    (7, 3, '+', 10),\n    (15, 3, '/', 5.0)\n]\n\nfor num1, num2, op, expected in test_cases:\n    try:\n        result = calculator(num1, num2, op)\n        print(f\"calculator({num1}, {num2}, '{op}') = {result}, Expected: {expected}, Passed: {result == expected}\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\n# Test error cases\nprint(\"\\nTesting error cases:\")\ntry:\n    calculator(10, 0, '/')\nexcept ValueError as e:\n    print(f\"Division by zero caught: {e}\")\n\ntry:\n    calculator(5, 3, '%')\nexcept ValueError as e:\n    print(f\"Invalid operator caught: {e}\")\n\nprint(\"-\" * 50)\n```\n\n## Challenge 4: Reverse String\n\n**Problem**: Write a function called `reverse_string` that takes a string and returns it reversed.\n\n**Function Signature**: \n```python\ndef reverse_string(s: str) -> str:\n    \"\"\"Returns the reverse of a string.\"\"\"\n    pass\n```\n\n**Examples**:\n- `reverse_string('hello')` â†’ `'olleh'`\n- `reverse_string('world')` â†’ `'dlrow'`\n- `reverse_string('')` â†’ `''`\n\n**Constraints**:\n- Input string contains only lowercase letters and spaces\n- Try solving with loops first, then with built-in methods\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(n)\n\n```python\n# Solution for Challenge 4: Reverse String\n\n# Method 1: Using loop (manual approach)\ndef reverse_string_loop(s: str) -> str:\n    \"\"\"Returns the reverse of a string using a loop.\"\"\"\n    reversed_str = \"\"\n    for i in range(len(s) - 1, -1, -1):\n        reversed_str += s[i]\n    return reversed_str\n\n# Method 2: Using slicing (Pythonic approach)\ndef reverse_string(s: str) -> str:\n    \"\"\"Returns the reverse of a string using slicing.\"\"\"\n    return s[::-1]\n\n# Method 3: Using built-in functions\ndef reverse_string_builtin(s: str) -> str:\n    \"\"\"Returns the reverse of a string using built-in functions.\"\"\"\n    return ''.join(reversed(s))\n\n# Method 4: Using recursion\ndef reverse_string_recursive(s: str) -> str:\n    \"\"\"Returns the reverse of a string using recursion.\"\"\"\n    if len(s) <= 1:\n        return s\n    return s[-1] + reverse_string_recursive(s[:-1])\n\n# Test all methods\nprint(\"Testing reverse_string() methods:\")\ntest_cases = ['hello', 'world', '', 'a', 'python', 'programming']\n\nfor test_str in test_cases:\n    result1 = reverse_string_loop(test_str)\n    result2 = reverse_string(test_str)\n    result3 = reverse_string_builtin(test_str)\n    result4 = reverse_string_recursive(test_str)\n    \n    print(f\"'{test_str}' â†’ '{result1}' (all methods same: {result1 == result2 == result3 == result4})\")\n\nprint(\"-\" * 50)\n```\n\n## Challenge 5: Palindrome Check\n\n**Problem**: Write a function called `is_palindrome` that checks if a string reads the same forwards and backwards.\n\n**Function Signature**: \n```python\ndef is_palindrome(s: str) -> bool:\n    \"\"\"Returns True if the string is a palindrome.\"\"\"\n    pass\n```\n\n**Examples**:\n- `is_palindrome('madam')` â†’ `True`\n- `is_palindrome('racecar')` â†’ `True` \n- `is_palindrome('hello')` â†’ `False`\n- `is_palindrome('')` â†’ `True`\n- `is_palindrome('A man a plan a canal Panama')` â†’ `True` (ignoring spaces and case)\n\n**Constraints**:\n- Function should ignore spaces and case differences\n- Input may contain spaces and mixed case\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(n)\n\n```python\n# Solution for Challenge 5: Palindrome Check\nimport re\n\n# Method 1: Using string comparison\ndef is_palindrome(s: str) -> bool:\n    \"\"\"Returns True if the string is a palindrome.\"\"\"\n    # Clean the string: remove non-alphanumeric and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return cleaned == cleaned[::-1]\n\n# Method 2: Two-pointer approach (more memory efficient)\ndef is_palindrome_two_pointers(s: str) -> bool:\n    \"\"\"Check palindrome using two pointers approach.\"\"\"\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    left, right = 0, len(cleaned) - 1\n    \n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\n# Method 3: Without regex (manual cleaning)\ndef is_palindrome_manual(s: str) -> bool:\n    \"\"\"Check palindrome with manual string cleaning.\"\"\"\n    cleaned = ''.join(char.lower() for char in s if char.isalnum())\n    return cleaned == cleaned[::-1]\n\n# Method 4: Recursive approach\ndef is_palindrome_recursive(s: str) -> bool:\n    \"\"\"Check palindrome using recursion.\"\"\"\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    \n    def helper(start: int, end: int) -> bool:\n        if start >= end:\n            return True\n        if cleaned[start] != cleaned[end]:\n            return False\n        return helper(start + 1, end - 1)\n    \n    return helper(0, len(cleaned) - 1)\n\n# Test the function\nprint(\"Testing is_palindrome():\")\ntest_cases = [\n    ('madam', True),\n    ('racecar', True),\n    ('hello', False),\n    ('', True),\n    ('a', True),\n    ('A man a plan a canal Panama', True),\n    ('race a car', False),\n    ('Madam', True),\n    ('Was it a car or a cat I saw', True)\n]\n\nfor test_str, expected in test_cases:\n    result1 = is_palindrome(test_str)\n    result2 = is_palindrome_two_pointers(test_str)\n    result3 = is_palindrome_manual(test_str)\n    result4 = is_palindrome_recursive(test_str)\n    \n    all_same = result1 == result2 == result3 == result4 == expected\n    print(f\"'{test_str}' â†’ {result1}, Expected: {expected}, All methods agree: {all_same}\")\n\nprint(\"-\" * 50)\n```\n\n## Challenge 6: Count Vowels\n\n**Problem**: Write a function called `count_vowels` that counts the number of vowels in a string.\n\n**Function Signature**: \n```python\ndef count_vowels(s: str) -> int:\n    \"\"\"Returns the number of vowels in a string.\"\"\"\n    pass\n```\n\n**Examples**:\n- `count_vowels('hello')` â†’ `2`\n- `count_vowels('why')` â†’ `0`\n- `count_vowels('mississippi')` â†’ `4`\n- `count_vowels('PROGRAMMING')` â†’ `3`\n\n**Constraints**:\n- Should work with both uppercase and lowercase\n- Vowels are: a, e, i, o, u\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(1)\n\n```python\n# Solution for Challenge 6: Count Vowels\n\n# Method 1: Loop through each character\ndef count_vowels_loop(s: str) -> int:\n    \"\"\"Count vowels using a loop.\"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n\n# Method 2: Using list comprehension\ndef count_vowels(s: str) -> int:\n    \"\"\"Count vowels using list comprehension.\"\"\"\n    vowels = \"aeiou\"\n    return sum(1 for char in s.lower() if char in vowels)\n\n# Method 3: Using filter\ndef count_vowels_filter(s: str) -> int:\n    \"\"\"Count vowels using filter.\"\"\"\n    vowels = \"aeiou\"\n    return len(list(filter(lambda char: char.lower() in vowels, s)))\n\n# Method 4: Using regular expressions\nimport re\ndef count_vowels_regex(s: str) -> int:\n    \"\"\"Count vowels using regex.\"\"\"\n    return len(re.findall(r'[aeiouAEIOU]', s))\n\n# Method 5: Dictionary counting approach\ndef count_vowels_detailed(s: str) -> dict:\n    \"\"\"Count each vowel separately.\"\"\"\n    vowel_counts = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}\n    for char in s.lower():\n        if char in vowel_counts:\n            vowel_counts[char] += 1\n    return vowel_counts\n\n# Test the function\nprint(\"Testing count_vowels():\")\ntest_cases = [\n    ('hello', 2),\n    ('why', 0), \n    ('mississippi', 4),\n    ('PROGRAMMING', 3),\n    ('aeiou', 5),\n    ('bcdfg', 0),\n    ('Education', 5),\n    ('', 0)\n]\n\nfor test_str, expected in test_cases:\n    result1 = count_vowels_loop(test_str)\n    result2 = count_vowels(test_str)\n    result3 = count_vowels_filter(test_str)\n    result4 = count_vowels_regex(test_str)\n    \n    all_same = result1 == result2 == result3 == result4 == expected\n    print(f\"'{test_str}' â†’ {result1} vowels, Expected: {expected}, All methods agree: {all_same}\")\n\n# Show detailed vowel breakdown for some examples\nprint(\"\\nDetailed vowel breakdown:\")\nfor test_str in ['hello', 'mississippi', 'Education']:\n    details = count_vowels_detailed(test_str)\n    total = sum(details.values())\n    print(f\"'{test_str}': {details} (Total: {total})\")\n\nprint(\"-\" * 50)\n```\n\n# ðŸ“š Section 2: Basic Challenges - Part 2\n\nThese challenges involve array manipulation, mathematical operations, and more complex logic.\n\n## Challenge 6.5: Count Occurrences\n\n**Problem**: Write a function called `count_occurrences` that counts how many times a character appears in a string.\n\n**Function Signature**: \n```python\ndef count_occurrences(text: str, char: str) -> int:\n    \"\"\"Returns the number of occurrences of char in text.\"\"\"\n    pass\n```\n\n**Examples**:\n- `count_occurrences('hello', 'l')` â†’ `2`\n- `count_occurrences('hello', 'z')` â†’ `0`\n- `count_occurrences('Python', 'p')` â†’ `0` (case sensitive)\n\n**Constraints**:\n- Case sensitive by default\n- Single character search\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(1)\n\n```python\n# Solution for Challenge 6.5: Count Occurrences\n\n# Method 1: Simple loop counting\ndef count_occurrences(text: str, char: str) -> int:\n    \"\"\"Count occurrences using simple loop.\"\"\"\n    count = 0\n    for c in text:\n        if c == char:\n            count += 1\n    return count\n\n# Method 2: Using built-in count method\ndef count_occurrences_builtin(text: str, char: str) -> int:\n    \"\"\"Count occurrences using built-in method.\"\"\"\n    return text.count(char)\n\n# Method 3: Using list comprehension\ndef count_occurrences_comprehension(text: str, char: str) -> int:\n    \"\"\"Count occurrences using list comprehension.\"\"\"\n    return sum(1 for c in text if c == char)\n\n# Method 4: Case insensitive version\ndef count_occurrences_case_insensitive(text: str, char: str) -> int:\n    \"\"\"Count occurrences ignoring case.\"\"\"\n    return text.lower().count(char.lower())\n\n# Method 5: Using filter\ndef count_occurrences_filter(text: str, char: str) -> int:\n    \"\"\"Count occurrences using filter.\"\"\"\n    return len(list(filter(lambda c: c == char, text)))\n\n# Test the functions\nprint(\"Testing count_occurrences():\")\ntest_cases = [\n    ('hello', 'l', 2),\n    ('hello', 'z', 0),\n    ('Python', 'p', 0),  # Case sensitive\n    ('Python', 'P', 1),\n    ('programming', 'g', 2),\n    ('', 'a', 0),\n    ('aaaa', 'a', 4),\n    ('Hello World', ' ', 1),\n    ('Mississippi', 's', 4)\n]\n\nfor text, char, expected in test_cases:\n    result1 = count_occurrences(text, char)\n    result2 = count_occurrences_builtin(text, char)\n    result3 = count_occurrences_comprehension(text, char)\n    result4 = count_occurrences_filter(text, char)\n    \n    all_same = result1 == result2 == result3 == result4 == expected\n    print(f\"count_occurrences('{text}', '{char}') = {result1}, Expected: {expected}, All agree: {all_same}\")\n\n# Test case insensitive version\nprint(\"\\nCase insensitive examples:\")\ncase_test = [\n    ('Python', 'p', 1),\n    ('Programming', 'g', 2),\n    ('Hello', 'L', 2)\n]\n\nfor text, char, expected in case_test:\n    result = count_occurrences_case_insensitive(text, char)\n    print(f\"count_occurrences_case_insensitive('{text}', '{char}') = {result}\")\n\nprint(\"-\" * 50)\n```\n\n## Challenge 6.6: Find Max Number\n\n**Problem**: Write a function called `find_max` that finds the largest number in an array.\n\n**Function Signature**: \n```python\ndef find_max(numbers: list[int]) -> int:\n    \"\"\"Returns the largest number in the array.\"\"\"\n    pass\n```\n\n**Examples**:\n- `find_max([1, 5, 3, 9, 2])` â†’ `9`\n- `find_max([-1, -5, -3])` â†’ `-1`\n- `find_max([42])` â†’ `42`\n\n**Constraints**:\n- Array will not be empty\n- Handle negative numbers\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(1)\n\n```python\n# Solution for Challenge 6.6: Find Max Number\n\n# Method 1: Using built-in max function\ndef find_max(numbers: list[int]) -> int:\n    \"\"\"Find maximum using built-in max function.\"\"\"\n    return max(numbers)\n\n# Method 2: Manual iteration\ndef find_max_manual(numbers: list[int]) -> int:\n    \"\"\"Find maximum using manual iteration.\"\"\"\n    if not numbers:\n        raise ValueError(\"Empty array\")\n    \n    max_num = numbers[0]\n    for num in numbers[1:]:\n        if num > max_num:\n            max_num = num\n    return max_num\n\n# Method 3: Using reduce\nfrom functools import reduce\ndef find_max_reduce(numbers: list[int]) -> int:\n    \"\"\"Find maximum using reduce.\"\"\"\n    return reduce(lambda a, b: a if a > b else b, numbers)\n\n# Method 4: Recursive approach\ndef find_max_recursive(numbers: list[int]) -> int:\n    \"\"\"Find maximum using recursion.\"\"\"\n    if len(numbers) == 1:\n        return numbers[0]\n    \n    rest_max = find_max_recursive(numbers[1:])\n    return numbers[0] if numbers[0] > rest_max else rest_max\n\n# Test the functions\nprint(\"Testing find_max():\")\ntest_cases = [\n    ([1, 5, 3, 9, 2], 9),\n    ([-1, -5, -3], -1),\n    ([42], 42),\n    ([0, 0, 0], 0),\n    ([-10, -20, -5], -5),\n    ([100, 99, 101, 98], 101)\n]\n\nfor numbers, expected in test_cases:\n    result1 = find_max(numbers)\n    result2 = find_max_manual(numbers)\n    result3 = find_max_reduce(numbers)\n    result4 = find_max_recursive(numbers)\n    \n    all_same = result1 == result2 == result3 == result4 == expected\n    print(f\"find_max({numbers}) = {result1}, Expected: {expected}, All agree: {all_same}\")\n\nprint(\"-\" * 50)\n```\n\n## Challenge 7: FizzBuzz Array\n\n**Problem**: Create a function called `fizz_buzz_array` that returns an array from 1 to n where:\n- Numbers divisible by 3 are replaced with \"Fizz\"\n- Numbers divisible by 5 are replaced with \"Buzz\"  \n- Numbers divisible by both 3 and 5 are replaced with \"FizzBuzz\"\n\n**Function Signature**: \n```python\ndef fizz_buzz_array(n: int) -> list:\n    \"\"\"Returns FizzBuzz array from 1 to n.\"\"\"\n    pass\n```\n\n**Examples**:\n- `fizz_buzz_array(5)` â†’ `[1, 2, \"Fizz\", 4, \"Buzz\"]`\n- `fizz_buzz_array(15)` â†’ `[1, 2, \"Fizz\", 4, \"Buzz\", \"Fizz\", 7, 8, \"Fizz\", \"Buzz\", 11, \"Fizz\", 13, 14, \"FizzBuzz\"]`\n\n**Constraints**:\n- n will always be greater than 0\n- n will always be an integer\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(n)\n\n```python\n# Solution for Challenge 7: FizzBuzz Array\n\n# Method 1: Traditional approach with if-elif-else\ndef fizz_buzz_array(n: int) -> list:\n    \"\"\"Returns FizzBuzz array from 1 to n.\"\"\"\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:  # Divisible by both 3 and 5\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(i)\n    return result\n\n# Method 2: String concatenation approach\ndef fizz_buzz_array_v2(n: int) -> list:\n    \"\"\"Alternative FizzBuzz using string concatenation.\"\"\"\n    result = []\n    for i in range(1, n + 1):\n        output = \"\"\n        if i % 3 == 0:\n            output += \"Fizz\"\n        if i % 5 == 0:\n            output += \"Buzz\"\n        result.append(output if output else i)\n    return result\n\n# Method 3: List comprehension approach\ndef fizz_buzz_array_v3(n: int) -> list:\n    \"\"\"FizzBuzz using list comprehension.\"\"\"\n    return [\n        \"FizzBuzz\" if i % 15 == 0 else\n        \"Fizz\" if i % 3 == 0 else\n        \"Buzz\" if i % 5 == 0 else\n        i\n        for i in range(1, n + 1)\n    ]\n\n# Method 4: Dictionary mapping approach\ndef fizz_buzz_array_v4(n: int) -> list:\n    \"\"\"FizzBuzz using dictionary mapping.\"\"\"\n    def get_fizz_buzz(num):\n        mappings = {3: \"Fizz\", 5: \"Buzz\"}\n        result = \"\"\n        for divisor, word in mappings.items():\n            if num % divisor == 0:\n                result += word\n        return result if result else num\n    \n    return [get_fizz_buzz(i) for i in range(1, n + 1)]\n\n# Test the function\nprint(\"Testing fizz_buzz_array():\")\ntest_cases = [5, 15, 20]\n\nfor n in test_cases:\n    result1 = fizz_buzz_array(n)\n    result2 = fizz_buzz_array_v2(n)\n    result3 = fizz_buzz_array_v3(n)\n    result4 = fizz_buzz_array_v4(n)\n    \n    all_same = result1 == result2 == result3 == result4\n    print(f\"fizz_buzz_array({n}): All methods agree: {all_same}\")\n    print(f\"Result: {result1}\")\n    print()\n\nprint(\"-\" * 50)\n```\n\n## Challenge 8: Find Missing Number\n\n**Problem**: Write a function called `find_missing_number` that finds the missing number in an array of consecutive integers from 1 to n.\n\n**Function Signature**: \n```python\ndef find_missing_number(arr: list[int]) -> int:\n    \"\"\"Returns the missing number in consecutive sequence.\"\"\"\n    pass\n```\n\n**Examples**:\n- `find_missing_number([1, 2, 3, 4, 6, 7, 8, 9, 10])` â†’ `5`\n- `find_missing_number([10, 8, 6, 7, 5, 4, 2, 3, 1])` â†’ `9`\n- `find_missing_number([10, 5, 1, 2, 4, 6, 8, 3, 9])` â†’ `7`\n\n**Constraints**:\n- If empty array is passed, return 1\n- If None is passed, return None\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(1)\n\n```python\n# Solution for Challenge 8: Find Missing Number\n\n# Method 1: Mathematical approach using sum formula\ndef find_missing_number(arr: list[int]) -> int:\n    \"\"\"Find missing number using sum formula.\"\"\"\n    if not arr:\n        return 1\n    if arr is None:\n        return None\n    \n    n = len(arr) + 1  # Expected length\n    expected_sum = n * (n + 1) // 2  # Sum formula: n(n+1)/2\n    actual_sum = sum(arr)\n    return expected_sum - actual_sum\n\n# Method 2: Using set difference\ndef find_missing_number_v2(arr: list[int]) -> int:\n    \"\"\"Find missing number using set difference.\"\"\"\n    if not arr:\n        return 1\n    if arr is None:\n        return None\n    \n    n = len(arr) + 1\n    full_set = set(range(1, n + 1))\n    arr_set = set(arr)\n    missing = full_set - arr_set\n    return missing.pop() if missing else None\n\n# Method 3: XOR approach (bit manipulation)\ndef find_missing_number_v3(arr: list[int]) -> int:\n    \"\"\"Find missing number using XOR.\"\"\"\n    if not arr:\n        return 1\n    if arr is None:\n        return None\n    \n    n = len(arr) + 1\n    xor_all = 0\n    xor_arr = 0\n    \n    # XOR all numbers from 1 to n\n    for i in range(1, n + 1):\n        xor_all ^= i\n    \n    # XOR all numbers in array\n    for num in arr:\n        xor_arr ^= num\n    \n    # Missing number is the XOR of the two\n    return xor_all ^ xor_arr\n\n# Method 4: Using sorting and linear search\ndef find_missing_number_v4(arr: list[int]) -> int:\n    \"\"\"Find missing number by sorting first.\"\"\"\n    if not arr:\n        return 1\n    if arr is None:\n        return None\n    \n    arr_sorted = sorted(arr)\n    for i, num in enumerate(arr_sorted, 1):\n        if num != i:\n            return i\n    return len(arr) + 1\n\n# Test the function\nprint(\"Testing find_missing_number():\")\ntest_cases = [\n    ([1, 2, 3, 4, 6, 7, 8, 9, 10], 5),\n    ([10, 8, 6, 7, 5, 4, 2, 3, 1], 9),\n    ([10, 5, 1, 2, 4, 6, 8, 3, 9], 7),\n    ([2, 3, 4, 5], 1),\n    ([1, 2, 3, 4], 5),\n    ([], 1),\n    ([1], 2)\n]\n\nfor arr, expected in test_cases:\n    result1 = find_missing_number(arr.copy() if arr else arr)\n    result2 = find_missing_number_v2(arr.copy() if arr else arr)\n    result3 = find_missing_number_v3(arr.copy() if arr else arr)\n    result4 = find_missing_number_v4(arr.copy() if arr else arr)\n    \n    all_same = result1 == result2 == result3 == result4 == expected\n    print(f\"Array: {arr}, Missing: {result1}, Expected: {expected}, All methods agree: {all_same}\")\n\n# Test None case\nresult_none = find_missing_number(None)\nprint(f\"find_missing_number(None) = {result_none}\")\n\nprint(\"-\" * 50)\n```\n\n## Challenge 8.5: Find Missing Letter\n\n**Problem**: Write a function called `find_missing_letter` that finds the missing letter in an array of consecutive letters.\n\n**Function Signature**: \n```python\ndef find_missing_letter(letters: list[str]) -> str:\n    \"\"\"Returns the missing letter in consecutive sequence.\"\"\"\n    pass\n```\n\n**Examples**:\n- `find_missing_letter(['a', 'b', 'c', 'd', 'f'])` â†’ `'e'`\n- `find_missing_letter(['O', 'Q', 'R', 'S'])` â†’ `'P'`\n- `find_missing_letter(['t', 'u', 'v', 'w', 'x', 'z'])` â†’ `'y'`\n\n**Constraints**:\n- Input contains only one case (lower or upper)\n- If no missing letter, return empty string\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(1)\n\n```python\n# Solution for Challenge 8.5: Find Missing Letter\n\n# Method 1: Using ASCII values\ndef find_missing_letter(letters: list[str]) -> str:\n    \"\"\"Find missing letter using ASCII values.\"\"\"\n    if not letters:\n        return ''\n    \n    for i in range(len(letters) - 1):\n        current_code = ord(letters[i])\n        next_code = ord(letters[i + 1])\n        \n        # If there's a gap of more than 1\n        if next_code - current_code > 1:\n            return chr(current_code + 1)\n    \n    return ''\n\n# Method 2: Using alphabet string\ndef find_missing_letter_v2(letters: list[str]) -> str:\n    \"\"\"Find missing letter using alphabet string.\"\"\"\n    if not letters:\n        return ''\n    \n    # Create appropriate alphabet\n    if letters[0].islower():\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    else:\n        alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Find start position in alphabet\n    start_idx = alphabet.index(letters[0])\n    \n    # Check each position\n    for i, letter in enumerate(letters):\n        expected_letter = alphabet[start_idx + i]\n        if letter != expected_letter:\n            return expected_letter\n    \n    return ''\n\n# Method 3: Using set difference\ndef find_missing_letter_v3(letters: list[str]) -> str:\n    \"\"\"Find missing letter using set difference.\"\"\"\n    if not letters:\n        return ''\n    \n    # Create expected sequence\n    start_ord = ord(letters[0])\n    end_ord = ord(letters[-1])\n    expected_letters = {chr(i) for i in range(start_ord, end_ord + 1)}\n    actual_letters = set(letters)\n    \n    missing = expected_letters - actual_letters\n    return missing.pop() if missing else ''\n\n# Method 4: Mathematical approach\ndef find_missing_letter_v4(letters: list[str]) -> str:\n    \"\"\"Find missing letter using sum difference.\"\"\"\n    if not letters:\n        return ''\n    \n    # Calculate expected sum of ASCII values\n    start_ord = ord(letters[0])\n    end_ord = ord(letters[-1])\n    expected_sum = sum(range(start_ord, end_ord + 1))\n    \n    # Calculate actual sum\n    actual_sum = sum(ord(letter) for letter in letters)\n    \n    # Missing letter's ASCII value\n    missing_ord = expected_sum - actual_sum\n    return chr(missing_ord) if missing_ord else ''\n\n# Method 5: Generator approach\ndef find_missing_letter_v5(letters: list[str]) -> str:\n    \"\"\"Find missing letter using generator.\"\"\"\n    if not letters:\n        return ''\n    \n    def expected_sequence():\n        start = ord(letters[0])\n        for i in range(len(letters) + 1):  # +1 for potential missing letter\n            yield chr(start + i)\n    \n    expected = expected_sequence()\n    for i, letter in enumerate(letters):\n        expected_letter = next(expected)\n        if letter != expected_letter:\n            return expected_letter\n    \n    return ''\n\n# Test the functions\nprint(\"Testing find_missing_letter():\")\ntest_cases = [\n    (['a', 'b', 'c', 'd', 'f'], 'e'),\n    (['O', 'Q', 'R', 'S'], 'P'),\n    (['t', 'u', 'v', 'w', 'x', 'z'], 'y'),\n    (['a', 'b', 'c'], ''),  # No missing letter\n    (['m', 'o'], 'n'),\n    (['A', 'B', 'D'], 'C'),\n    ([], ''),  # Empty array\n    (['x', 'z'], 'y')\n]\n\nfor letters, expected in test_cases:\n    result1 = find_missing_letter(letters)\n    result2 = find_missing_letter_v2(letters)\n    result3 = find_missing_letter_v3(letters)\n    result4 = find_missing_letter_v4(letters)\n    result5 = find_missing_letter_v5(letters)\n    \n    all_same = result1 == result2 == result3 == result4 == result5 == expected\n    print(f\"Letters: {letters}\")\n    print(f\"Missing: '{result1}', Expected: '{expected}', All methods agree: {all_same}\")\n    \n    if letters:  # Show ASCII analysis for non-empty arrays\n        ascii_values = [ord(letter) for letter in letters]\n        print(f\"ASCII values: {ascii_values}\")\n        if len(letters) > 1:\n            gaps = [ascii_values[i+1] - ascii_values[i] for i in range(len(ascii_values)-1)]\n            print(f\"Gaps: {gaps}\")\n    print(\"-\" * 40)\n\nprint(\"Algorithm Insights:\")\nprint(\"â€¢ ASCII method: Direct character code arithmetic\")\nprint(\"â€¢ Alphabet method: Use predefined sequence lookup\")\nprint(\"â€¢ Set difference: Mathematical set operations\")\nprint(\"â€¢ Sum difference: Mathematical formula approach\")\nprint(\"â€¢ Generator: Lazy evaluation for memory efficiency\")\nprint(\"-\" * 50)\n```\n\n## Challenge 8.7: Array Intersection\n\n**Problem**: Write a function called `array_intersection` that finds the common elements between two arrays.\n\n**Function Signature**: \n```python\ndef array_intersection(arr1: list[int], arr2: list[int]) -> list[int]:\n    \"\"\"Returns common elements between two arrays.\"\"\"\n    pass\n```\n\n**Examples**:\n- `array_intersection([1, 2, 3], [2, 3, 4])` â†’ `[2, 3]`\n- `array_intersection([1, 1, 2], [1, 3])` â†’ `[1]`\n- `array_intersection([1, 2], [3, 4])` â†’ `[]`\n\n**Constraints**:\n- Return unique elements only\n- Order doesn't matter\n\n**Time Complexity**: O(n + m)  \n**Space Complexity**: O(min(n, m))\n\n```python\n# Solution for Challenge 8.7: Array Intersection\n\n# Method 1: Using set intersection\ndef array_intersection(arr1: list[int], arr2: list[int]) -> list[int]:\n    \"\"\"Find intersection using set operations.\"\"\"\n    return list(set(arr1) & set(arr2))\n\n# Method 2: Using list comprehension\ndef array_intersection_v2(arr1: list[int], arr2: list[int]) -> list[int]:\n    \"\"\"Find intersection using list comprehension.\"\"\"\n    return list(set([x for x in arr1 if x in arr2]))\n\n# Method 3: Two-pointer approach (for sorted arrays)\ndef array_intersection_sorted(arr1: list[int], arr2: list[int]) -> list[int]:\n    \"\"\"Find intersection using two pointers (requires sorted arrays).\"\"\"\n    arr1_sorted = sorted(set(arr1))\n    arr2_sorted = sorted(set(arr2))\n    \n    result = []\n    i = j = 0\n    \n    while i < len(arr1_sorted) and j < len(arr2_sorted):\n        if arr1_sorted[i] == arr2_sorted[j]:\n            result.append(arr1_sorted[i])\n            i += 1\n            j += 1\n        elif arr1_sorted[i] < arr2_sorted[j]:\n            i += 1\n        else:\n            j += 1\n    \n    return result\n\n# Method 4: Using dictionary/hash map\ndef array_intersection_dict(arr1: list[int], arr2: list[int]) -> list[int]:\n    \"\"\"Find intersection using dictionary counting.\"\"\"\n    count_map = {}\n    result = []\n    \n    # Count elements in first array\n    for num in arr1:\n        count_map[num] = count_map.get(num, 0) + 1\n    \n    # Check if elements from second array exist in first\n    seen = set()\n    for num in arr2:\n        if num in count_map and num not in seen:\n            result.append(num)\n            seen.add(num)\n    \n    return result\n\n# Method 5: Using filter\ndef array_intersection_filter(arr1: list[int], arr2: list[int]) -> list[int]:\n    \"\"\"Find intersection using filter.\"\"\"\n    set2 = set(arr2)\n    return list(set(filter(lambda x: x in set2, arr1)))\n\n# Test the functions\nprint(\"Testing array_intersection():\")\ntest_cases = [\n    ([1, 2, 3], [2, 3, 4], [2, 3]),\n    ([1, 1, 2], [1, 3], [1]),\n    ([1, 2], [3, 4], []),\n    ([1, 2, 3, 4], [3, 4, 5, 6], [3, 4]),\n    ([], [1, 2], []),\n    ([1, 2, 3], [], []),\n    ([5, 5, 5], [5, 5], [5]),\n    ([1, 2, 2, 3], [2, 2, 3, 4], [2, 3])\n]\n\nfor arr1, arr2, expected in test_cases:\n    result1 = sorted(array_intersection(arr1, arr2))\n    result2 = sorted(array_intersection_v2(arr1, arr2))\n    result3 = sorted(array_intersection_sorted(arr1, arr2))\n    result4 = sorted(array_intersection_dict(arr1, arr2))\n    result5 = sorted(array_intersection_filter(arr1, arr2))\n    expected_sorted = sorted(expected)\n    \n    all_same = (result1 == expected_sorted and result2 == expected_sorted and \n                result3 == expected_sorted and result4 == expected_sorted and \n                result5 == expected_sorted)\n    \n    print(f\"array_intersection({arr1}, {arr2}) = {result1}\")\n    print(f\"Expected: {expected_sorted}, All methods agree: {all_same}\")\n    print(\"-\" * 30)\n\nprint(\"Algorithm Analysis:\")\nprint(\"â€¢ Set intersection: Fastest for general case\")\nprint(\"â€¢ Two-pointer: Memory efficient for sorted arrays\")\nprint(\"â€¢ Dictionary: Best when you need to preserve counts\")\nprint(\"â€¢ Filter: Functional programming approach\")\nprint(\"-\" * 50)\n```\n\n# ðŸ“š Section 3: Higher-Order Functions & List Methods\n\nThese challenges focus on functional programming concepts using Python's built-in functions like `filter()`, `map()`, `reduce()`, and list comprehensions.\n\n## Challenge 9: Sum of Even Squares\n\n**Problem**: Write a function called `sum_of_even_squares` that takes an array of numbers and returns the sum of the squares of the even numbers.\n\n**Function Signature**: \n```python\ndef sum_of_even_squares(numbers: list[int]) -> int:\n    \"\"\"Returns the sum of squares of even numbers in the array.\"\"\"\n    pass\n```\n\n**Examples**:\n- `sum_of_even_squares([1, 2, 3, 4, 5])` â†’ `20` (2Â² + 4Â² = 4 + 16)\n- `sum_of_even_squares([-1, 0, 1, 2, 3, 4])` â†’ `20` (0Â² + 2Â² + 4Â² = 0 + 4 + 16)\n- `sum_of_even_squares([])` â†’ `0`\n\n**Approach**:\n1. Filter even numbers\n2. Square each even number \n3. Sum the squares\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(k) where k is number of even numbers\n\n```python\n# Solution for Challenge 9: Sum of Even Squares\nfrom functools import reduce\n\n# Method 1: Using filter, map, and reduce (functional approach)\ndef sum_of_even_squares(numbers: list[int]) -> int:\n    \"\"\"Returns sum of squares of even numbers using functional programming.\"\"\"\n    even_numbers = filter(lambda x: x % 2 == 0, numbers)\n    squares = map(lambda x: x ** 2, even_numbers)\n    return reduce(lambda a, b: a + b, squares, 0)\n\n# Method 2: List comprehension (Pythonic approach)\ndef sum_of_even_squares_v2(numbers: list[int]) -> int:\n    \"\"\"Returns sum of squares of even numbers using list comprehension.\"\"\"\n    return sum(x ** 2 for x in numbers if x % 2 == 0)\n\n# Method 3: Chain methods (similar to JavaScript)\ndef sum_of_even_squares_v3(numbers: list[int]) -> int:\n    \"\"\"Chain filter, map, reduce in functional style.\"\"\"\n    return reduce(\n        lambda a, b: a + b,\n        map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, numbers)),\n        0\n    )\n\n# Method 4: Traditional loop approach\ndef sum_of_even_squares_v4(numbers: list[int]) -> int:\n    \"\"\"Traditional loop approach.\"\"\"\n    total = 0\n    for num in numbers:\n        if num % 2 == 0:\n            total += num ** 2\n    return total\n\n# Method 5: One-liner with sum and generator\ndef sum_of_even_squares_v5(numbers: list[int]) -> int:\n    \"\"\"One-liner approach.\"\"\"\n    return sum(x**2 for x in numbers if x % 2 == 0)\n\n# Test the function\nprint(\"Testing sum_of_even_squares():\")\ntest_cases = [\n    ([1, 2, 3, 4, 5], 20),          # 2Â² + 4Â² = 4 + 16 = 20\n    ([-1, 0, 1, 2, 3, 4], 20),     # 0Â² + 2Â² + 4Â² = 0 + 4 + 16 = 20\n    ([], 0),                        # Empty array\n    ([1, 3, 5], 0),                # No even numbers\n    ([2, 4, 6], 56),               # 2Â² + 4Â² + 6Â² = 4 + 16 + 36 = 56\n    ([-2, -4], 20),                # (-2)Â² + (-4)Â² = 4 + 16 = 20\n    ([0], 0),                      # 0Â² = 0\n    ([10], 100)                    # 10Â² = 100\n]\n\nfor numbers, expected in test_cases:\n    result1 = sum_of_even_squares(numbers)\n    result2 = sum_of_even_squares_v2(numbers)\n    result3 = sum_of_even_squares_v3(numbers)\n    result4 = sum_of_even_squares_v4(numbers)\n    result5 = sum_of_even_squares_v5(numbers)\n    \n    all_same = result1 == result2 == result3 == result4 == result5 == expected\n    print(f\"Numbers: {numbers}\")\n    print(f\"Result: {result1}, Expected: {expected}, All methods agree: {all_same}\")\n    \n    # Show breakdown for better understanding\n    even_nums = [x for x in numbers if x % 2 == 0]\n    squares = [x**2 for x in even_nums]\n    print(f\"Even numbers: {even_nums}, Squares: {squares}, Sum: {sum(squares)}\")\n    print()\n\nprint(\"-\" * 50)\n```\n\n## Challenge 9.5: Valid Anagrams\n\n**Problem**: Write a function called `valid_anagrams` that checks if two strings are anagrams of each other.\n\n**Function Signature**: \n```python\ndef valid_anagrams(str1: str, str2: str) -> bool:\n    \"\"\"Returns True if str1 and str2 are anagrams.\"\"\"\n    pass\n```\n\n**Examples**:\n- `valid_anagrams('listen', 'silent')` â†’ `True`\n- `valid_anagrams('elbow', 'below')` â†’ `True`\n- `valid_anagrams('hello', 'bello')` â†’ `False`\n\n**Key Concept**: Anagrams contain the same characters with the same frequency, just rearranged.\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(1) - limited character set\n\n```python\n# Solution for Challenge 9.5: Valid Anagrams\n\n# Method 1: Sorting approach\ndef valid_anagrams(str1: str, str2: str) -> bool:\n    \"\"\"Check anagrams by sorting both strings.\"\"\"\n    if len(str1) != len(str2):\n        return False\n    return sorted(str1.lower()) == sorted(str2.lower())\n\n# Method 2: Character counting with dictionary\ndef valid_anagrams_count(str1: str, str2: str) -> bool:\n    \"\"\"Check anagrams by counting character frequencies.\"\"\"\n    if len(str1) != len(str2):\n        return False\n    \n    char_count = {}\n    \n    # Count characters in first string\n    for char in str1.lower():\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Subtract character counts for second string\n    for char in str2.lower():\n        if char not in char_count:\n            return False\n        char_count[char] -= 1\n        if char_count[char] == 0:\n            del char_count[char]\n    \n    return len(char_count) == 0\n\n# Method 3: Using Counter from collections\nfrom collections import Counter\ndef valid_anagrams_counter(str1: str, str2: str) -> bool:\n    \"\"\"Check anagrams using Counter.\"\"\"\n    return Counter(str1.lower()) == Counter(str2.lower())\n\n# Method 4: Using list counting (ASCII approach)\ndef valid_anagrams_ascii(str1: str, str2: str) -> bool:\n    \"\"\"Check anagrams using ASCII character array.\"\"\"\n    if len(str1) != len(str2):\n        return False\n    \n    # Create frequency array for 26 letters\n    char_freq = [0] * 26\n    \n    str1, str2 = str1.lower(), str2.lower()\n    \n    for i in range(len(str1)):\n        char_freq[ord(str1[i]) - ord('a')] += 1\n        char_freq[ord(str2[i]) - ord('a')] -= 1\n    \n    return all(freq == 0 for freq in char_freq)\n\n# Method 5: One-liner using sorted\ndef valid_anagrams_oneliner(str1: str, str2: str) -> bool:\n    \"\"\"One-liner anagram check.\"\"\"\n    return sorted(str1.lower()) == sorted(str2.lower())\n\n# Test the functions\nprint(\"Testing valid_anagrams():\")\ntest_cases = [\n    ('listen', 'silent', True),\n    ('elbow', 'below', True),\n    ('hello', 'bello', False),\n    ('rail safety', 'fairy tales', True),\n    ('astronomer', 'moon starer', True),\n    ('The Eyes', 'They See', True),\n    ('hello', 'world', False),\n    ('', '', True),\n    ('a', 'a', True),\n    ('a', 'b', False),\n    ('Eleven plus two', 'Twelve plus one', True),\n    ('conversation', 'voices rant on', True)\n]\n\nfor str1, str2, expected in test_cases:\n    result1 = valid_anagrams(str1, str2)\n    result2 = valid_anagrams_count(str1, str2)\n    result3 = valid_anagrams_counter(str1, str2)\n    \n    # ASCII method only works with letters\n    if str1.replace(' ', '').isalpha() and str2.replace(' ', '').isalpha():\n        result4 = valid_anagrams_ascii(str1.replace(' ', ''), str2.replace(' ', ''))\n    else:\n        result4 = result1  # Skip ASCII method for non-letters\n    \n    result5 = valid_anagrams_oneliner(str1, str2)\n    \n    all_same = result1 == result2 == result3 == result4 == result5 == expected\n    \n    print(f\"valid_anagrams('{str1}', '{str2}') = {result1}\")\n    print(f\"Expected: {expected}, All methods agree: {all_same}\")\n    \n    # Show character analysis\n    if len(str1) <= 20 and len(str2) <= 20:\n        count1 = Counter(str1.lower().replace(' ', ''))\n        count2 = Counter(str2.lower().replace(' ', ''))\n        print(f\"  '{str1}' chars: {dict(count1)}\")\n        print(f\"  '{str2}' chars: {dict(count2)}\")\n    print(\"-\" * 40)\n\nprint(\"Performance Comparison:\")\nprint(\"â€¢ Sorting: O(n log n) time, easy to understand\")\nprint(\"â€¢ Counting: O(n) time, O(1) space (limited alphabet)\")\nprint(\"â€¢ Counter: O(n) time, very readable\")\nprint(\"â€¢ ASCII array: O(n) time, most efficient for English letters\")\nprint(\"-\" * 50)\n```\n\n# ðŸ“š Section 4: Recursion Challenges\n\nRecursion is a programming technique where a function calls itself to solve smaller instances of the same problem.\n\n## Challenge 10: Factorial with Recursion\n\n**Problem**: Write a function called `factorial` that calculates the factorial of a number using recursion.\n\n**Mathematical Definition**:\n- `0! = 1` (base case)\n- `1! = 1` (base case)\n- `n! = n Ã— (n-1)!` for n > 1\n\n**Function Signature**: \n```python\ndef factorial(n: int) -> int:\n    \"\"\"Returns the factorial of n using recursion.\"\"\"\n    pass\n```\n\n**Examples**:\n- `factorial(0)` â†’ `1`\n- `factorial(1)` â†’ `1`\n- `factorial(5)` â†’ `120` (5 Ã— 4 Ã— 3 Ã— 2 Ã— 1)\n- `factorial(4)` â†’ `24` (4 Ã— 3 Ã— 2 Ã— 1)\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(n) due to call stack\n\n```python\n# Solution for Challenge 10: Factorial with Recursion\n\n# Method 1: Basic recursion\ndef factorial(n: int) -> int:\n    \"\"\"Returns the factorial of n using recursion.\"\"\"\n    # Base cases\n    if n == 0 or n == 1:\n        return 1\n    \n    # Recursive case\n    return n * factorial(n - 1)\n\n# Method 2: With input validation\ndef factorial_safe(n: int) -> int:\n    \"\"\"Factorial with input validation.\"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if n == 0 or n == 1:\n        return 1\n    \n    return n * factorial_safe(n - 1)\n\n# Method 3: With memoization for optimization\ndef factorial_memo(n: int, memo: dict = None) -> int:\n    \"\"\"Factorial with memoization to avoid repeated calculations.\"\"\"\n    if memo is None:\n        memo = {}\n    \n    if n in memo:\n        return memo[n]\n    \n    if n == 0 or n == 1:\n        result = 1\n    else:\n        result = n * factorial_memo(n - 1, memo)\n    \n    memo[n] = result\n    return result\n\n# Method 4: Iterative approach for comparison\ndef factorial_iterative(n: int) -> int:\n    \"\"\"Factorial using iterative approach.\"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be non-negative\")\n    \n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\n# Method 5: Using math library\nimport math\ndef factorial_builtin(n: int) -> int:\n    \"\"\"Using Python's built-in math.factorial.\"\"\"\n    return math.factorial(n)\n\n# Test the functions\nprint(\"Testing factorial():\")\ntest_cases = [0, 1, 2, 3, 4, 5, 6, 10]\n\nfor n in test_cases:\n    try:\n        result1 = factorial(n)\n        result2 = factorial_safe(n)\n        result3 = factorial_memo(n)\n        result4 = factorial_iterative(n)\n        result5 = factorial_builtin(n)\n        \n        all_same = result1 == result2 == result3 == result4 == result5\n        print(f\"factorial({n}) = {result1}, All methods agree: {all_same}\")\n        \n        # Show the calculation for small numbers\n        if n <= 5:\n            if n == 0 or n == 1:\n                calculation = f\"{n}! = 1 (base case)\"\n            else:\n                numbers = list(range(1, n + 1))\n                calculation = f\"{n}! = {' Ã— '.join(map(str, numbers))} = {result1}\"\n            print(f\"  Calculation: {calculation}\")\n        \n    except Exception as e:\n        print(f\"Error with factorial({n}): {e}\")\n\n# Test error handling\nprint(\"\\nTesting error cases:\")\ntry:\n    factorial_safe(-1)\nexcept ValueError as e:\n    print(f\"factorial_safe(-1): {e}\")\n\ntry:\n    factorial_safe(\"5\")\nexcept ValueError as e:\n    print(f\"factorial_safe('5'): {e}\")\n\n# Demonstrate recursion depth for larger numbers\nprint(\"\\nLarge factorials:\")\nfor n in [20, 50]:\n    result = factorial(n)\n    print(f\"factorial({n}) = {result}\")\n\nprint(\"-\" * 50)\n```\n\n## Challenge 10.5: Power Function\n\n**Problem**: Write a function called `power` that calculates x raised to the power of y using recursion.\n\n**Function Signature**: \n```python\ndef power(x: int, y: int) -> int:\n    \"\"\"Returns x raised to the power of y using recursion.\"\"\"\n    pass\n```\n\n**Examples**:\n- `power(2, 3)` â†’ `8` (2Â³ = 2 Ã— 2 Ã— 2)\n- `power(5, 0)` â†’ `1` (any number to power 0 = 1)\n- `power(3, 4)` â†’ `81` (3â´ = 81)\n\n**Mathematical Definition**:\n- `xâ° = 1` (base case)\n- `xÊ¸ = x Ã— x^(y-1)` for y > 0\n\n**Time Complexity**: O(y)  \n**Space Complexity**: O(y) due to call stack\n\n```python\n# Solution for Challenge 10.5: Power Function\n\n# Method 1: Basic recursion\ndef power(x: int, y: int) -> int:\n    \"\"\"Calculate x^y using basic recursion.\"\"\"\n    if y == 0:\n        return 1\n    if y < 0:\n        return 1 / power(x, -y)\n    return x * power(x, y - 1)\n\n# Method 2: Optimized recursion (fast exponentiation)\ndef power_optimized(x: int, y: int) -> int:\n    \"\"\"Calculate x^y using fast exponentiation.\"\"\"\n    if y == 0:\n        return 1\n    if y < 0:\n        return 1 / power_optimized(x, -y)\n    \n    if y % 2 == 0:\n        # Even power: x^y = (x^(y/2))^2\n        half = power_optimized(x, y // 2)\n        return half * half\n    else:\n        # Odd power: x^y = x * x^(y-1)\n        return x * power_optimized(x, y - 1)\n\n# Method 3: Iterative approach\ndef power_iterative(x: int, y: int) -> int:\n    \"\"\"Calculate x^y using iteration.\"\"\"\n    if y == 0:\n        return 1\n    if y < 0:\n        return 1 / power_iterative(x, -y)\n    \n    result = 1\n    for _ in range(y):\n        result *= x\n    return result\n\n# Method 4: Built-in power operator\ndef power_builtin(x: int, y: int) -> int:\n    \"\"\"Calculate x^y using built-in operator.\"\"\"\n    return x ** y\n\n# Method 5: Using math.pow\nimport math\ndef power_math(x: int, y: int) -> float:\n    \"\"\"Calculate x^y using math.pow.\"\"\"\n    return math.pow(x, y)\n\n# Method 6: Binary exponentiation (iterative)\ndef power_binary(x: int, y: int) -> int:\n    \"\"\"Calculate x^y using binary exponentiation.\"\"\"\n    if y == 0:\n        return 1\n    if y < 0:\n        return 1 / power_binary(x, -y)\n    \n    result = 1\n    base = x\n    \n    while y > 0:\n        if y % 2 == 1:\n            result *= base\n        base *= base\n        y //= 2\n    \n    return result\n\n# Test the functions\nprint(\"Testing power() functions:\")\ntest_cases = [\n    (2, 3, 8),\n    (5, 0, 1),\n    (3, 4, 81),\n    (10, 2, 100),\n    (2, 10, 1024),\n    (1, 100, 1),\n    (7, 1, 7),\n    (0, 5, 0),\n    (2, -3, 0.125),  # 1/8\n    (-2, 3, -8),\n    (-3, 2, 9)\n]\n\nfor x, y, expected in test_cases:\n    result1 = power(x, y)\n    result2 = power_optimized(x, y)\n    result3 = power_iterative(x, y)\n    result4 = power_builtin(x, y)\n    result5 = power_math(x, y)\n    result6 = power_binary(x, y)\n    \n    # Handle floating point comparison for negative powers\n    def close_enough(a, b, tolerance=1e-10):\n        return abs(a - b) < tolerance\n    \n    all_same = (close_enough(result1, expected) and \n                close_enough(result2, expected) and\n                close_enough(result3, expected) and\n                close_enough(result4, expected) and\n                close_enough(result5, expected) and\n                close_enough(result6, expected))\n    \n    print(f\"power({x}, {y}) = {result1}, Expected: {expected}, All agree: {all_same}\")\n    \n    # Show calculation for small powers\n    if 0 < y <= 4 and x != 0:\n        if y > 0:\n            calculation = \" Ã— \".join([str(x)] * y)\n            print(f\"  Calculation: {x}^{y} = {calculation} = {expected}\")\n\n# Performance comparison for large exponents\nprint(f\"\\nPerformance comparison for 2^1000:\")\nimport time\n\n# Basic recursion would be too slow for large numbers, so skip it\nprint(\"Skipping basic recursion for large exponent (would cause stack overflow)\")\n\nstart = time.time()\nresult_opt = power_optimized(2, 100)  # Smaller number to avoid overflow\ntime_opt = time.time() - start\n\nstart = time.time()\nresult_binary = power_binary(2, 100)\ntime_binary = time.time() - start\n\nstart = time.time()\nresult_builtin = 2 ** 100\ntime_builtin = time.time() - start\n\nprint(f\"Optimized recursion (2^100): {time_opt:.8f}s\")\nprint(f\"Binary exponentiation (2^100): {time_binary:.8f}s\")\nprint(f\"Built-in operator (2^100): {time_builtin:.8f}s\")\n\nprint(\"\\n\" + \"-\" * 50)\nprint(\"Algorithm Analysis:\")\nprint(\"â€¢ Basic recursion: O(y) time, O(y) space - Simple but slow\")\nprint(\"â€¢ Fast exponentiation: O(log y) time, O(log y) space - Much faster!\")\nprint(\"â€¢ Binary exponentiation: O(log y) time, O(1) space - Optimal\")\nprint(\"â€¢ Built-in **: Highly optimized, use in production\")\nprint(\"-\" * 50)\n```\n\n## Challenge 11: Flatten Array\n\n**Problem:** Write a function to flatten a nested array of arbitrary depth.\n\n**Example:**\n```\nInput: [1, [2, 3], [4, [5, 6]]]\nOutput: [1, 2, 3, 4, 5, 6]\n```\n\n**Learning Goals:**\n- Recursion with different data types\n- Understanding nested data structures  \n- Array traversal techniques\n- Python's flexible typing system\n\n```python\n# Solution for Challenge 11: Flatten Array\n\nfrom typing import List, Union, Any\n\n# Method 1: Recursive approach\ndef flatten_array(arr: List[Union[int, List]]) -> List[int]:\n    \"\"\"Flatten a nested array using recursion.\"\"\"\n    result = []\n    \n    for item in arr:\n        if isinstance(item, list):\n            # Recursively flatten nested lists\n            result.extend(flatten_array(item))\n        else:\n            # Add non-list items directly\n            result.append(item)\n    \n    return result\n\n# Method 2: Using a generator (memory efficient)\ndef flatten_generator(arr: List[Union[int, List]]):\n    \"\"\"Flatten array using generator for memory efficiency.\"\"\"\n    for item in arr:\n        if isinstance(item, list):\n            yield from flatten_generator(item)\n        else:\n            yield item\n\n# Method 3: Iterative approach with stack\ndef flatten_iterative(arr: List[Union[int, List]]) -> List[int]:\n    \"\"\"Flatten array using iterative approach with stack.\"\"\"\n    result = []\n    stack = arr.copy()\n    \n    while stack:\n        item = stack.pop()\n        \n        if isinstance(item, list):\n            # Add list items back to stack in reverse order\n            # to maintain original order\n            stack.extend(reversed(item))\n        else:\n            result.append(item)\n    \n    # Reverse result since we built it backwards\n    return list(reversed(result))\n\n# Method 4: Using numpy (if available)\ntry:\n    import numpy as np\n    def flatten_numpy(arr: List[Union[int, List]]) -> List[int]:\n        \"\"\"Flatten array using numpy.\"\"\"\n        # Convert to numpy array and flatten\n        return np.array(arr, dtype=object).flatten().tolist()\nexcept ImportError:\n    def flatten_numpy(arr):\n        return \"NumPy not available\"\n\n# Method 5: One-liner with string manipulation (hack!)\ndef flatten_string_hack(arr: List[Union[int, List]]) -> List[int]:\n    \"\"\"Flatten using string manipulation - not recommended!\"\"\"\n    # Convert to string, remove brackets, split and convert back\n    import re\n    str_arr = str(arr)\n    # Remove all brackets\n    cleaned = re.sub(r'[\\[\\]]', '', str_arr)\n    # Split by comma and convert to integers\n    return [int(x.strip()) for x in cleaned.split(',') if x.strip()]\n\n# Method 6: Custom recursive with depth limit\ndef flatten_with_depth(arr: List[Union[int, List]], max_depth: int = float('inf')) -> List[int]:\n    \"\"\"Flatten array with optional depth limit.\"\"\"\n    def _flatten_helper(arr, current_depth):\n        result = []\n        \n        for item in arr:\n            if isinstance(item, list) and current_depth < max_depth:\n                result.extend(_flatten_helper(item, current_depth + 1))\n            else:\n                result.append(item)\n        \n        return result\n    \n    return _flatten_helper(arr, 0)\n\n# Test the functions\nprint(\"Testing flatten_array() functions:\")\n\ntest_cases = [\n    ([1, [2, 3], [4, [5, 6]]], [1, 2, 3, 4, 5, 6]),\n    ([1, 2, 3], [1, 2, 3]),  # Already flat\n    ([[1], [2], [3]], [1, 2, 3]),  # Simple nesting\n    ([1, [2, [3, [4]]]], [1, 2, 3, 4]),  # Deep nesting\n    ([], []),  # Empty array\n    ([[[[[1]]]]], [1]),  # Very deep nesting\n    ([1, [2, 3], 4, [5, [6, 7], 8]], [1, 2, 3, 4, 5, 6, 7, 8])  # Mixed nesting\n]\n\nfor i, (input_arr, expected) in enumerate(test_cases, 1):\n    result1 = flatten_array(input_arr)\n    result2 = list(flatten_generator(input_arr))\n    result3 = flatten_iterative(input_arr)\n    result4 = flatten_string_hack(input_arr) if input_arr else []\n    \n    all_same = (result1 == expected and \n                result2 == expected and \n                result3 == expected and\n                result4 == expected)\n    \n    print(f\"Test {i}: {input_arr}\")\n    print(f\"  Expected: {expected}\")\n    print(f\"  Recursive: {result1}\")\n    print(f\"  Generator: {result2}\")\n    print(f\"  Iterative: {result3}\")\n    print(f\"  String hack: {result4}\")\n    print(f\"  All match: {all_same}\\n\")\n\n# Test depth-limited flattening\nprint(\"Testing depth-limited flattening:\")\ndeep_arr = [1, [2, [3, [4, [5]]]]]\n\nfor depth in range(5):\n    result = flatten_with_depth(deep_arr, depth)\n    print(f\"  Depth {depth}: {result}\")\n\n# Performance comparison\nprint(f\"\\nPerformance comparison on large nested array:\")\nimport time\n\n# Create a large nested array\nlarge_arr = []\nfor i in range(100):\n    if i % 10 == 0:\n        large_arr.append([i, i+1, [i+2, i+3]])\n    else:\n        large_arr.append(i)\n\nstart = time.time()\nresult1 = flatten_array(large_arr)\ntime1 = time.time() - start\n\nstart = time.time()\nresult2 = list(flatten_generator(large_arr))\ntime2 = time.time() - start\n\nstart = time.time()\nresult3 = flatten_iterative(large_arr)\ntime3 = time.time() - start\n\nprint(f\"Recursive approach: {time1:.6f}s\")\nprint(f\"Generator approach: {time2:.6f}s\")\nprint(f\"Iterative approach: {time3:.6f}s\")\n\nprint(\"\\n\" + \"-\" * 50)\nprint(\"Algorithm Analysis:\")\nprint(\"â€¢ Recursive: O(n) time, O(d) space - Clean and intuitive\")\nprint(\"â€¢ Generator: O(n) time, O(d) space - Memory efficient for large arrays\")\nprint(\"â€¢ Iterative: O(n) time, O(d) space - No recursion limit issues\")\nprint(\"â€¢ String hack: O(n) time, O(n) space - Fun but not recommended!\")\nprint(\"Where n = total elements, d = maximum depth\")\nprint(\"-\" * 50)\n```\n\n## Challenge 12: Reverse String Using Stack\n\n**Problem:** Write a function to reverse a string using a stack data structure.\n\n**Example:**\n```\nInput: \"hello\"\nOutput: \"olleh\"\n```\n\n**Learning Goals:**\n- Understanding stack (LIFO) data structure\n- String manipulation\n- Custom data structure implementation\n- Multiple approaches comparison\n\n```python\n# Solution for Challenge 12: Reverse String Using Stack\n\n# First, let's implement a simple Stack class\nclass Stack:\n    \"\"\"Simple stack implementation using list.\"\"\"\n    \n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        \"\"\"Add item to top of stack.\"\"\"\n        self.items.append(item)\n    \n    def pop(self):\n        \"\"\"Remove and return top item from stack.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"pop from empty stack\")\n        return self.items.pop()\n    \n    def peek(self):\n        \"\"\"Return top item without removing it.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"peek from empty stack\")\n        return self.items[-1]\n    \n    def is_empty(self):\n        \"\"\"Check if stack is empty.\"\"\"\n        return len(self.items) == 0\n    \n    def size(self):\n        \"\"\"Return number of items in stack.\"\"\"\n        return len(self.items)\n    \n    def __str__(self):\n        \"\"\"String representation of stack.\"\"\"\n        return f\"Stack({self.items})\"\n\n# Method 1: Using custom Stack class\ndef reverse_string_stack(s: str) -> str:\n    \"\"\"Reverse string using custom stack.\"\"\"\n    stack = Stack()\n    \n    # Push all characters onto the stack\n    for char in s:\n        stack.push(char)\n    \n    # Pop all characters to build reversed string\n    reversed_str = \"\"\n    while not stack.is_empty():\n        reversed_str += stack.pop()\n    \n    return reversed_str\n\n# Method 2: Using Python list as stack\ndef reverse_string_list_stack(s: str) -> str:\n    \"\"\"Reverse string using list as stack.\"\"\"\n    stack = []\n    \n    # Push all characters\n    for char in s:\n        stack.append(char)\n    \n    # Pop all characters\n    reversed_str = \"\"\n    while stack:\n        reversed_str += stack.pop()\n    \n    return reversed_str\n\n# Method 3: Using collections.deque as stack\nfrom collections import deque\n\ndef reverse_string_deque_stack(s: str) -> str:\n    \"\"\"Reverse string using deque as stack.\"\"\"\n    stack = deque()\n    \n    # Push all characters\n    for char in s:\n        stack.append(char)\n    \n    # Pop all characters\n    reversed_str = \"\"\n    while stack:\n        reversed_str += stack.pop()\n    \n    return reversed_str\n\n# Method 4: Stack with list comprehension\ndef reverse_string_stack_comprehension(s: str) -> str:\n    \"\"\"Reverse string using stack with list comprehension.\"\"\"\n    stack = list(s)  # All characters on stack\n    return ''.join(stack.pop() for _ in range(len(stack)))\n\n# Method 5: Recursive stack simulation\ndef reverse_string_recursive_stack(s: str) -> str:\n    \"\"\"Reverse string using recursive approach (simulates stack).\"\"\"\n    if len(s) <= 1:\n        return s\n    \n    # First character goes to the end (like popping from stack)\n    return reverse_string_recursive_stack(s[1:]) + s[0]\n\n# Method 6: Using Python's built-in slicing (for comparison)\ndef reverse_string_builtin(s: str) -> str:\n    \"\"\"Reverse string using Python's built-in slicing.\"\"\"\n    return s[::-1]\n\n# Method 7: Stack with generator\ndef reverse_string_generator_stack(s: str) -> str:\n    \"\"\"Reverse string using generator with stack behavior.\"\"\"\n    def char_generator():\n        stack = list(s)\n        while stack:\n            yield stack.pop()\n    \n    return ''.join(char_generator())\n\n# Method 8: Two-pass approach with explicit stack operations\ndef reverse_string_two_pass(s: str) -> str:\n    \"\"\"Reverse string with explicit push and pop phases.\"\"\"\n    stack = []\n    \n    # Phase 1: Push all characters\n    print(f\"Phase 1 - Pushing characters:\")\n    for i, char in enumerate(s):\n        stack.append(char)\n        print(f\"  Push '{char}': stack = {stack}\")\n    \n    # Phase 2: Pop all characters\n    print(f\"Phase 2 - Popping characters:\")\n    reversed_str = \"\"\n    while stack:\n        char = stack.pop()\n        reversed_str += char\n        print(f\"  Pop '{char}': stack = {stack}, result = '{reversed_str}'\")\n    \n    return reversed_str\n\n# Test the functions\nprint(\"Testing reverse string with stack functions:\")\n\ntest_cases = [\n    \"hello\",\n    \"world\",\n    \"Python\",\n    \"a\",\n    \"\",\n    \"12345\",\n    \"racecar\",\n    \"Stack Data Structure\"\n]\n\nfor test_str in test_cases:\n    result1 = reverse_string_stack(test_str)\n    result2 = reverse_string_list_stack(test_str)\n    result3 = reverse_string_deque_stack(test_str)\n    result4 = reverse_string_stack_comprehension(test_str)\n    result5 = reverse_string_recursive_stack(test_str)\n    result6 = reverse_string_builtin(test_str)\n    result7 = reverse_string_generator_stack(test_str)\n    \n    all_same = (result1 == result2 == result3 == result4 == \n                result5 == result6 == result7)\n    \n    print(f\"'{test_str}' -> '{result1}' (All methods agree: {all_same})\")\n\n# Demonstrate stack operations step by step\nprint(f\"\\nStep-by-step demonstration for 'hello':\")\nresult = reverse_string_two_pass(\"hello\")\n\n# Stack behavior visualization\nprint(f\"\\nStack behavior visualization:\")\nstack = Stack()\ninput_str = \"STACK\"\n\nprint(f\"Input: '{input_str}'\")\nprint(f\"1. Pushing characters:\")\nfor char in input_str:\n    stack.push(char)\n    print(f\"   push('{char}') -> {stack}\")\n\nprint(f\"2. Popping characters:\")\nresult = \"\"\nwhile not stack.is_empty():\n    char = stack.pop()\n    result += char\n    print(f\"   pop() -> '{char}', result: '{result}', {stack}\")\n\nprint(f\"Final result: '{result}'\")\n\n# Performance comparison\nprint(f\"\\nPerformance comparison on long string:\")\nimport time\n\nlong_string = \"A\" * 10000\n\nmethods = [\n    (\"Custom Stack\", reverse_string_stack),\n    (\"List Stack\", reverse_string_list_stack),\n    (\"Deque Stack\", reverse_string_deque_stack),\n    (\"List Comprehension\", reverse_string_stack_comprehension),\n    (\"Recursive\", reverse_string_recursive_stack),\n    (\"Built-in Slicing\", reverse_string_builtin),\n    (\"Generator Stack\", reverse_string_generator_stack)\n]\n\nfor name, func in methods:\n    start = time.time()\n    result = func(long_string)\n    duration = time.time() - start\n    print(f\"{name}: {duration:.6f}s\")\n\nprint(\"\\n\" + \"-\" * 50)\nprint(\"Algorithm Analysis:\")\nprint(\"â€¢ All stack methods: O(n) time, O(n) space\")\nprint(\"â€¢ Custom Stack: Educational, shows LIFO principle clearly\")\nprint(\"â€¢ List Stack: Most Pythonic for stack operations\")\nprint(\"â€¢ Deque Stack: Optimal for frequent push/pop operations\")\nprint(\"â€¢ Recursive: O(n) space due to call stack\")\nprint(\"â€¢ Built-in slicing: Fastest but doesn't demonstrate stack concept\")\nprint(\"â€¢ Stack is perfect for reversing due to LIFO (Last In, First Out)\")\nprint(\"-\" * 50)\n```\n\n## Challenge 13: Longest Consecutive Sequence\n\n**Problem:** Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\n\n**Example:**\n```\nInput: [100, 4, 200, 1, 3, 2]\nOutput: 4 (sequence: 1, 2, 3, 4)\n```\n\n**Learning Goals:**\n- Hash set for O(1) lookups\n- Efficient algorithm design\n- Understanding sequence detection\n- Optimization techniques\n\n```python\n# Solution for Challenge 13: Longest Consecutive Sequence\n\nfrom typing import List\n\n# Method 1: Optimal hash set approach\ndef longest_consecutive_optimal(nums: List[int]) -> int:\n    \"\"\"Find longest consecutive sequence using hash set - O(n) time.\"\"\"\n    if not nums:\n        return 0\n    \n    num_set = set(nums)  # O(1) lookup\n    max_length = 0\n    \n    for num in num_set:\n        # Only start counting from the beginning of a sequence\n        # (i.e., when num-1 is not in the set)\n        if num - 1 not in num_set:\n            current_num = num\n            current_length = 1\n            \n            # Count consecutive numbers\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_length += 1\n            \n            max_length = max(max_length, current_length)\n    \n    return max_length\n\n# Method 2: Sorting approach (less optimal but intuitive)\ndef longest_consecutive_sort(nums: List[int]) -> int:\n    \"\"\"Find longest consecutive sequence by sorting - O(n log n) time.\"\"\"\n    if not nums:\n        return 0\n    \n    # Remove duplicates and sort\n    unique_nums = sorted(set(nums))\n    \n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, len(unique_nums)):\n        if unique_nums[i] == unique_nums[i-1] + 1:\n            # Consecutive number found\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            # Sequence broken, reset\n            current_length = 1\n    \n    return max_length\n\n# Method 3: Union-Find approach (overkill but educational)\nclass UnionFind:\n    \"\"\"Union-Find data structure for tracking connected components.\"\"\"\n    \n    def __init__(self, nums):\n        self.parent = {num: num for num in nums}\n        self.size = {num: 1 for num in nums}\n    \n    def find(self, x):\n        \"\"\"Find root of x with path compression.\"\"\"\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        \"\"\"Union two sets and return new size.\"\"\"\n        root_x, root_y = self.find(x), self.find(y)\n        \n        if root_x == root_y:\n            return self.size[root_x]\n        \n        # Union by size\n        if self.size[root_x] < self.size[root_y]:\n            root_x, root_y = root_y, root_x\n        \n        self.parent[root_y] = root_x\n        self.size[root_x] += self.size[root_y]\n        return self.size[root_x]\n\ndef longest_consecutive_union_find(nums: List[int]) -> int:\n    \"\"\"Find longest consecutive sequence using Union-Find.\"\"\"\n    if not nums:\n        return 0\n    \n    unique_nums = set(nums)\n    uf = UnionFind(unique_nums)\n    max_length = 1\n    \n    for num in unique_nums:\n        # Connect with consecutive numbers\n        if num + 1 in unique_nums:\n            new_size = uf.union(num, num + 1)\n            max_length = max(max_length, new_size)\n    \n    return max_length\n\n# Method 4: Dynamic programming approach\ndef longest_consecutive_dp(nums: List[int]) -> int:\n    \"\"\"Find longest consecutive sequence using DP concept.\"\"\"\n    if not nums:\n        return 0\n    \n    # dp[num] = length of sequence ending at num\n    dp = {}\n    max_length = 0\n    \n    for num in nums:\n        if num not in dp:\n            # Check if we can extend existing sequences\n            left_length = dp.get(num - 1, 0)\n            right_length = dp.get(num + 1, 0)\n            \n            # Current sequence length\n            current_length = left_length + right_length + 1\n            dp[num] = current_length\n            \n            # Update endpoints of the merged sequence\n            dp[num - left_length] = current_length\n            dp[num + right_length] = current_length\n            \n            max_length = max(max_length, current_length)\n    \n    return max_length\n\n# Method 5: Brute force (for comparison)\ndef longest_consecutive_brute_force(nums: List[int]) -> int:\n    \"\"\"Find longest consecutive sequence using brute force - O(nÂ³) time.\"\"\"\n    if not nums:\n        return 0\n    \n    max_length = 1\n    \n    for num in nums:\n        current_length = 1\n        current_num = num\n        \n        # Count consecutive numbers going up\n        while current_num + 1 in nums:\n            current_num += 1\n            current_length += 1\n        \n        max_length = max(max_length, current_length)\n    \n    return max_length\n\n# Method 6: Using Counter for sequence building\nfrom collections import Counter\n\ndef longest_consecutive_counter(nums: List[int]) -> int:\n    \"\"\"Find longest consecutive sequence using Counter.\"\"\"\n    if not nums:\n        return 0\n    \n    counter = Counter(nums)\n    max_length = 0\n    \n    for num in counter:\n        if num - 1 not in counter:  # Start of sequence\n            current_num = num\n            current_length = 0\n            \n            while current_num in counter:\n                current_length += 1\n                current_num += 1\n            \n            max_length = max(max_length, current_length)\n    \n    return max_length\n\n# Test the functions\nprint(\"Testing longest_consecutive() functions:\")\n\ntest_cases = [\n    ([100, 4, 200, 1, 3, 2], 4),  # 1,2,3,4\n    ([0, 3, 7, 2, 5, 8, 4, 6, 0, 1], 9),  # 0,1,2,3,4,5,6,7,8\n    ([1, 2, 0, 1], 3),  # 0,1,2\n    ([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6], 7),  # -1,0,1,3,4,5,6,7,8,9 -> 3,4,5,6,7,8,9\n    ([], 0),  # Empty array\n    ([1], 1),  # Single element\n    ([1, 3, 5, 7], 1),  # No consecutive numbers\n    ([2, 1, 3, 4, 5], 5),  # Already mostly consecutive\n    ([10, 5, 12, 3, 55, 30, 4, 11, 2], 4),  # 2,3,4,5\n    ([1, 1, 1, 1], 1)  # Duplicates\n]\n\nmethods = [\n    (\"Optimal (Hash Set)\", longest_consecutive_optimal),\n    (\"Sorting\", longest_consecutive_sort),\n    (\"Union-Find\", longest_consecutive_union_find),\n    (\"Dynamic Programming\", longest_consecutive_dp),\n    (\"Counter\", longest_consecutive_counter),\n    (\"Brute Force\", longest_consecutive_brute_force)\n]\n\nfor i, (input_nums, expected) in enumerate(test_cases, 1):\n    print(f\"Test {i}: {input_nums}\")\n    print(f\"Expected: {expected}\")\n    \n    all_correct = True\n    for name, func in methods:\n        try:\n            result = func(input_nums.copy())\n            is_correct = result == expected\n            if not is_correct:\n                all_correct = False\n            print(f\"  {name}: {result} {'âœ“' if is_correct else 'âœ—'}\")\n        except Exception as e:\n            print(f\"  {name}: Error - {e}\")\n            all_correct = False\n    \n    print(f\"  All correct: {all_correct}\\n\")\n\n# Detailed example walkthrough\nprint(\"Detailed walkthrough for [100, 4, 200, 1, 3, 2]:\")\nnums = [100, 4, 200, 1, 3, 2]\nnum_set = set(nums)\nprint(f\"Set: {sorted(num_set)}\")\n\nsequences = []\nfor num in sorted(num_set):\n    if num - 1 not in num_set:  # Start of sequence\n        sequence = [num]\n        current = num\n        while current + 1 in num_set:\n            current += 1\n            sequence.append(current)\n        sequences.append(sequence)\n\nprint(f\"Found sequences: {sequences}\")\nlongest = max(sequences, key=len)\nprint(f\"Longest sequence: {longest} (length: {len(longest)})\")\n\n# Performance comparison\nprint(f\"\\nPerformance comparison on larger array:\")\nimport time\nimport random\n\n# Generate test data\nlarge_nums = list(range(1000, 2000)) + list(range(500, 600)) + list(range(2500, 2600))\nrandom.shuffle(large_nums)\n\nfor name, func in methods:\n    if name == \"Brute Force\":\n        print(f\"{name}: Skipped (too slow for large input)\")\n        continue\n    \n    start = time.time()\n    result = func(large_nums)\n    duration = time.time() - start\n    print(f\"{name}: {result} in {duration:.6f}s\")\n\nprint(\"\\n\" + \"-\" * 50)\nprint(\"Algorithm Analysis:\")\nprint(\"â€¢ Optimal (Hash Set): O(n) time, O(n) space - Best approach!\")\nprint(\"â€¢ Sorting: O(n log n) time, O(1) space - Good if space is limited\")\nprint(\"â€¢ Union-Find: O(n Î±(n)) time, O(n) space - Overkill but educational\")\nprint(\"â€¢ Dynamic Programming: O(n) time, O(n) space - Alternative approach\")\nprint(\"â€¢ Brute Force: O(nÂ³) time, O(1) space - Avoid in practice\")\nprint(\"â€¢ Key insight: Only check sequences starting from their minimum\")\nprint(\"-\" * 50)\n```\n\n## Challenge 11: Fibonacci Sequence\n\n**Problem**: Write a function called `fibonacci` that returns the nth number in the Fibonacci sequence using recursion.\n\n**Fibonacci Definition**:\n- `F(0) = 0` (base case)\n- `F(1) = 1` (base case)\n- `F(n) = F(n-1) + F(n-2)` for n > 1\n\n**Sequence**: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55...\n\n**Function Signature**: \n```python\ndef fibonacci(n: int) -> int:\n    \"\"\"Returns the nth Fibonacci number using recursion.\"\"\"\n    pass\n```\n\n**Examples**:\n- `fibonacci(0)` â†’ `0`\n- `fibonacci(1)` â†’ `1`\n- `fibonacci(6)` â†’ `8`\n- `fibonacci(10)` â†’ `55`\n\n**Time Complexity**: O(2^n) naive recursion, O(n) with memoization  \n**Space Complexity**: O(n)\n\n```python\n# Solution for Challenge 11: Fibonacci Sequence\nimport time\nfrom functools import lru_cache\n\n# Method 1: Basic recursion (inefficient for large n)\ndef fibonacci_basic(n: int) -> int:\n    \"\"\"Basic recursive Fibonacci (O(2^n) time complexity).\"\"\"\n    if n <= 1:\n        return n\n    return fibonacci_basic(n - 1) + fibonacci_basic(n - 2)\n\n# Method 2: Recursion with memoization\ndef fibonacci_memo(n: int, memo: dict = None) -> int:\n    \"\"\"Fibonacci with memoization.\"\"\"\n    if memo is None:\n        memo = {}\n    \n    if n in memo:\n        return memo[n]\n    \n    if n <= 1:\n        result = n\n    else:\n        result = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)\n    \n    memo[n] = result\n    return result\n\n# Method 3: Using @lru_cache decorator (built-in memoization)\n@lru_cache(maxsize=None)\ndef fibonacci_lru(n: int) -> int:\n    \"\"\"Fibonacci with LRU cache decorator.\"\"\"\n    if n <= 1:\n        return n\n    return fibonacci_lru(n - 1) + fibonacci_lru(n - 2)\n\n# Method 4: Iterative approach (most efficient)\ndef fibonacci_iterative(n: int) -> int:\n    \"\"\"Iterative Fibonacci (O(n) time, O(1) space).\"\"\"\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Method 5: Generator approach\ndef fibonacci_generator(n: int):\n    \"\"\"Generator that yields Fibonacci numbers up to n.\"\"\"\n    a, b = 0, 1\n    for _ in range(n + 1):\n        yield a\n        a, b = b, a + b\n\n# Method 6: Matrix exponentiation (advanced)\ndef fibonacci_matrix(n: int) -> int:\n    \"\"\"Fibonacci using matrix exponentiation (O(log n)).\"\"\"\n    if n <= 1:\n        return n\n    \n    def matrix_multiply(A, B):\n        return [[A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],\n                [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]]\n    \n    def matrix_power(matrix, power):\n        if power == 1:\n            return matrix\n        if power % 2 == 0:\n            half_power = matrix_power(matrix, power // 2)\n            return matrix_multiply(half_power, half_power)\n        else:\n            return matrix_multiply(matrix, matrix_power(matrix, power - 1))\n    \n    fib_matrix = [[1, 1], [1, 0]]\n    result_matrix = matrix_power(fib_matrix, n)\n    return result_matrix[0][1]\n\n# Test and compare different approaches\nprint(\"Testing Fibonacci implementations:\")\n\n# Test small numbers with all methods\nsmall_test_cases = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint(\"\\nSmall numbers (all methods):\")\nfor n in small_test_cases:\n    basic = fibonacci_basic(n)\n    memo = fibonacci_memo(n)\n    lru = fibonacci_lru(n)\n    iterative = fibonacci_iterative(n)\n    matrix = fibonacci_matrix(n)\n    \n    all_same = basic == memo == lru == iterative == matrix\n    print(f\"F({n}) = {basic}, All methods agree: {all_same}\")\n\n# Show the sequence\nprint(f\"\\nFibonacci sequence (first 15 numbers):\")\nsequence = list(fibonacci_generator(14))\nprint(sequence)\n\n# Performance comparison for larger numbers\nprint(\"\\nPerformance comparison (time in seconds):\")\ntest_n = 30\n\nprint(f\"Testing fibonacci({test_n}):\")\n\n# Basic recursion (warning: very slow for n > 35)\nif test_n <= 35:\n    start = time.time()\n    result_basic = fibonacci_basic(test_n)\n    time_basic = time.time() - start\n    print(f\"  Basic recursion: {result_basic} (time: {time_basic:.6f}s)\")\n\n# Memoized recursion\nstart = time.time()\nresult_memo = fibonacci_memo(test_n)\ntime_memo = time.time() - start\nprint(f\"  Memoized recursion: {result_memo} (time: {time_memo:.6f}s)\")\n\n# LRU cache\nfibonacci_lru.cache_clear()  # Clear cache for fair comparison\nstart = time.time()\nresult_lru = fibonacci_lru(test_n)\ntime_lru = time.time() - start\nprint(f\"  LRU cache: {result_lru} (time: {time_lru:.6f}s)\")\n\n# Iterative\nstart = time.time()\nresult_iterative = fibonacci_iterative(test_n)\ntime_iterative = time.time() - start\nprint(f\"  Iterative: {result_iterative} (time: {time_iterative:.6f}s)\")\n\n# Matrix exponentiation\nstart = time.time()\nresult_matrix = fibonacci_matrix(test_n)\ntime_matrix = time.time() - start\nprint(f\"  Matrix exponentiation: {result_matrix} (time: {time_matrix:.6f}s)\")\n\n# Test very large numbers with efficient methods\nprint(f\"\\nLarge Fibonacci numbers:\")\nlarge_numbers = [50, 100, 500]\nfor n in large_numbers:\n    result = fibonacci_iterative(n)\n    print(f\"F({n}) = {result}\")\n\nprint(\"-\" * 50)\n```\n\n# ðŸŽ¯ Summary & Learning Outcomes\n\n## What You've Learned\n\n### 1. **Basic Programming Concepts**\n- Function definitions and type hints\n- String manipulation and processing\n- Mathematical operations and validations\n- Error handling and edge cases\n\n### 2. **Algorithm Techniques**\n- **Iteration**: Loops for sequential processing\n- **Two-pointer**: Efficient string/array processing\n- **Mathematical formulas**: Sum formulas, XOR operations\n- **String operations**: Cleaning, validation, transformation\n\n### 3. **Functional Programming**\n- **Higher-order functions**: `filter()`, `map()`, `reduce()`\n- **List comprehensions**: Pythonic data processing\n- **Lambda functions**: Inline function definitions\n- **Generator expressions**: Memory-efficient iteration\n\n### 4. **Recursion Mastery**\n- **Base cases**: Stopping conditions\n- **Recursive relations**: Problem decomposition\n- **Memoization**: Optimization techniques\n- **Time/space complexity**: Analysis and improvement\n\n### 5. **Python Best Practices**\n- **Multiple solution approaches**: Different ways to solve problems\n- **Performance optimization**: Comparing time complexities\n- **Code readability**: Clean, documented solutions\n- **Built-in utilities**: Leveraging Python's standard library\n\n## Key Problem-Solving Patterns\n\n| Pattern | When to Use | Examples |\n|---------|-------------|----------|\n| **Iteration** | Sequential processing | String reversal, counting |\n| **Two Pointers** | Array/string comparison | Palindrome check |\n| **Mathematical** | Number sequences | Missing number, factorial |\n| **Functional** | Data transformation | Filter-map-reduce chains |\n| **Recursion** | Self-similar subproblems | Fibonacci, factorial |\n| **Memoization** | Overlapping subproblems | Optimized Fibonacci |\n\n## Complexity Analysis Summary\n\n| Challenge | Best Time | Best Space | Approach |\n|-----------|-----------|------------|----------|\n| Hello World | O(1) | O(1) | Direct return |\n| Palindrome | O(n) | O(1) | Two pointers |\n| FizzBuzz | O(n) | O(n) | Conditional logic |\n| Missing Number | O(n) | O(1) | Mathematical formula |\n| Even Squares | O(n) | O(k) | Functional programming |\n| Factorial | O(n) | O(1) | Iterative approach |\n| Fibonacci | O(n) | O(1) | Iterative/Matrix |\n\n## Next Steps\n\n1. **Practice more problems** on platforms like LeetCode, HackerRank\n2. **Study data structures**: Lists, stacks, queues, trees, graphs\n3. **Learn algorithms**: Sorting, searching, dynamic programming\n4. **Build projects**: Apply these concepts in real applications\n5. **Interview preparation**: Practice explaining your solutions\n\nRemember: **Understanding multiple approaches** to solve the same problem makes you a better programmer! ðŸš€\n\n# ðŸ“š Section 5: Complexity Analysis & Optimization\n\nUnderstanding algorithm efficiency through time and space complexity analysis.\n\n## Challenge 12: Big O Notation Examples\n\n**Problem**: Demonstrate different time complexities with practical examples.\n\n**Key Concepts**:\n- **O(1)**: Constant time - Same execution time regardless of input size\n- **O(log n)**: Logarithmic time - Execution time grows logarithmically  \n- **O(n)**: Linear time - Execution time grows linearly with input\n- **O(nÂ²)**: Quadratic time - Execution time grows quadratically\n- **O(2^n)**: Exponential time - Execution time doubles with each input increase\n\n**Learning Objective**: Understand how to analyze and compare algorithm efficiency.\n\n```python\n# Challenge 12: Big O Notation Examples\nimport time\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# O(1) - Constant Time\ndef constant_time_example(arr):\n    \"\"\"O(1) - Getting first element regardless of array size.\"\"\"\n    if arr:\n        return arr[0]\n    return None\n\n# O(log n) - Logarithmic Time\ndef binary_search(arr, target):\n    \"\"\"O(log n) - Binary search on sorted array.\"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\n# O(n) - Linear Time\ndef linear_search(arr, target):\n    \"\"\"O(n) - Linear search through array.\"\"\"\n    for i, value in enumerate(arr):\n        if value == target:\n            return i\n    return -1\n\n# O(nÂ²) - Quadratic Time\ndef bubble_sort(arr):\n    \"\"\"O(nÂ²) - Bubble sort algorithm.\"\"\"\n    arr = arr.copy()\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    \n    return arr\n\n# O(2^n) - Exponential Time\ndef fibonacci_exponential(n):\n    \"\"\"O(2^n) - Inefficient recursive Fibonacci.\"\"\"\n    if n <= 1:\n        return n\n    return fibonacci_exponential(n - 1) + fibonacci_exponential(n - 2)\n\n# O(n log n) - Linearithmic Time\ndef merge_sort(arr):\n    \"\"\"O(n log n) - Merge sort algorithm.\"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    \"\"\"Helper function for merge sort.\"\"\"\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\n# Performance measurement function\ndef measure_time(func, *args):\n    \"\"\"Measure execution time of a function.\"\"\"\n    start = time.time()\n    result = func(*args)\n    end = time.time()\n    return end - start, result\n\n# Demonstrate different complexities\nprint(\"Big O Complexity Examples:\")\nprint(\"=\" * 50)\n\n# Test with different input sizes\nsizes = [10, 100, 1000]\n\nfor size in sizes:\n    print(f\"\\nInput size: {size}\")\n    print(\"-\" * 30)\n    \n    # Create test data\n    test_array = list(range(size))\n    target = size - 1  # Last element\n    \n    # O(1) - Constant time\n    time_o1, _ = measure_time(constant_time_example, test_array)\n    print(f\"O(1) - Constant time: {time_o1:.6f}s\")\n    \n    # O(log n) - Logarithmic time\n    time_log_n, _ = measure_time(binary_search, test_array, target)\n    print(f\"O(log n) - Binary search: {time_log_n:.6f}s\")\n    \n    # O(n) - Linear time\n    time_n, _ = measure_time(linear_search, test_array, target)\n    print(f\"O(n) - Linear search: {time_n:.6f}s\")\n    \n    # O(n log n) - Linearithmic time (only for smaller arrays)\n    if size <= 1000:\n        time_n_log_n, _ = measure_time(merge_sort, test_array[::-1])  # Reverse sorted\n        print(f\"O(n log n) - Merge sort: {time_n_log_n:.6f}s\")\n    \n    # O(nÂ²) - Quadratic time (only for small arrays)\n    if size <= 100:\n        time_n2, _ = measure_time(bubble_sort, test_array[::-1])  # Worst case\n        print(f\"O(nÂ²) - Bubble sort: {time_n2:.6f}s\")\n\n# Demonstrate exponential growth (be careful with large numbers!)\nprint(f\"\\nO(2^n) - Exponential time (Fibonacci):\")\nprint(\"-\" * 40)\nfor n in range(1, 31, 5):\n    if n <= 25:  # Only up to 25 to avoid long wait times\n        time_exp, result = measure_time(fibonacci_exponential, n)\n        print(f\"F({n}) = {result}, Time: {time_exp:.6f}s\")\n\nprint(\"\\n\" + \"=\" * 50)\nprint(\"Key Insights:\")\nprint(\"â€¢ O(1): Always fast, regardless of input size\")\nprint(\"â€¢ O(log n): Scales very well, even for large inputs\")\nprint(\"â€¢ O(n): Scales linearly with input size\")\nprint(\"â€¢ O(n log n): Good for sorting large datasets\")\nprint(\"â€¢ O(nÂ²): Becomes slow quickly as input grows\")\nprint(\"â€¢ O(2^n): Only practical for very small inputs\")\nprint(\"=\" * 50)\n```\n\n# ðŸ“š Section 6: Hash Tables, Maps & Sets\n\nHash tables, dictionaries, and sets are fundamental data structures for fast lookups and eliminating duplicates.\n\n## Challenge 13: Two Sum Problem\n\n**Problem**: Given an array of integers and a target sum, return the indices of two numbers that add up to the target.\n\n**Function Signature**: \n```python\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"Returns indices of two numbers that add up to target.\"\"\"\n    pass\n```\n\n**Examples**:\n- `two_sum([2, 7, 11, 15], 9)` â†’ `[0, 1]` (2 + 7 = 9)\n- `two_sum([3, 2, 4], 6)` â†’ `[1, 2]` (2 + 4 = 6)\n- `two_sum([3, 3], 6)` â†’ `[0, 1]` (3 + 3 = 6)\n\n**Constraints**:\n- Each input has exactly one solution\n- Can't use the same element twice\n\n**Time Complexity**: O(n) with hash map  \n**Space Complexity**: O(n)\n\n```python\n# Solution for Challenge 13: Two Sum Problem\n\n# Method 1: Brute Force (O(nÂ²) time, O(1) space)\ndef two_sum_brute_force(nums: list[int], target: int) -> list[int]:\n    \"\"\"Brute force approach - check all pairs.\"\"\"\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n\n# Method 2: Hash Map (O(n) time, O(n) space) - Optimal\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"Hash map approach for O(n) time complexity.\"\"\"\n    num_map = {}  # value -> index\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    \n    return []\n\n# Method 3: Two-pointer approach (only works with sorted array)\ndef two_sum_sorted(nums: list[int], target: int) -> list[int]:\n    \"\"\"Two-pointer approach for sorted array.\"\"\"\n    # Create array of (value, original_index) pairs\n    indexed_nums = [(nums[i], i) for i in range(len(nums))]\n    indexed_nums.sort()  # Sort by value\n    \n    left, right = 0, len(indexed_nums) - 1\n    \n    while left < right:\n        current_sum = indexed_nums[left][0] + indexed_nums[right][0]\n        if current_sum == target:\n            # Return original indices\n            return sorted([indexed_nums[left][1], indexed_nums[right][1]])\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\n# Method 4: Using collections.Counter for frequency counting\nfrom collections import Counter\n\ndef two_sum_counter(nums: list[int], target: int) -> list[int]:\n    \"\"\"Using Counter to handle duplicates.\"\"\"\n    counter = Counter(nums)\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in counter:\n            if complement != num:\n                # Different numbers\n                complement_index = nums.index(complement)\n                return sorted([i, complement_index])\n            elif counter[num] > 1:\n                # Same number appears twice\n                first_index = i\n                second_index = nums.index(num, i + 1)\n                return [first_index, second_index]\n    \n    return []\n\n# Test the functions\nprint(\"Testing two_sum() methods:\")\ntest_cases = [\n    ([2, 7, 11, 15], 9, [0, 1]),\n    ([3, 2, 4], 6, [1, 2]),\n    ([3, 3], 6, [0, 1]),\n    ([1, 2, 3, 4, 5], 8, [2, 4]),\n    ([2, 5, 5, 11], 10, [1, 2]),\n    ([-1, -2, -3, -4, -5], -8, [2, 4])\n]\n\nfor nums, target, expected in test_cases:\n    result1 = two_sum_brute_force(nums, target)\n    result2 = two_sum(nums, target)\n    result3 = two_sum_sorted(nums, target)\n    result4 = two_sum_counter(nums, target)\n    \n    print(f\"Input: nums={nums}, target={target}\")\n    print(f\"Expected: {expected}\")\n    print(f\"Brute force: {result1}\")\n    print(f\"Hash map: {result2}\")\n    print(f\"Two pointer: {result3}\")\n    print(f\"Counter: {result4}\")\n    \n    # Verify all methods give correct answer\n    all_correct = all(\n        sorted(result) == sorted(expected) \n        for result in [result1, result2, result3, result4]\n        if result\n    )\n    print(f\"All methods correct: {all_correct}\")\n    print(\"-\" * 50)\n\n# Performance comparison\nprint(\"Performance Comparison:\")\nprint(\"=\" * 30)\n\n# Test with larger array\nlarge_nums = list(range(1000))\nlarge_target = 1500\n\nimport time\n\n# Brute force (comment out for very large arrays as it's slow)\nstart = time.time()\nresult_brute = two_sum_brute_force(large_nums[:100], 150)  # Smaller subset\ntime_brute = time.time() - start\n\n# Hash map approach\nstart = time.time()\nresult_hash = two_sum(large_nums, large_target)\ntime_hash = time.time() - start\n\nprint(f\"Brute force (100 elements): {time_brute:.6f}s\")\nprint(f\"Hash map (1000 elements): {time_hash:.6f}s\")\nprint(f\"Hash map result for {large_target}: {result_hash}\")\n\nprint(\"\\n\" + \"=\" * 50)\nprint(\"Algorithm Analysis:\")\nprint(\"â€¢ Brute Force: O(nÂ²) time, O(1) space - Simple but slow\")\nprint(\"â€¢ Hash Map: O(n) time, O(n) space - Optimal solution\")  \nprint(\"â€¢ Two Pointer: O(n log n) time, O(n) space - Good for sorted arrays\")\nprint(\"=\" * 50)\n```\n\n# ðŸ“š Section 7: Stacks, Queues & Linked Lists\n\nLinear data structures that organize data in different ways for specific use cases.\n\n## Challenge 14: Balanced Parentheses\n\n**Problem**: Write a function called `is_balanced` that checks if parentheses in a string are balanced using a stack.\n\n**Function Signature**: \n```python\ndef is_balanced(s: str) -> bool:\n    \"\"\"Returns True if parentheses are balanced.\"\"\"\n    pass\n```\n\n**Examples**:\n- `is_balanced('()')` â†’ `True`\n- `is_balanced('(()())')` â†’ `True`\n- `is_balanced('(()')` â†’ `False`\n- `is_balanced(')(')`â†’ `False`\n- `is_balanced('([{}])')` â†’ `True`\n\n**Key Concepts**:\n- **Stack**: LIFO (Last In, First Out) data structure\n- **Push**: Add element to top\n- **Pop**: Remove element from top\n\n**Time Complexity**: O(n)  \n**Space Complexity**: O(n)\n\n```python\n# Solution for Challenge 14: Balanced Parentheses\n\n# First, let's implement a basic Stack class\nclass Stack:\n    \"\"\"Simple stack implementation using list.\"\"\"\n    \n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        \"\"\"Add item to top of stack.\"\"\"\n        self.items.append(item)\n    \n    def pop(self):\n        \"\"\"Remove and return top item from stack.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Pop from empty stack\")\n        return self.items.pop()\n    \n    def peek(self):\n        \"\"\"Return top item without removing it.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Peek from empty stack\")\n        return self.items[-1]\n    \n    def is_empty(self):\n        \"\"\"Check if stack is empty.\"\"\"\n        return len(self.items) == 0\n    \n    def size(self):\n        \"\"\"Return number of items in stack.\"\"\"\n        return len(self.items)\n    \n    def __str__(self):\n        return f\"Stack({self.items})\"\n\n# Method 1: Using custom Stack class (simple parentheses only)\ndef is_balanced_simple(s: str) -> bool:\n    \"\"\"Check balanced parentheses using custom stack.\"\"\"\n    stack = Stack()\n    \n    for char in s:\n        if char == '(':\n            stack.push(char)\n        elif char == ')':\n            if stack.is_empty():\n                return False\n            stack.pop()\n    \n    return stack.is_empty()\n\n# Method 2: Using Python list as stack (multiple bracket types)\ndef is_balanced(s: str) -> bool:\n    \"\"\"Check balanced brackets using list as stack.\"\"\"\n    stack = []\n    opening = {'(', '[', '{'}\n    closing = {')', ']', '}'}\n    pairs = {'(': ')', '[': ']', '{': '}'}\n    \n    for char in s:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack:\n                return False\n            last_opening = stack.pop()\n            if pairs[last_opening] != char:\n                return False\n    \n    return len(stack) == 0\n\n# Method 3: Using dictionary mapping for bracket matching\ndef is_balanced_dict(s: str) -> bool:\n    \"\"\"Check balanced brackets using dictionary mapping.\"\"\"\n    stack = []\n    bracket_map = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in bracket_map:  # Closing bracket\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n        elif char in bracket_map.values():  # Opening bracket\n            stack.append(char)\n    \n    return not stack\n\n# Method 4: Filter only brackets from string\ndef is_balanced_filter(s: str) -> bool:\n    \"\"\"Check balanced brackets after filtering non-bracket characters.\"\"\"\n    brackets = ''.join(char for char in s if char in '()[]{]}')\n    stack = []\n    pairs = {'(': ')', '[': ']', '{': '}'}\n    \n    for char in brackets:\n        if char in pairs:  # Opening bracket\n            stack.append(char)\n        else:  # Closing bracket\n            if not stack:\n                return False\n            last = stack.pop()\n            if pairs.get(last) != char:\n                return False\n    \n    return not stack\n\n# Method 5: Using collections.deque (more efficient for large inputs)\nfrom collections import deque\n\ndef is_balanced_deque(s: str) -> bool:\n    \"\"\"Check balanced brackets using deque.\"\"\"\n    stack = deque()\n    pairs = {'(': ')', '[': ']', '{': '}'}\n    \n    for char in s:\n        if char in pairs:\n            stack.append(char)\n        elif char in pairs.values():\n            if not stack:\n                return False\n            last = stack.pop()\n            if pairs[last] != char:\n                return False\n    \n    return not stack\n\n# Test the functions\nprint(\"Testing balanced parentheses functions:\")\nprint(\"=\" * 50)\n\ntest_cases = [\n    ('()', True),\n    ('(()())', True),\n    ('(()', False),\n    (')(', False),\n    ('([{}])', True),\n    ('([)]', False),\n    ('(((', False),\n    ('))))', False),\n    ('', True),\n    ('()[]{}', True),\n    ('([{}]())', True),\n    ('(hello[world{test}])', True),\n    ('print(\"Hello World\")', True),\n    ('function(arr[0], {key: value})', True),\n    ('if (x > 0 and arr[i] == target):', True),\n    ('mismatched(]', False)\n]\n\nfor test_str, expected in test_cases:\n    result1 = is_balanced_simple(test_str) if all(c in '()' for c in test_str if c in '()[]{}') else None\n    result2 = is_balanced(test_str)\n    result3 = is_balanced_dict(test_str)\n    result4 = is_balanced_filter(test_str)\n    result5 = is_balanced_deque(test_str)\n    \n    # For simple cases, all methods should agree\n    methods_agree = result2 == result3 == result4 == result5 == expected\n    \n    print(f\"Input: '{test_str}'\")\n    print(f\"Expected: {expected}\")\n    print(f\"Result: {result2}\")\n    print(f\"All methods agree: {methods_agree}\")\n    \n    if not methods_agree:\n        print(f\"  Simple: {result1}, Dict: {result3}, Filter: {result4}, Deque: {result5}\")\n    print(\"-\" * 30)\n\n# Demonstrate stack operations\nprint(\"\\nStack Operations Demo:\")\nprint(\"=\" * 30)\n\nstack = Stack()\noperations = [\n    ('push', '('),\n    ('push', '['),\n    ('peek', None),\n    ('pop', None),\n    ('push', '{'),\n    ('size', None),\n    ('pop', None),\n    ('pop', None),\n    ('is_empty', None)\n]\n\nfor op, value in operations:\n    try:\n        if op == 'push':\n            stack.push(value)\n            print(f\"push('{value}') -> {stack}\")\n        elif op == 'pop':\n            popped = stack.pop()\n            print(f\"pop() -> '{popped}', stack: {stack}\")\n        elif op == 'peek':\n            peeked = stack.peek()\n            print(f\"peek() -> '{peeked}', stack: {stack}\")\n        elif op == 'size':\n            size = stack.size()\n            print(f\"size() -> {size}\")\n        elif op == 'is_empty':\n            empty = stack.is_empty()\n            print(f\"is_empty() -> {empty}\")\n    except IndexError as e:\n        print(f\"{op}() -> Error: {e}\")\n\nprint(\"\\n\" + \"=\" * 50)\nprint(\"Algorithm Insights:\")\nprint(\"â€¢ Stack is perfect for matching pairs (LIFO property)\")\nprint(\"â€¢ Always push opening brackets onto stack\")\nprint(\"â€¢ Pop and match when encountering closing brackets\")\nprint(\"â€¢ Balanced if stack is empty at the end\")\nprint(\"â€¢ Unbalanced if trying to pop from empty stack\")\nprint(\"=\" * 50)\n```\n\n# ðŸ“š Section 8: Binary Trees & Graphs\n\nTree and graph data structures for hierarchical and network relationships.\n\n## Challenge 15: Binary Tree Implementation & Traversal\n\n**Problem**: Implement a binary tree with common operations and traversal methods.\n\n**Key Concepts**:\n- **Node**: Contains data and references to left and right children\n- **Depth-First Traversal**: In-order, Pre-order, Post-order\n- **Breadth-First Traversal**: Level-order using queue\n- **Tree Properties**: Height, depth, balanced trees\n\n**Applications**:\n- File systems, decision trees, expression parsing\n- Database indices, priority queues\n- Abstract syntax trees in compilers\n\n**Time Complexity**: O(n) for traversals  \n**Space Complexity**: O(h) where h is height\n\n```python\n# Solution for Challenge 15: Binary Tree Implementation & Traversal\nfrom collections import deque\nfrom typing import Optional, List\n\nclass TreeNode:\n    \"\"\"Binary tree node class.\"\"\"\n    \n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    \n    def __str__(self):\n        return f\"TreeNode({self.val})\"\n\nclass BinaryTree:\n    \"\"\"Binary tree implementation with traversal methods.\"\"\"\n    \n    def __init__(self, root=None):\n        self.root = root\n    \n    # DEPTH-FIRST TRAVERSALS (Recursive)\n    \n    def inorder_traversal(self, node=None) -> List[int]:\n        \"\"\"In-order: Left -> Root -> Right\"\"\"\n        if node is None:\n            node = self.root\n        \n        result = []\n        if node:\n            result.extend(self.inorder_traversal(node.left))\n            result.append(node.val)\n            result.extend(self.inorder_traversal(node.right))\n        return result\n    \n    def preorder_traversal(self, node=None) -> List[int]:\n        \"\"\"Pre-order: Root -> Left -> Right\"\"\"\n        if node is None:\n            node = self.root\n        \n        result = []\n        if node:\n            result.append(node.val)\n            result.extend(self.preorder_traversal(node.left))\n            result.extend(self.preorder_traversal(node.right))\n        return result\n    \n    def postorder_traversal(self, node=None) -> List[int]:\n        \"\"\"Post-order: Left -> Right -> Root\"\"\"\n        if node is None:\n            node = self.root\n        \n        result = []\n        if node:\n            result.extend(self.postorder_traversal(node.left))\n            result.extend(self.postorder_traversal(node.right))\n            result.append(node.val)\n        return result\n    \n    # DEPTH-FIRST TRAVERSALS (Iterative)\n    \n    def inorder_iterative(self) -> List[int]:\n        \"\"\"In-order traversal using stack (iterative).\"\"\"\n        result = []\n        stack = []\n        current = self.root\n        \n        while stack or current:\n            # Go to leftmost node\n            while current:\n                stack.append(current)\n                current = current.left\n            \n            # Process node\n            current = stack.pop()\n            result.append(current.val)\n            \n            # Move to right subtree\n            current = current.right\n        \n        return result\n    \n    def preorder_iterative(self) -> List[int]:\n        \"\"\"Pre-order traversal using stack (iterative).\"\"\"\n        if not self.root:\n            return []\n        \n        result = []\n        stack = [self.root]\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            # Push right first (so left is processed first)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return result\n    \n    # BREADTH-FIRST TRAVERSAL\n    \n    def level_order_traversal(self) -> List[List[int]]:\n        \"\"\"Level-order (breadth-first) traversal.\"\"\"\n        if not self.root:\n            return []\n        \n        result = []\n        queue = deque([self.root])\n        \n        while queue:\n            level_size = len(queue)\n            level_values = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                level_values.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(level_values)\n        \n        return result\n    \n    def level_order_flat(self) -> List[int]:\n        \"\"\"Level-order traversal returning flat list.\"\"\"\n        if not self.root:\n            return []\n        \n        result = []\n        queue = deque([self.root])\n        \n        while queue:\n            node = queue.popleft()\n            result.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        return result\n    \n    # TREE PROPERTIES\n    \n    def max_depth(self, node=None) -> int:\n        \"\"\"Calculate maximum depth (height) of the tree.\"\"\"\n        if node is None:\n            node = self.root\n        \n        if not node:\n            return 0\n        \n        left_depth = self.max_depth(node.left)\n        right_depth = self.max_depth(node.right)\n        \n        return 1 + max(left_depth, right_depth)\n    \n    def min_depth(self, node=None) -> int:\n        \"\"\"Calculate minimum depth of the tree.\"\"\"\n        if node is None:\n            node = self.root\n        \n        if not node:\n            return 0\n        \n        # If one subtree is empty, return depth of other subtree + 1\n        if not node.left:\n            return 1 + self.min_depth(node.right)\n        if not node.right:\n            return 1 + self.min_depth(node.left)\n        \n        # Both subtrees exist\n        return 1 + min(self.min_depth(node.left), self.min_depth(node.right))\n    \n    def is_symmetric(self) -> bool:\n        \"\"\"Check if tree is symmetric (mirror of itself).\"\"\"\n        def is_mirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return (left.val == right.val and \n                   is_mirror(left.left, right.right) and \n                   is_mirror(left.right, right.left))\n        \n        return is_mirror(self.root, self.root)\n    \n    def diameter(self) -> int:\n        \"\"\"Calculate diameter (longest path between any two nodes).\"\"\"\n        self.max_diameter = 0\n        \n        def depth(node):\n            if not node:\n                return 0\n            \n            left_depth = depth(node.left)\n            right_depth = depth(node.right)\n            \n            # Update diameter\n            self.max_diameter = max(self.max_diameter, left_depth + right_depth)\n            \n            return 1 + max(left_depth, right_depth)\n        \n        depth(self.root)\n        return self.max_diameter\n\n# Test the binary tree implementation\nprint(\"Binary Tree Implementation & Traversal\")\nprint(\"=\" * 50)\n\n# Create a sample binary tree:\n#       1\n#      / \\\n#     2   3\n#    / \\\n#   4   5\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\n\ntree = BinaryTree(root)\n\nprint(\"Tree structure:\")\nprint(\"    1\")\nprint(\"   / \\\\\")\nprint(\"  2   3\")\nprint(\" / \\\\\")\nprint(\"4   5\")\nprint()\n\n# Test all traversal methods\nprint(\"Traversal Methods:\")\nprint(\"-\" * 30)\nprint(f\"In-order (L-Root-R):     {tree.inorder_traversal()}\")\nprint(f\"Pre-order (Root-L-R):    {tree.preorder_traversal()}\")\nprint(f\"Post-order (L-R-Root):   {tree.postorder_traversal()}\")\nprint(f\"Level-order (BFS):       {tree.level_order_flat()}\")\nprint()\n\nprint(\"Iterative vs Recursive:\")\nprint(\"-\" * 30)\nprint(f\"In-order recursive:      {tree.inorder_traversal()}\")\nprint(f\"In-order iterative:      {tree.inorder_iterative()}\")\nprint(f\"Pre-order recursive:     {tree.preorder_traversal()}\")\nprint(f\"Pre-order iterative:     {tree.preorder_iterative()}\")\nprint()\n\nprint(\"Level-order by levels:\")\nlevels = tree.level_order_traversal()\nfor i, level in enumerate(levels):\n    print(f\"Level {i}: {level}\")\nprint()\n\n# Test tree properties\nprint(\"Tree Properties:\")\nprint(\"-\" * 30)\nprint(f\"Max depth (height):      {tree.max_depth()}\")\nprint(f\"Min depth:               {tree.min_depth()}\")\nprint(f\"Is symmetric:            {tree.is_symmetric()}\")\nprint(f\"Diameter:                {tree.diameter()}\")\nprint()\n\n# Create a more complex tree for testing\nprint(\"More Complex Tree Example:\")\nprint(\"-\" * 30)\n\n#         1\n#       /   \\\n#      2     2\n#     / \\   / \\\n#    3   4 4   3\n\nsymmetric_root = TreeNode(1)\nsymmetric_root.left = TreeNode(2)\nsymmetric_root.right = TreeNode(2)\nsymmetric_root.left.left = TreeNode(3)\nsymmetric_root.left.right = TreeNode(4)\nsymmetric_root.right.left = TreeNode(4)\nsymmetric_root.right.right = TreeNode(3)\n\nsymmetric_tree = BinaryTree(symmetric_root)\n\nprint(\"Symmetric tree structure:\")\nprint(\"      1\")\nprint(\"    /   \\\\\")\nprint(\"   2     2\")\nprint(\"  / \\\\   / \\\\\")\nprint(\" 3   4 4   3\")\nprint()\n\nprint(f\"In-order:                {symmetric_tree.inorder_traversal()}\")\nprint(f\"Level-order:             {symmetric_tree.level_order_flat()}\")\nprint(f\"Is symmetric:            {symmetric_tree.is_symmetric()}\")\nprint(f\"Max depth:               {symmetric_tree.max_depth()}\")\nprint(f\"Diameter:                {symmetric_tree.diameter()}\")\n\nprint(\"\\n\" + \"=\" * 50)\nprint(\"Traversal Applications:\")\nprint(\"â€¢ In-order: Get sorted values from BST\")\nprint(\"â€¢ Pre-order: Copy/serialize tree structure\") \nprint(\"â€¢ Post-order: Delete nodes, calculate tree size\")\nprint(\"â€¢ Level-order: Print tree level by level\")\nprint(\"=\" * 50)\n```\n\n# ðŸ“š Section 9: Sorting Algorithms\n\nDifferent approaches to organizing data in order, each with unique trade-offs.\n\n## Challenge 16: Sorting Algorithm Implementations\n\n**Problem**: Implement and compare various sorting algorithms.\n\n**Algorithms Covered**:\n- **Bubble Sort**: O(nÂ²) - Simple but inefficient\n- **Selection Sort**: O(nÂ²) - Find minimum and swap\n- **Insertion Sort**: O(nÂ²) - Build sorted array incrementally  \n- **Merge Sort**: O(n log n) - Divide and conquer\n- **Quick Sort**: O(n log n) average - Partition-based\n- **Heap Sort**: O(n log n) - Using heap data structure\n\n**Key Insights**:\n- **Stable**: Maintains relative order of equal elements\n- **In-place**: Uses O(1) extra space\n- **Adaptive**: Performs better on partially sorted data\n\n**When to Use Each**: Different algorithms for different scenarios\n\n```python\n# Solution for Challenge 16: Sorting Algorithm Implementations\nimport random\nimport time\nfrom typing import List, Callable\n\n# SIMPLE SORTING ALGORITHMS - O(nÂ²)\n\ndef bubble_sort(arr: List[int]) -> List[int]:\n    \"\"\"Bubble Sort: O(nÂ²) time, O(1) space - Stable\"\"\"\n    arr = arr.copy()\n    n = len(arr)\n    \n    for i in range(n):\n        swapped = False\n        # Last i elements are already sorted\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # If no swapping occurred, array is sorted\n        if not swapped:\n            break\n    \n    return arr\n\ndef selection_sort(arr: List[int]) -> List[int]:\n    \"\"\"Selection Sort: O(nÂ²) time, O(1) space - Not stable\"\"\"\n    arr = arr.copy()\n    n = len(arr)\n    \n    for i in range(n):\n        # Find minimum element in remaining array\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        # Swap found minimum with first element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    \n    return arr\n\ndef insertion_sort(arr: List[int]) -> List[int]:\n    \"\"\"Insertion Sort: O(nÂ²) time, O(1) space - Stable, Adaptive\"\"\"\n    arr = arr.copy()\n    \n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        \n        # Move elements greater than key one position ahead\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        \n        arr[j + 1] = key\n    \n    return arr\n\n# EFFICIENT SORTING ALGORITHMS - O(n log n)\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"Merge Sort: O(n log n) time, O(n) space - Stable\"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Helper function for merge sort.\"\"\"\n    result = []\n    i = j = 0\n    \n    # Merge the two sorted arrays\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Add remaining elements\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\ndef quick_sort(arr: List[int]) -> List[int]:\n    \"\"\"Quick Sort: O(n log n) average, O(nÂ²) worst - Not stable, In-place\"\"\"\n    arr = arr.copy()\n    quick_sort_helper(arr, 0, len(arr) - 1)\n    return arr\n\ndef quick_sort_helper(arr: List[int], low: int, high: int):\n    \"\"\"Helper function for quick sort.\"\"\"\n    if low < high:\n        # Partition the array and get pivot index\n        pi = partition(arr, low, high)\n        \n        # Recursively sort elements before and after partition\n        quick_sort_helper(arr, low, pi - 1)\n        quick_sort_helper(arr, pi + 1, high)\n\ndef partition(arr: List[int], low: int, high: int) -> int:\n    \"\"\"Partition function for quick sort (Lomuto scheme).\"\"\"\n    # Choose rightmost element as pivot\n    pivot = arr[high]\n    i = low - 1  # Index of smaller element\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef heap_sort(arr: List[int]) -> List[int]:\n    \"\"\"Heap Sort: O(n log n) time, O(1) space - Not stable\"\"\"\n    arr = arr.copy()\n    n = len(arr)\n    \n    # Build max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    \n    # Extract elements from heap one by one\n    for i in range(n - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]  # Move root to end\n        heapify(arr, i, 0)  # Heapify reduced heap\n    \n    return arr\n\ndef heapify(arr: List[int], n: int, i: int):\n    \"\"\"Heapify subtree rooted at index i.\"\"\"\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    # If left child is larger than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    \n    # If right child is larger than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    \n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\n# SPECIALIZED SORTING ALGORITHMS\n\ndef counting_sort(arr: List[int]) -> List[int]:\n    \"\"\"Counting Sort: O(n + k) time where k is range - Stable\"\"\"\n    if not arr:\n        return arr\n    \n    # Find range\n    max_val = max(arr)\n    min_val = min(arr)\n    range_val = max_val - min_val + 1\n    \n    # Count occurrences\n    count = [0] * range_val\n    for num in arr:\n        count[num - min_val] += 1\n    \n    # Build result\n    result = []\n    for i, freq in enumerate(count):\n        result.extend([i + min_val] * freq)\n    \n    return result\n\ndef radix_sort(arr: List[int]) -> List[int]:\n    \"\"\"Radix Sort: O(d * (n + k)) time - Stable\"\"\"\n    if not arr:\n        return arr\n    \n    arr = arr.copy()\n    max_val = max(arr)\n    \n    # Sort by each digit\n    exp = 1\n    while max_val // exp > 0:\n        counting_sort_by_digit(arr, exp)\n        exp *= 10\n    \n    return arr\n\ndef counting_sort_by_digit(arr: List[int], exp: int):\n    \"\"\"Helper for radix sort - sort by specific digit.\"\"\"\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n    \n    # Count occurrences of digits\n    for num in arr:\n        digit = (num // exp) % 10\n        count[digit] += 1\n    \n    # Change count[i] to actual position\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    \n    # Build output array\n    i = n - 1\n    while i >= 0:\n        digit = (arr[i] // exp) % 10\n        output[count[digit] - 1] = arr[i]\n        count[digit] -= 1\n        i -= 1\n    \n    # Copy output array to arr\n    for i in range(n):\n        arr[i] = output[i]\n\n# PERFORMANCE TESTING\n\ndef measure_sorting_performance():\n    \"\"\"Compare performance of different sorting algorithms.\"\"\"\n    algorithms = [\n        (\"Bubble Sort\", bubble_sort),\n        (\"Selection Sort\", selection_sort),\n        (\"Insertion Sort\", insertion_sort),\n        (\"Merge Sort\", merge_sort),\n        (\"Quick Sort\", quick_sort),\n        (\"Heap Sort\", heap_sort),\n        (\"Counting Sort\", counting_sort),\n        (\"Radix Sort\", radix_sort),\n        (\"Python Built-in\", sorted)\n    ]\n    \n    test_cases = [\n        (\"Random\", lambda n: [random.randint(1, 1000) for _ in range(n)]),\n        (\"Sorted\", lambda n: list(range(n))),\n        (\"Reverse Sorted\", lambda n: list(range(n, 0, -1))),\n        (\"Nearly Sorted\", lambda n: list(range(n)) + [random.randint(1, n) for _ in range(n//10)])\n    ]\n    \n    sizes = [100, 500]  # Smaller sizes for demonstration\n    \n    print(\"Sorting Algorithm Performance Comparison\")\n    print(\"=\" * 60)\n    \n    for case_name, case_generator in test_cases:\n        print(f\"\\n{case_name} Data:\")\n        print(\"-\" * 40)\n        \n        for size in sizes:\n            print(f\"\\nArray size: {size}\")\n            test_data = case_generator(size)\n            \n            for algo_name, algo_func in algorithms:\n                # Skip slow algorithms for larger sizes\n                if size > 100 and algo_name in [\"Bubble Sort\", \"Selection Sort\"]:\n                    continue\n                \n                try:\n                    start_time = time.time()\n                    result = algo_func(test_data.copy())\n                    end_time = time.time()\n                    \n                    # Verify correctness\n                    is_correct = result == sorted(test_data)\n                    status = \"âœ“\" if is_correct else \"âœ—\"\n                    \n                    print(f\"{algo_name:15}: {end_time - start_time:.6f}s {status}\")\n                    \n                except Exception as e:\n                    print(f\"{algo_name:15}: Error - {e}\")\n\n# Test basic functionality\nprint(\"Testing Sorting Algorithms\")\nprint(\"=\" * 50)\n\ntest_array = [64, 34, 25, 12, 22, 11, 90]\nprint(f\"Original array: {test_array}\")\nprint()\n\nalgorithms = [\n    (\"Bubble Sort\", bubble_sort),\n    (\"Selection Sort\", selection_sort), \n    (\"Insertion Sort\", insertion_sort),\n    (\"Merge Sort\", merge_sort),\n    (\"Quick Sort\", quick_sort),\n    (\"Heap Sort\", heap_sort),\n    (\"Counting Sort\", counting_sort),\n    (\"Radix Sort\", radix_sort)\n]\n\nfor name, func in algorithms:\n    sorted_array = func(test_array)\n    print(f\"{name:15}: {sorted_array}\")\n\nprint(\"\\n\" + \"=\" * 50)\n\n# Performance comparison\nmeasure_sorting_performance()\n\nprint(\"\\n\" + \"=\" * 50)\nprint(\"Algorithm Characteristics:\")\nprint(\"â€¢ Bubble Sort: Simple, inefficient, stable\")\nprint(\"â€¢ Selection Sort: Simple, not stable, minimum swaps\") \nprint(\"â€¢ Insertion Sort: Efficient for small/nearly sorted arrays\")\nprint(\"â€¢ Merge Sort: Consistent O(n log n), stable, extra space\")\nprint(\"â€¢ Quick Sort: Fast average case, in-place, not stable\")\nprint(\"â€¢ Heap Sort: Consistent O(n log n), in-place, not stable\")\nprint(\"â€¢ Counting Sort: Linear time for small ranges\")\nprint(\"â€¢ Radix Sort: Linear time for integers\")\nprint(\"=\" * 50)\n```\n\n# ðŸ“Š Challenge Coverage Summary\n\n## âœ… **Currently Implemented (18 Challenges)**\n\n### **Section 1: Basic Challenges Part 1 (6/10)**\nâœ… Hello World | âœ… Get Sum | âœ… Calculator | âœ… Reverse String | âœ… Palindrome | âœ… Count Vowels  \nâœ… Count Occurrences  \nâŒ Find Max Number | âŒ Title Case | âŒ Remove Duplicates\n\n### **Section 2: Basic Challenges Part 2 (4/10)**  \nâœ… FizzBuzz Array | âœ… Find Missing Number | âœ… Find Missing Letter  \nâŒ Array Intersection | âŒ Display Likes | âŒ Are All Chars Unique | âŒ First Non Repeating | âŒ Dice Game | âŒ Format Phone | âŒ Validate Email\n\n### **Section 3: Higher-Order Functions (1/10)**\nâœ… Sum of Even Squares  \nâŒ Calculate Total Sales | âŒ Highest Scoring Word | âŒ Valid Anagrams | âŒ Hashtag Generator | âŒ Valid IPv4 | âŒ Analyze Car Mileage | âŒ Password Validator | âŒ Missing Letter Refactor\n\n### **Section 4: Recursion (2/10)**\nâœ… Factorial | âœ… Fibonacci  \nâŒ Reverse String Recursion | âŒ Power | âŒ Array Sum | âŒ Number Range | âŒ Flatten Array | âŒ Permutations\n\n### **Section 5: Complexity Analysis (1/10)**\nâœ… Big O Examples  \nâŒ Time Complexity Examples | âŒ Space Complexity | âŒ Max Subarray | âŒ Sliding Window\n\n### **Section 6: Hash Tables & Sets (1/14)**\nâœ… Two Sum  \nâŒ Word Frequency | âŒ Phone Directory | âŒ Anagram Grouping | âŒ Symmetric Difference | âŒ Longest Consecutive | âŒ Custom Hash Table\n\n### **Section 7: Data Structures (1/16)**\nâœ… Balanced Parentheses  \nâŒ Stack Implementation | âŒ Queue Implementation | âŒ Reverse String Stack/Queue | âŒ Palindrome Queue Stack | âŒ Linked List | âŒ Find Middle | âŒ Doubly Linked List\n\n### **Section 8: Trees & Graphs (1/15)**\nâœ… Binary Tree Traversal  \nâŒ Maximum Depth | âŒ Binary Search Tree | âŒ Validate BST | âŒ Graph Implementation | âŒ Graph Traversal | âŒ BFS/DFS\n\n### **Section 9: Sorting (1/11)**\nâœ… All Sorting Algorithms  \nâŒ Individual algorithm implementations and analysis\n\n---\n\n## ðŸŽ¯ **Coverage Statistics**\n- **Total Available**: ~100+ challenges\n- **Currently Implemented**: 18 challenges  \n- **Coverage**: ~18%\n- **Missing**: 80+ challenges\n\n## ðŸš€ **Recommendation**\nThe notebook provides a solid foundation covering:\n- âœ… Core programming concepts\n- âœ… Key algorithm patterns  \n- âœ… Important data structures\n- âœ… Multiple solution approaches\n- âœ… Performance analysis\n\n**For complete coverage**, you could add challenges progressively based on your learning needs. The current selection covers the most essential computer science concepts for interviews and practical programming.\n\nWould you like me to add more specific challenges from any particular section?\n\n## ðŸŽ¯ TOP INTERVIEW CHALLENGES FOR CAREER SUCCESS\n\n**This section focuses on the most frequently asked interview questions at FAANG and top tech companies. Master these to significantly boost your interview success rate!**\n\n---\n\n## Challenge 14: Merge Intervals â­â­â­\n\n**âš¡ Interview Frequency: VERY HIGH** | **Companies: Google, Facebook, Amazon, Microsoft**\n\n**Problem:** Given a collection of intervals, merge all overlapping intervals.\n\n**Example:**\n```\nInput: [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: [1,3] and [2,6] overlap, so merge them.\n```\n\n**Why This Matters for Your Career:**\n- **Algorithm Design:** Tests your ability to think systematically\n- **Edge Case Handling:** Critical for senior developer roles\n- **Real-World Applications:** Calendar scheduling, resource allocation\n- **Interview Weight:** Often determines if you advance to next round\n\n```python\n# Solution for Challenge 14: Merge Intervals - TOP INTERVIEW PRIORITY!\n\nfrom typing import List\n\n# Method 1: Optimal sorting approach (MOST COMMON IN INTERVIEWS)\ndef merge_intervals(intervals: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Merge overlapping intervals - O(n log n) time, O(1) space.\n    \n    This is THE solution interviewers expect you to know!\n    \"\"\"\n    if not intervals:\n        return []\n    \n    # Step 1: Sort by start time (CRITICAL!)\n    intervals.sort(key=lambda x: x[0])\n    \n    # Step 2: Initialize result with first interval\n    merged = [intervals[0]]\n    \n    # Step 3: Iterate and merge\n    for current in intervals[1:]:\n        last_merged = merged[-1]\n        \n        # Check for overlap: current start <= last end\n        if current[0] <= last_merged[1]:\n            # Merge: extend the end time\n            last_merged[1] = max(last_merged[1], current[1])\n        else:\n            # No overlap: add new interval\n            merged.append(current)\n    \n    return merged\n\n# Method 2: Using stack (alternative approach)\ndef merge_intervals_stack(intervals: List[List[int]]) -> List[List[int]]:\n    \"\"\"Merge intervals using stack approach.\"\"\"\n    if not intervals:\n        return []\n    \n    intervals.sort(key=lambda x: x[0])\n    stack = [intervals[0]]\n    \n    for current in intervals[1:]:\n        top = stack[-1]\n        \n        if current[0] <= top[1]:\n            # Overlapping - merge\n            top[1] = max(top[1], current[1])\n        else:\n            # Non-overlapping - push\n            stack.append(current)\n    \n    return stack\n\n# Method 3: Functional approach with reduce\nfrom functools import reduce\n\ndef merge_intervals_functional(intervals: List[List[int]]) -> List[List[int]]:\n    \"\"\"Merge intervals using functional programming approach.\"\"\"\n    if not intervals:\n        return []\n    \n    intervals.sort(key=lambda x: x[0])\n    \n    def merge_two(merged_list, current_interval):\n        if not merged_list:\n            return [current_interval]\n        \n        last = merged_list[-1]\n        if current_interval[0] <= last[1]:\n            last[1] = max(last[1], current_interval[1])\n            return merged_list\n        else:\n            return merged_list + [current_interval]\n    \n    return reduce(merge_two, intervals, [])\n\n# Method 4: In-place merging (space optimized)\ndef merge_intervals_inplace(intervals: List[List[int]]) -> List[List[int]]:\n    \"\"\"Merge intervals with minimal extra space.\"\"\"\n    if not intervals:\n        return []\n    \n    intervals.sort(key=lambda x: x[0])\n    \n    write_index = 0\n    for read_index in range(1, len(intervals)):\n        current = intervals[read_index]\n        last_merged = intervals[write_index]\n        \n        if current[0] <= last_merged[1]:\n            # Merge\n            last_merged[1] = max(last_merged[1], current[1])\n        else:\n            # Move to next position\n            write_index += 1\n            intervals[write_index] = current\n    \n    return intervals[:write_index + 1]\n\n# INTERVIEW-STYLE TEST CASES (These are what interviewers use!)\nprint(\"ðŸŽ¯ INTERVIEW TEST CASES - Master these patterns!\")\n\ninterview_test_cases = [\n    # Case 1: Basic overlapping\n    ([[1,3],[2,6],[8,10],[15,18]], [[1,6],[8,10],[15,18]], \"Basic overlap\"),\n    \n    # Case 2: All intervals merge into one\n    ([[1,4],[4,5]], [[1,5]], \"Adjacent intervals (edge case!)\"),\n    \n    # Case 3: No overlaps\n    ([[1,2],[3,4],[5,6]], [[1,2],[3,4],[5,6]], \"No overlaps\"),\n    \n    # Case 4: Completely contained intervals\n    ([[1,4],[2,3]], [[1,4]], \"Contained interval\"),\n    \n    # Case 5: Empty input (edge case)\n    ([], [], \"Empty input\"),\n    \n    # Case 6: Single interval\n    ([[1,4]], [[1,4]], \"Single interval\"),\n    \n    # Case 7: Unsorted input (tricky!)\n    ([[4,5],[1,3],[0,1]], [[0,3],[4,5]], \"Unsorted input\"),\n    \n    # Case 8: Complex overlapping pattern\n    ([[1,3],[2,6],[8,10],[9,12],[15,18]], [[1,6],[8,12],[15,18]], \"Complex pattern\"),\n    \n    # Case 9: All intervals merge\n    ([[1,2],[2,3],[3,4],[4,5]], [[1,5]], \"Chain merging\"),\n    \n    # Case 10: Duplicate intervals\n    ([[1,3],[1,3],[2,4]], [[1,4]], \"Duplicates\")\n]\n\nfor i, (input_intervals, expected, description) in enumerate(interview_test_cases, 1):\n    print(f\"\\nðŸ“ Interview Test {i}: {description}\")\n    print(f\"Input: {input_intervals}\")\n    print(f\"Expected: {expected}\")\n    \n    # Test all methods\n    result1 = merge_intervals(input_intervals.copy())\n    result2 = merge_intervals_stack(input_intervals.copy())\n    result3 = merge_intervals_functional(input_intervals.copy())\n    result4 = merge_intervals_inplace(input_intervals.copy())\n    \n    all_correct = (result1 == expected and result2 == expected and \n                   result3 == expected and result4 == expected)\n    \n    print(f\"âœ… All methods correct: {all_correct}\")\n    if not all_correct:\n        print(f\"  Method 1: {result1}\")\n        print(f\"  Method 2: {result2}\")\n        print(f\"  Method 3: {result3}\")\n        print(f\"  Method 4: {result4}\")\n\n# ðŸŽ¯ INTERVIEW WALKTHROUGH - Practice explaining this!\nprint(f\"\\nðŸŽ¯ INTERVIEW WALKTHROUGH:\")\nprint(\"Input: [[1,3],[2,6],[8,10],[15,18]]\")\nprint(\"Step 1: Already sorted by start time\")\nprint(\"Step 2: Start with first interval [1,3]\")\nprint(\"Step 3: Check [2,6] - 2 <= 3? YES â†’ Merge to [1,6]\")\nprint(\"Step 4: Check [8,10] - 8 <= 6? NO â†’ Add [8,10]\")\nprint(\"Step 5: Check [15,18] - 15 <= 10? NO â†’ Add [15,18]\")\nprint(\"Result: [[1,6],[8,10],[15,18]]\")\n\n# ðŸ’¼ CAREER IMPACT METRICS\nprint(f\"\\nðŸ’¼ CAREER IMPACT OF MASTERING THIS PROBLEM:\")\nprint(\"âœ… Appears in 85%+ of algorithm interviews\")\nprint(\"âœ… Tests sorting, greedy algorithms, and edge cases\")\nprint(\"âœ… Foundation for harder problems (Meeting Rooms, etc.)\")\nprint(\"âœ… Demonstrates systematic problem-solving\")\nprint(\"âœ… Shows ability to optimize (time/space tradeoffs)\")\n\n# ðŸš€ INTERVIEW TIPS\nprint(f\"\\nðŸš€ INTERVIEW SUCCESS TIPS:\")\nprint(\"1. ALWAYS ask about edge cases (empty, single interval)\")\nprint(\"2. Mention the sorting step explicitly\")\nprint(\"3. Walk through the algorithm step by step\")\nprint(\"4. Discuss time/space complexity\")\nprint(\"5. Consider follow-up questions (insert interval, etc.)\")\n\nprint(\"\\n\" + \"=\"*50)\nprint(\"â­ MASTERY CHECKPOINT: Can you solve this in < 5 minutes?\")\nprint(\"â­ If YES: You're ready for senior developer interviews!\")\nprint(\"â­ If NO: Practice until it becomes automatic!\")\nprint(\"=\"*50)\n```\n\n## Challenge 15: Valid Parentheses (Advanced) â­â­â­\n\n**âš¡ Interview Frequency: EXTREMELY HIGH** | **Companies: ALL major tech companies**\n\n**Problem:** Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\n**Example:**\n```\nInput: \"({[]})\"\nOutput: True\n\nInput: \"({[}])\"\nOutput: False\n```\n\n**Career Impact:** This is the #1 stack problem in interviews. Mastering this opens doors to senior positions.\n\n```python\n# Solution for Challenge 15: Valid Parentheses - INTERVIEW ESSENTIAL!\n\n# Method 1: Classic stack approach (WHAT INTERVIEWERS EXPECT)\ndef is_valid_parentheses(s: str) -> bool:\n    \"\"\"\n    Check if parentheses are valid using stack.\n    \n    This is THE solution every software engineer must know!\n    Time: O(n), Space: O(n)\n    \"\"\"\n    # Edge case: odd length can't be valid\n    if len(s) % 2 != 0:\n        return False\n    \n    # Mapping of closing to opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack = []\n    \n    for char in s:\n        if char in bracket_map:  # Closing bracket\n            # Check if stack is empty or top doesn't match\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n        else:  # Opening bracket\n            stack.append(char)\n    \n    # Valid if stack is empty (all brackets matched)\n    return len(stack) == 0\n\n# Method 2: Optimized with early termination\ndef is_valid_optimized(s: str) -> bool:\n    \"\"\"Optimized version with early termination checks.\"\"\"\n    if len(s) % 2 != 0:\n        return False\n    \n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack = []\n    \n    for char in s:\n        if char in bracket_map:\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n        else:\n            stack.append(char)\n            # Early termination: if stack size > remaining chars\n            if len(stack) > len(s) // 2:\n                return False\n    \n    return len(stack) == 0\n\n# Method 3: Counter-based approach (space optimized for specific cases)\ndef is_valid_counter(s: str) -> bool:\n    \"\"\"Counter approach - works only if brackets can be arbitrarily nested.\"\"\"\n    if len(s) % 2 != 0:\n        return False\n    \n    counters = {'(': 0, '{': 0, '[': 0}\n    \n    for char in s:\n        if char in '({[':\n            counters[char] += 1\n        elif char == ')':\n            if counters['('] <= 0:\n                return False\n            counters['('] -= 1\n        elif char == '}':\n            if counters['{'] <= 0:\n                return False\n            counters['{'] -= 1\n        elif char == ']':\n            if counters['['] <= 0:\n                return False\n            counters['['] -= 1\n    \n    return all(count == 0 for count in counters.values())\n\n# Method 4: Replace approach (inefficient but educational)\ndef is_valid_replace(s: str) -> bool:\n    \"\"\"Replace pairs until no more pairs exist - O(nÂ²) but intuitive.\"\"\"\n    while '()' in s or '{}' in s or '[]' in s:\n        s = s.replace('()', '').replace('{}', '').replace('[]', '')\n    return s == ''\n\n# Method 5: Recursive approach\ndef is_valid_recursive(s: str) -> bool:\n    \"\"\"Recursive solution - educational but not efficient.\"\"\"\n    def helper(s, index, stack):\n        if index == len(s):\n            return len(stack) == 0\n        \n        char = s[index]\n        if char in '({[':\n            return helper(s, index + 1, stack + [char])\n        else:\n            bracket_map = {')': '(', '}': '{', ']': '['}\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            return helper(s, index + 1, stack[:-1])\n    \n    return helper(s, 0, [])\n\n# ðŸŽ¯ COMPREHENSIVE INTERVIEW TEST CASES\nprint(\"ðŸŽ¯ INTERVIEW TEST CASES - These appear in real interviews!\")\n\ninterview_cases = [\n    # Basic cases\n    (\"()\", True, \"Simple pair\"),\n    (\"()[]{}\", True, \"Multiple types\"),\n    (\"(]\", False, \"Mismatched types\"),\n    (\"([)]\", False, \"Wrong nesting order\"),\n    (\"{[]}\", True, \"Proper nesting\"),\n    \n    # Edge cases (CRITICAL for interviews!)\n    (\"\", True, \"Empty string\"),\n    (\"(\", False, \"Single opening\"),\n    (\")\", False, \"Single closing\"),\n    (\"((\", False, \"Only opening\"),\n    (\"))\", False, \"Only closing\"),\n    \n    # Complex patterns\n    (\"((()))\", True, \"Nested same type\"),\n    (\"({[]})\", True, \"Perfect nesting\"),\n    (\"({[}])\", False, \"Cross nesting\"),\n    (\"((((()))))\", True, \"Deep nesting\"),\n    \n    # Tricky cases\n    (\"((\", False, \"Unbalanced opening\"),\n    (\"))(\", False, \"Wrong order\"),\n    (\"({[\", False, \"All opening\"),\n    (\"]})\", False, \"All closing\"),\n    \n    # Real-world scenarios\n    (\"(a)\", True, \"With content - depends on problem variant\"),\n    (\"[{()}]\", True, \"Complex valid\"),\n    (\"[({})]\", True, \"Another complex valid\"),\n]\n\nprint(\"Testing all methods on interview cases...\")\nfor test_str, expected, description in interview_cases:\n    print(f\"\\nðŸ“ Test: '{test_str}' - {description}\")\n    print(f\"Expected: {expected}\")\n    \n    # Skip content-containing test for basic version\n    if any(c.isalpha() for c in test_str):\n        print(\"âš ï¸  Note: Basic version doesn't handle non-bracket characters\")\n        continue\n    \n    results = [\n        (\"Stack (Primary)\", is_valid_parentheses(test_str)),\n        (\"Optimized\", is_valid_optimized(test_str)),\n        (\"Counter\", is_valid_counter(test_str)),\n        (\"Replace\", is_valid_replace(test_str)),\n        (\"Recursive\", is_valid_recursive(test_str))\n    ]\n    \n    all_correct = all(result == expected for _, result in results)\n    print(f\"âœ… All methods correct: {all_correct}\")\n    \n    if not all_correct:\n        for method, result in results:\n            status = \"âœ…\" if result == expected else \"âŒ\"\n            print(f\"  {status} {method}: {result}\")\n\n# ðŸŽ¯ INTERVIEW WALKTHROUGH\nprint(f\"\\nðŸŽ¯ STEP-BY-STEP WALKTHROUGH:\")\nprint(\"Example: '({[]})'\")\nprint(\"1. '(' â†’ Push to stack: ['(']\")\nprint(\"2. '{' â†’ Push to stack: ['(', '{']\")  \nprint(\"3. '[' â†’ Push to stack: ['(', '{', '[']\")\nprint(\"4. ']' â†’ Matches '[', pop: ['(', '{']\")\nprint(\"5. '}' â†’ Matches '{', pop: ['(']\")\nprint(\"6. ')' â†’ Matches '(', pop: []\")\nprint(\"7. Stack empty â†’ Valid!\")\n\n# ðŸ’¼ CAREER SUCCESS METRICS\nprint(f\"\\nðŸ’¼ WHY THIS PROBLEM IS CAREER-DEFINING:\")\nprint(\"ðŸ† Asked in 95%+ of coding interviews\")\nprint(\"ðŸ† Gateway to senior developer roles\")\nprint(\"ðŸ† Foundation for parsing algorithms\")\nprint(\"ðŸ† Tests fundamental data structure knowledge\")\nprint(\"ðŸ† Demonstrates clean, bug-free coding\")\n\n# ðŸš€ INTERVIEW MASTERY TIPS\nprint(f\"\\nðŸš€ INTERVIEW SUCCESS STRATEGIES:\")\nprint(\"1. âš¡ Start with edge cases (empty string, odd length)\")\nprint(\"2. âš¡ Explain the stack approach clearly\")\nprint(\"3. âš¡ Handle the mapping dictionary elegantly\")\nprint(\"4. âš¡ Mention time/space complexity\")\nprint(\"5. âš¡ Ask about follow-ups (minimum removals, etc.)\")\n\n# ðŸŽ¯ FOLLOW-UP QUESTIONS (for senior positions)\nprint(f\"\\nðŸŽ¯ COMMON FOLLOW-UP QUESTIONS:\")\nprint(\"â€¢ What if string contains other characters?\")\nprint(\"â€¢ Find minimum removals to make valid\")\nprint(\"â€¢ Generate all valid parentheses of length n\")\nprint(\"â€¢ Handle different bracket priorities\")\nprint(\"â€¢ Longest valid parentheses substring\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"â­ MASTERY GOAL: Solve in < 3 minutes with perfect explanation\")\nprint(\"â­ This problem alone can determine interview success!\")\nprint(\"=\"*60)\n```\n\n## Challenge 16: Binary Tree Level Order Traversal â­â­â­\n\n**âš¡ Interview Frequency: EXTREMELY HIGH** | **Companies: Amazon, Google, Facebook, Apple**\n\n**Problem:** Given a binary tree, return the level order traversal (BFS) of its nodes' values.\n\n**Example:**\n```\nTree:     3\n         / \\\n        9   20\n           /  \\\n          15   7\n\nOutput: [[3], [9, 20], [15, 7]]\n```\n\n**Career Catalyst:** Master this and you'll ace tree problems in any interview. It's the foundation for countless variations.\n\n```python\n# Solution for Challenge 16: Binary Tree Level Order Traversal - INTERVIEW GOLD!\n\nfrom typing import List, Optional\nfrom collections import deque\n\n# TreeNode class (standard in interviews)\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        return f\"TreeNode({self.val})\"\n\n# Method 1: BFS with Queue (STANDARD INTERVIEW SOLUTION)\ndef level_order_bfs(root: Optional[TreeNode]) -> List[List[int]]:\n    \"\"\"\n    Level order traversal using BFS with queue.\n    \n    This is THE solution interviewers want to see!\n    Time: O(n), Space: O(w) where w is max width\n    \"\"\"\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)  # CRITICAL: capture current level size\n        current_level = []\n        \n        # Process all nodes in current level\n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n            \n            # Add children for next level\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(current_level)\n    \n    return result\n\n# Method 2: DFS with level tracking (alternative approach)\ndef level_order_dfs(root: Optional[TreeNode]) -> List[List[int]]:\n    \"\"\"Level order using DFS with level parameter.\"\"\"\n    if not root:\n        return []\n    \n    result = []\n    \n    def dfs(node, level):\n        if not node:\n            return\n        \n        # Expand result if we're at a new level\n        if level >= len(result):\n            result.append([])\n        \n        # Add current node to its level\n        result[level].append(node.val)\n        \n        # Recurse on children\n        dfs(node.left, level + 1)\n        dfs(node.right, level + 1)\n    \n    dfs(root, 0)\n    return result\n\n# Method 3: Using two queues (educational)\ndef level_order_two_queues(root: Optional[TreeNode]) -> List[List[int]]:\n    \"\"\"Level order using two queues to separate levels.\"\"\"\n    if not root:\n        return []\n    \n    result = []\n    current_level = deque([root])\n    \n    while current_level:\n        next_level = deque()\n        current_values = []\n        \n        while current_level:\n            node = current_level.popleft()\n            current_values.append(node.val)\n            \n            if node.left:\n                next_level.append(node.left)\n            if node.right:\n                next_level.append(node.right)\n        \n        result.append(current_values)\n        current_level = next_level\n    \n    return result\n\n# Method 4: Iterative with level markers (alternative)\ndef level_order_markers(root: Optional[TreeNode]) -> List[List[int]]:\n    \"\"\"Level order using None as level marker.\"\"\"\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root, None])  # None marks end of level\n    current_level = []\n    \n    while queue:\n        node = queue.popleft()\n        \n        if node is None:\n            # End of level\n            result.append(current_level)\n            current_level = []\n            \n            # Add marker for next level if queue not empty\n            if queue:\n                queue.append(None)\n        else:\n            current_level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    \n    return result\n\n# Method 5: Generator approach (memory efficient)\ndef level_order_generator(root: Optional[TreeNode]):\n    \"\"\"Generator version for memory efficiency.\"\"\"\n    if not root:\n        return\n    \n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        current_level = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            current_level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        yield current_level\n\n# Helper function to build test trees\ndef build_tree_from_list(values: List) -> Optional[TreeNode]:\n    \"\"\"Build binary tree from level-order list (None for missing nodes).\"\"\"\n    if not values:\n        return None\n    \n    root = TreeNode(values[0])\n    queue = deque([root])\n    i = 1\n    \n    while queue and i < len(values):\n        node = queue.popleft()\n        \n        # Left child\n        if i < len(values) and values[i] is not None:\n            node.left = TreeNode(values[i])\n            queue.append(node.left)\n        i += 1\n        \n        # Right child\n        if i < len(values) and values[i] is not None:\n            node.right = TreeNode(values[i])\n            queue.append(node.right)\n        i += 1\n    \n    return root\n\n# ðŸŽ¯ INTERVIEW TEST CASES\nprint(\"ðŸŽ¯ BINARY TREE LEVEL ORDER - INTERVIEW SCENARIOS\")\n\ntest_cases = [\n    # Basic cases\n    ([3, 9, 20, None, None, 15, 7], [[3], [9, 20], [15, 7]], \"Standard example\"),\n    ([1], [[1]], \"Single node\"),\n    ([], [], \"Empty tree\"),\n    \n    # Edge cases\n    ([1, 2], [[1], [2]], \"Left child only\"),\n    ([1, None, 2], [[1], [2]], \"Right child only\"),\n    ([1, 2, 3, 4, 5], [[1], [2, 3], [4, 5]], \"Complete tree\"),\n    \n    # Complex cases\n    ([1, 2, 3, 4, None, None, 5], [[1], [2, 3], [4, 5]], \"Sparse tree\"),\n    ([1, 2, 3, 4, 5, 6, 7], [[1], [2, 3], [4, 5, 6, 7]], \"Full tree\"),\n    \n    # Unbalanced trees\n    ([1, 2, None, 3, None, 4], [[1], [2], [3], [4]], \"Left skewed\"),\n    ([1, None, 2, None, 3, None, 4], [[1], [2], [3], [4]], \"Right skewed\"),\n]\n\nmethods = [\n    (\"BFS Queue (Primary)\", level_order_bfs),\n    (\"DFS Recursive\", level_order_dfs),\n    (\"Two Queues\", level_order_two_queues),\n    (\"Level Markers\", level_order_markers),\n]\n\nfor i, (tree_values, expected, description) in enumerate(test_cases, 1):\n    print(f\"\\nðŸ“ Test {i}: {description}\")\n    print(f\"Tree: {tree_values}\")\n    print(f\"Expected: {expected}\")\n    \n    # Build tree\n    root = build_tree_from_list(tree_values)\n    \n    # Test all methods\n    all_correct = True\n    for method_name, method_func in methods:\n        try:\n            result = method_func(root)\n            is_correct = result == expected\n            if not is_correct:\n                all_correct = False\n            print(f\"  {method_name}: {result} {'âœ…' if is_correct else 'âŒ'}\")\n        except Exception as e:\n            print(f\"  {method_name}: Error - {e}\")\n            all_correct = False\n    \n    # Test generator\n    if root:\n        gen_result = list(level_order_generator(root))\n        gen_correct = gen_result == expected\n        print(f\"  Generator: {gen_result} {'âœ…' if gen_correct else 'âŒ'}\")\n    \n    print(f\"âœ… All methods correct: {all_correct}\")\n\n# ðŸŽ¯ VISUAL WALKTHROUGH\nprint(f\"\\nðŸŽ¯ STEP-BY-STEP VISUALIZATION:\")\nprint(\"Tree:     3\")\nprint(\"         / \\\\\")\nprint(\"        9   20\")\nprint(\"           /  \\\\\")\nprint(\"          15   7\")\nprint()\nprint(\"BFS Process:\")\nprint(\"Queue: [3] â†’ Process level 0: [3]\")\nprint(\"Queue: [9, 20] â†’ Process level 1: [9, 20]\")\nprint(\"Queue: [15, 7] â†’ Process level 2: [15, 7]\")\nprint(\"Result: [[3], [9, 20], [15, 7]]\")\n\n# ðŸ’¼ CAREER IMPACT\nprint(f\"\\nðŸ’¼ CAREER BREAKTHROUGH OPPORTUNITIES:\")\nprint(\"ðŸš€ Foundation for 50+ tree interview problems\")\nprint(\"ðŸš€ Required for senior/staff engineer positions\")\nprint(\"ðŸš€ Demonstrates BFS/DFS mastery\")\nprint(\"ðŸš€ Gateway to system design (tree traversal systems)\")\nprint(\"ðŸš€ Shows clean coding and edge case handling\")\n\n# ðŸŽ¯ INTERVIEW VARIATIONS (CRITICAL TO KNOW!)\nprint(f\"\\nðŸŽ¯ COMMON INTERVIEW VARIATIONS:\")\nprint(\"1. Level Order Traversal II (bottom-up)\")\nprint(\"2. Binary Tree Zigzag Level Order\")\nprint(\"3. Binary Tree Right Side View\")\nprint(\"4. Find Largest Value in Each Row\")\nprint(\"5. Average of Levels in Binary Tree\")\nprint(\"6. Binary Tree Level Order with Custom Format\")\n\n# ðŸ”¥ PERFORMANCE ANALYSIS\nprint(f\"\\nðŸ”¥ PERFORMANCE & COMPLEXITY:\")\nprint(\"Time Complexity: O(n) - visit each node once\")\nprint(\"Space Complexity: O(w) - where w is maximum width\")\nprint(\"Best for: Complete trees (balanced)\")\nprint(\"Worst for: Skewed trees (degrades to O(n) space)\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"â­ INTERVIEW MASTERY: Solve + explain in < 4 minutes\")\nprint(\"â­ Know BFS vs DFS tradeoffs\")\nprint(\"â­ Handle follow-up variations instantly\")\nprint(\"=\"*60)\n```\n\n## Challenge 17: Maximum Subarray (Kadane's Algorithm) â­â­â­\n\n**âš¡ Interview Frequency: EXTREMELY HIGH** | **Companies: Google, Amazon, Microsoft, Facebook**\n\n**Problem:** Find the contiguous subarray with the largest sum.\n\n**Example:**\n```\nInput: [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6 (subarray [4,-1,2,1])\n```\n\n**Career Game-Changer:** This algorithm is legendary. It's asked in 90% of array interviews and demonstrates dynamic programming mastery.\n\n```python\n# Solution for Challenge 17: Maximum Subarray - KADANE'S ALGORITHM MASTERY!\n\nfrom typing import List, Tuple\n\n# Method 1: Kadane's Algorithm (THE LEGENDARY SOLUTION!)\ndef max_subarray_kadane(nums: List[int]) -> int:\n    \"\"\"\n    Kadane's Algorithm - THE algorithm every programmer must know!\n    \n    Time: O(n), Space: O(1) - Optimal!\n    This single algorithm can make or break your interview.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    max_ending_here = max_so_far = nums[0]\n    \n    for i in range(1, len(nums)):\n        # Key insight: either extend existing subarray or start new one\n        max_ending_here = max(nums[i], max_ending_here + nums[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\n# Method 2: Kadane's with subarray indices (for follow-up questions)\ndef max_subarray_with_indices(nums: List[int]) -> Tuple[int, int, int]:\n    \"\"\"\n    Kadane's Algorithm that also returns the actual subarray indices.\n    Returns: (max_sum, start_index, end_index)\n    \"\"\"\n    if not nums:\n        return 0, 0, 0\n    \n    max_sum = max_ending_here = nums[0]\n    start = end = temp_start = 0\n    \n    for i in range(1, len(nums)):\n        if max_ending_here < 0:\n            max_ending_here = nums[i]\n            temp_start = i\n        else:\n            max_ending_here += nums[i]\n        \n        if max_ending_here > max_sum:\n            max_sum = max_ending_here\n            start = temp_start\n            end = i\n    \n    return max_sum, start, end\n\n# Method 3: Dynamic Programming approach (educational)\ndef max_subarray_dp(nums: List[int]) -> int:\n    \"\"\"Dynamic Programming version - same logic, different presentation.\"\"\"\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    dp = [0] * n  # dp[i] = max sum ending at index i\n    dp[0] = nums[0]\n    max_sum = dp[0]\n    \n    for i in range(1, n):\n        dp[i] = max(nums[i], dp[i-1] + nums[i])\n        max_sum = max(max_sum, dp[i])\n    \n    return max_sum\n\n# Method 4: Divide and Conquer (O(n log n) - for algorithm variety)\ndef max_subarray_divide_conquer(nums: List[int]) -> int:\n    \"\"\"Divide and conquer approach - demonstrates different algorithmic thinking.\"\"\"\n    \n    def max_crossing_sum(nums, left, mid, right):\n        \"\"\"Find max sum of subarray that crosses the midpoint.\"\"\"\n        left_sum = float('-inf')\n        sum_val = 0\n        for i in range(mid, left - 1, -1):\n            sum_val += nums[i]\n            if sum_val > left_sum:\n                left_sum = sum_val\n        \n        right_sum = float('-inf')\n        sum_val = 0\n        for i in range(mid + 1, right + 1):\n            sum_val += nums[i]\n            if sum_val > right_sum:\n                right_sum = sum_val\n        \n        return left_sum + right_sum\n    \n    def max_subarray_rec(nums, left, right):\n        if left == right:\n            return nums[left]\n        \n        mid = (left + right) // 2\n        \n        left_max = max_subarray_rec(nums, left, mid)\n        right_max = max_subarray_rec(nums, mid + 1, right)\n        cross_max = max_crossing_sum(nums, left, mid, right)\n        \n        return max(left_max, right_max, cross_max)\n    \n    if not nums:\n        return 0\n    return max_subarray_rec(nums, 0, len(nums) - 1)\n\n# Method 5: Brute force (for comparison - O(nÂ²))\ndef max_subarray_brute_force(nums: List[int]) -> int:\n    \"\"\"Brute force approach - educational but inefficient.\"\"\"\n    if not nums:\n        return 0\n    \n    max_sum = float('-inf')\n    \n    for i in range(len(nums)):\n        current_sum = 0\n        for j in range(i, len(nums)):\n            current_sum += nums[j]\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n# Method 6: Prefix sum approach\ndef max_subarray_prefix(nums: List[int]) -> int:\n    \"\"\"Using prefix sums - another way to think about the problem.\"\"\"\n    if not nums:\n        return 0\n    \n    prefix_sum = 0\n    min_prefix = 0\n    max_sum = float('-inf')\n    \n    for num in nums:\n        prefix_sum += num\n        max_sum = max(max_sum, prefix_sum - min_prefix)\n        min_prefix = min(min_prefix, prefix_sum)\n    \n    return max_sum\n\n# ðŸŽ¯ COMPREHENSIVE INTERVIEW TEST CASES\nprint(\"ðŸŽ¯ MAXIMUM SUBARRAY - LEGENDARY ALGORITHM TESTS!\")\n\ninterview_test_cases = [\n    # Classic examples\n    ([-2, 1, -3, 4, -1, 2, 1, -5, 4], 6, \"Classic example [4,-1,2,1]\"),\n    ([1], 1, \"Single positive element\"),\n    ([5, 4, -1, 7, 8], 23, \"Mostly positive\"),\n    \n    # Edge cases (CRITICAL!)\n    ([-1], -1, \"Single negative element\"),\n    ([-2, -1], -1, \"All negative\"),\n    ([1, 2, 3, 4, 5], 15, \"All positive\"),\n    ([], 0, \"Empty array\"),\n    \n    # Tricky patterns\n    ([1, -1, 1, -1, 1], 1, \"Alternating pattern\"),\n    ([-1, -2, -3, -4], -1, \"All negative descending\"),\n    ([2, -8, 3, -2, 4, -10, 6], 6, \"Single element wins\"),\n    \n    # Complex scenarios\n    ([1, 2, -1, -2, 2, 1, -2, 1], 4, \"Complex mixed\"),\n    ([-2, 1, -3, 4, -1, 2, 1, -5, 4], 6, \"LeetCode classic\"),\n    ([100, -2, -3, -4, 1, 2, 3], 100, \"Large single vs small sum\"),\n]\n\nmethods = [\n    (\"Kadane's Algorithm\", max_subarray_kadane),\n    (\"With Indices\", lambda x: max_subarray_with_indices(x)[0]),\n    (\"Dynamic Programming\", max_subarray_dp),\n    (\"Divide & Conquer\", max_subarray_divide_conquer),\n    (\"Prefix Sum\", max_subarray_prefix),\n    (\"Brute Force\", max_subarray_brute_force),\n]\n\nfor i, (nums, expected, description) in enumerate(interview_test_cases, 1):\n    print(f\"\\nðŸ“ Test {i}: {description}\")\n    print(f\"Array: {nums}\")\n    print(f\"Expected: {expected}\")\n    \n    all_correct = True\n    for method_name, method_func in methods:\n        try:\n            result = method_func(nums.copy())\n            is_correct = result == expected\n            if not is_correct:\n                all_correct = False\n            print(f\"  {method_name}: {result} {'âœ…' if is_correct else 'âŒ'}\")\n        except Exception as e:\n            print(f\"  {method_name}: Error - {e}\")\n            all_correct = False\n    \n    print(f\"âœ… All methods correct: {all_correct}\")\n\n# ðŸŽ¯ DETAILED WALKTHROUGH\nprint(f\"\\nðŸŽ¯ KADANE'S ALGORITHM WALKTHROUGH:\")\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(f\"Array: {nums}\")\nprint(\"Step-by-step execution:\")\n\nmax_ending_here = max_so_far = nums[0]\nprint(f\"Initialize: max_ending_here = {max_ending_here}, max_so_far = {max_so_far}\")\n\nfor i in range(1, len(nums)):\n    old_max_ending = max_ending_here\n    max_ending_here = max(nums[i], max_ending_here + nums[i])\n    max_so_far = max(max_so_far, max_ending_here)\n    \n    decision = \"extend\" if max_ending_here == old_max_ending + nums[i] else \"restart\"\n    print(f\"i={i}, nums[{i}]={nums[i]:2}: {decision:7} â†’ max_ending={max_ending_here:2}, max_so_far={max_so_far}\")\n\n# Show the actual subarray\nmax_sum, start, end = max_subarray_with_indices(nums)\nprint(f\"\\nOptimal subarray: {nums[start:end+1]} = {max_sum}\")\n\n# ðŸ’¼ CAREER TRANSFORMATION IMPACT\nprint(f\"\\nðŸ’¼ CAREER TRANSFORMATION METRICS:\")\nprint(\"ðŸ† Asked in 90%+ of array/DP interviews\")\nprint(\"ðŸ† Demonstrates algorithmic thinking mastery\")\nprint(\"ðŸ† Gateway to advanced DP problems\")\nprint(\"ðŸ† Shows optimization skills (O(nÂ²) â†’ O(n))\")\nprint(\"ðŸ† Required for senior+ engineering roles\")\n\n# ðŸŽ¯ INTERVIEW MASTERY TIPS\nprint(f\"\\nðŸŽ¯ INTERVIEW DOMINATION STRATEGY:\")\nprint(\"1. âš¡ State the problem clearly\")\nprint(\"2. âš¡ Mention brute force O(nÂ²) solution first\")\nprint(\"3. âš¡ Introduce Kadane's as optimization\")\nprint(\"4. âš¡ Explain the key insight: extend vs restart\")\nprint(\"5. âš¡ Handle edge cases (empty, all negative)\")\nprint(\"6. âš¡ Analyze time/space complexity\")\n\n# ðŸ”¥ FOLLOW-UP VARIATIONS\nprint(f\"\\nðŸ”¥ COMMON FOLLOW-UP QUESTIONS:\")\nprint(\"â€¢ Return the actual subarray (not just sum)\")\nprint(\"â€¢ Maximum subarray of size exactly k\")\nprint(\"â€¢ Maximum circular subarray\")\nprint(\"â€¢ Maximum product subarray\")\nprint(\"â€¢ Maximum sum with no adjacent elements\")\nprint(\"â€¢ 2D version: Maximum rectangle in matrix\")\n\n# ðŸš€ PERFORMANCE COMPARISON\nprint(f\"\\nðŸš€ ALGORITHM PERFORMANCE:\")\nprint(\"â€¢ Kadane's: O(n) time, O(1) space - OPTIMAL!\")\nprint(\"â€¢ Divide & Conquer: O(n log n) time, O(log n) space\")\nprint(\"â€¢ Brute Force: O(nÂ²) time, O(1) space - Too slow!\")\nprint(\"â€¢ DP explicit: O(n) time, O(n) space - Unnecessary\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"â­ LEGEND STATUS: Master Kadane's = Master Dynamic Programming\")\nprint(\"â­ This algorithm alone can secure your dream job!\")\nprint(\"â­ Practice until you can implement it blindfolded!\")\nprint(\"=\"*60)\n```\n\n## ðŸŽ¯ FINAL INTERVIEW SUCCESS CHECKLIST\n\n**Congratulations! You now have a comprehensive arsenal of interview-winning algorithms!**\n\n### ðŸ† Career-Defining Problems You've Mastered:\n\n1. **âœ… Merge Intervals** - Algorithm design & edge cases\n2. **âœ… Valid Parentheses** - Stack mastery & parsing\n3. **âœ… Binary Tree Level Order** - BFS/DFS & tree traversal\n4. **âœ… Maximum Subarray (Kadane's)** - Dynamic programming legend\n5. **âœ… Two Sum** - Hash table fundamentals\n6. **âœ… Balanced Parentheses** - Stack applications\n7. **âœ… Binary Tree Operations** - Tree manipulation\n8. **âœ… Sorting Algorithms** - Algorithm analysis\n9. **âœ… FizzBuzz Variations** - Problem solving creativity\n10. **âœ… Array & String Challenges** - Core data structure mastery\n\n### ðŸš€ Your Interview Success Strategy:\n\n**Before Every Interview:**\n1. **Practice the big 4**: Merge Intervals, Valid Parentheses, Tree Traversal, Kadane's Algorithm\n2. **Review time/space complexity** for each solution\n3. **Prepare follow-up questions** and variations\n4. **Practice explaining** your thought process clearly\n\n**During the Interview:**\n1. **Start with clarifying questions** and edge cases\n2. **Discuss brute force** before optimizing\n3. **Think out loud** throughout the process\n4. **Test your solution** with the given examples\n5. **Analyze complexity** and suggest improvements\n\n### ðŸ’¼ Career Advancement Roadmap:\n\n**Junior â†’ Mid-Level Developer:**\n- Master basic data structures (arrays, strings, hash maps)\n- Understand fundamental algorithms (sorting, searching)\n- Practice explaining code clearly\n\n**Mid-Level â†’ Senior Developer:**\n- Master complex algorithms (dynamic programming, graph algorithms)\n- Design scalable solutions\n- Lead technical discussions\n\n**Senior â†’ Staff/Principal:**\n- Architect large-scale systems\n- Optimize for performance and scalability\n- Mentor others in algorithmic thinking\n\n### ðŸŽ¯ Next Steps for Continued Growth:\n\n1. **Practice regularly** - 2-3 problems per week minimum\n2. **Time yourself** - aim for solutions within interview time limits\n3. **Join coding communities** - LeetCode, HackerRank, Codeforces\n4. **Mock interviews** - practice with peers or platforms like Pramp\n5. **Study system design** - for senior positions\n6. **Contribute to open source** - showcase your skills\n\n---\n\n**Remember: Consistency beats perfection. Keep practicing, and these algorithms will become second nature!**\n\n"}