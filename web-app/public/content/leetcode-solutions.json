{"id":"leetcode-solutions","title":"ğŸ’» LeetCode Solutions","content":"# LeetCode Solutions\n\nA collection of LeetCode problems with detailed explanations and solutions in Python and JavaScript.\n\n---\n\n## 1. Two Sum\n\n**Difficulty:** Easy  \n**Topics:** Array, Hash Table\n\n### Problem Statement\n\nGiven an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to target.\n\n**Constraints:**\n- You may assume that each input would have exactly one solution\n- You may not use the same element twice\n- You can return the answer in any order\n- 2 <= nums.length <= 10^4\n- -10^9 <= nums[i] <= 10^9\n- -10^9 <= target <= 10^9\n\n### Examples\n\n```\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1]\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n```\n\n### Real-World Analogy ğŸŒ\n\nImagine you're at a grocery store with a $10 bill. You want to buy exactly 2 items that total $10. As you walk through the store:\n- You see an item for $3, you remember \"I need to find something for $7\"\n- You see an item for $5, you remember \"I need to find something for $5\"\n- When you find that $5 item again (or another $5 item), you realize \"Hey! I've seen this price before!\"\n\nThis is exactly how our hash map solution works - we remember what we've seen and what we need!\n\n### Approach 1: Brute Force âš ï¸\n\n**Idea:** Check every pair of numbers to see if they add up to the target.\n\n**Time Complexity:** O(nÂ²)  \n**Space Complexity:** O(1)\n\n**When to use:** Only for very small arrays or when memory is extremely limited.\n\n#### Python Implementation:\n```python\ndef twoSum_bruteforce(nums, target):\n    \"\"\"Brute force approach - check all pairs\"\"\"\n    n = len(nums)\n    \n    # Check every possible pair\n    for i in range(n):\n        for j in range(i + 1, n):  # Start from i+1 to avoid same element\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    \n    return []\n\n# Test\nprint(twoSum_bruteforce([2, 7, 11, 15], 9))  # Output: [0, 1]\n```\n\n#### JavaScript Implementation:\n```javascript\nfunction twoSum_bruteforce(nums, target) {\n    const n = nums.length;\n    \n    // Check every possible pair\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {  // Start from i+1\n            if (nums[i] + nums[j] === target) {\n                return [i, j];\n            }\n        }\n    }\n    \n    return [];\n}\n\n// Test\nconsole.log(twoSum_bruteforce([2, 7, 11, 15], 9));  // Output: [0, 1]\n```\n\n**Pros:** \n- Simple to understand\n- No extra space needed\n- Works on any input\n\n**Cons:** \n- Very slow for large arrays (nÂ² comparisons)\n- Not acceptable for interviews\n\n---\n\n### Approach 2: Two-Pass Hash Map\n\n**Idea:** First pass builds the hash map, second pass finds the complement.\n\n**Time Complexity:** O(n)  \n**Space Complexity:** O(n)\n\n**When to use:** When you want clear separation of concerns (build index, then search).\n\n#### Python Implementation:\n```python\ndef twoSum_twopass(nums, target):\n    \"\"\"Two-pass hash map approach\"\"\"\n    # First pass: build the hash map\n    seen = {}\n    for i, num in enumerate(nums):\n        seen[num] = i\n    \n    # Second pass: find the complement\n    for i, num in enumerate(nums):\n        complement = target - num\n        # Check if complement exists AND it's not the same element\n        if complement in seen and seen[complement] != i:\n            return [i, seen[complement]]\n    \n    return []\n\n# Test\nprint(twoSum_twopass([2, 7, 11, 15], 9))  # Output: [0, 1]\n```\n\n#### JavaScript Implementation:\n```javascript\nfunction twoSum_twopass(nums, target) {\n    // First pass: build the hash map\n    const seen = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        seen.set(nums[i], i);\n    }\n    \n    // Second pass: find the complement\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        // Check if complement exists AND it's not the same element\n        if (seen.has(complement) && seen.get(complement) !== i) {\n            return [i, seen.get(complement)];\n        }\n    }\n    \n    return [];\n}\n\n// Test\nconsole.log(twoSum_twopass([2, 7, 11, 15], 9));  // Output: [0, 1]\n```\n\n**Pros:** \n- Clear two-step logic\n- Still O(n) time complexity\n\n**Cons:** \n- Two passes through the array\n- Slightly more code\n- Same space as one-pass approach\n\n---\n\n### Approach 3: One-Pass Hash Map (Optimal) âœ…\n\n**Idea:** Use a hash map to store numbers we've seen and their indices. For each number, check if its complement (target - current number) exists in the map.\n\n**Time Complexity:** O(n) - Single pass through array  \n**Space Complexity:** O(n) - Hash map storage\n\n**Step-by-Step Process:**\n1. Create an empty hash map\n2. For each number in the array:\n   - Calculate complement = target - current number\n   - Check if complement exists in hash map\n   - If yes: return [index of complement, current index]\n   - If no: store current number and its index in hash map\n3. Continue until pair is found\n\n### Solution in Python ğŸ\n\n```python\ndef twoSum(nums, target):\n    \"\"\"\n    Find two numbers in array that sum to target.\n    \n    Args:\n        nums: List of integers\n        target: Target sum\n    \n    Returns:\n        List containing indices of the two numbers\n    \"\"\"\n    # Dictionary to store number: index mapping\n    seen = {}\n    \n    # Iterate through the array with index and value\n    for i, num in enumerate(nums):\n        # Calculate what number we need to reach target\n        complement = target - num\n        \n        # Check if we've seen the complement before\n        if complement in seen:\n            # Found the pair! Return indices\n            return [seen[complement], i]\n        \n        # Store current number and its index\n        seen[num] = i\n    \n    # No solution found (won't happen per problem constraints)\n    return []\n\n\n# Test cases\nprint(twoSum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(twoSum([3, 2, 4], 6))        # Output: [1, 2]\nprint(twoSum([3, 3], 6))           # Output: [0, 1]\n```\n\n### Solution in JavaScript ğŸŸ¨\n\n```javascript\n/**\n * Find two numbers in array that sum to target\n * @param {number[]} nums - Array of integers\n * @param {number} target - Target sum\n * @return {number[]} - Indices of the two numbers\n */\nfunction twoSum(nums, target) {\n    // Map to store number: index mapping\n    const seen = new Map();\n    \n    // Iterate through the array\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        // Calculate what number we need to reach target\n        const complement = target - num;\n        \n        // Check if we've seen the complement before\n        if (seen.has(complement)) {\n            // Found the pair! Return indices\n            return [seen.get(complement), i];\n        }\n        \n        // Store current number and its index\n        seen.set(num, i);\n    }\n    \n    // No solution found (won't happen per problem constraints)\n    return [];\n}\n\n// Test cases\nconsole.log(twoSum([2, 7, 11, 15], 9));  // Output: [0, 1]\nconsole.log(twoSum([3, 2, 4], 6));        // Output: [1, 2]\nconsole.log(twoSum([3, 3], 6));           // Output: [0, 1]\n```\n\n### Dry Run Example ğŸ“\n\nLet's trace through `nums = [2, 7, 11, 15]`, `target = 9`:\n\n| Step | i | num | complement | seen (before) | Action | seen (after) |\n|------|---|-----|------------|---------------|--------|--------------|\n| 1 | 0 | 2 | 7 | {} | 7 not in seen, add 2 | {2: 0} |\n| 2 | 1 | 7 | 2 | {2: 0} | 2 in seen! Return [0, 1] | - |\n\n**Result:** `[0, 1]` âœ“\n\n### Key Insights ğŸ’¡\n\n1. **Hash Map is Key:** Trading space for time - we use extra memory to achieve O(n) time\n2. **Single Pass:** We only need to go through the array once\n3. **Complement Logic:** Instead of checking all pairs, we check if `target - current` exists\n4. **Order Matters:** We store numbers as we see them, so we naturally find the first valid pair\n\n### Common Mistakes to Avoid âš ï¸\n\n1. âŒ Using the same element twice (e.g., using index 0 twice)\n2. âŒ Sorting the array first (this changes indices!)\n3. âŒ Not handling duplicate numbers correctly\n4. âŒ Returning values instead of indices\n\n### Follow-up Question Answer\n\n**Q: Can you come up with an algorithm that is less than O(nÂ²) time complexity?**\n\n**A:** Yes! The hash map approach above achieves O(n) time complexity, which is optimal for this problem. We can't do better than O(n) because we must examine each element at least once.\n\n---\n\n## ğŸ“Š Comparison of All Approaches\n\n| Approach | Time | Space | Passes | Best Use Case |\n|----------|------|-------|--------|---------------|\n| **Brute Force** | O(nÂ²) | O(1) | 1 | Very small arrays only |\n| **Two-Pass Hash** | O(n) | O(n) | 2 | Learning/clarity |\n| **One-Pass Hash** âœ… | O(n) | O(n) | 1 | **Production code** |\n\n### Which Solution to Use?\n\n**For Interviews:** Always use **Approach 3 (One-Pass Hash Map)** âœ…\n- Optimal time and space complexity\n- Shows you understand hash maps\n- Most efficient solution\n\n**For Learning:** Start with **Approach 1 (Brute Force)**\n- Easiest to understand\n- Good starting point before optimization\n\n**Alternative in Memory-Critical Systems:** Consider **Approach 1** if:\n- Array is very small (< 100 elements)\n- Memory is extremely limited\n- O(nÂ²) is acceptable for your use case\n\n---\n\n## ğŸ“ Additional Solutions (Advanced)\n\n### Approach 4: Sorting + Two Pointers (Changes Indices!) âš ï¸\n\n**Note:** This approach only works if you **don't need to return indices**, because sorting changes the original positions.\n\n**Time Complexity:** O(n log n) - due to sorting  \n**Space Complexity:** O(n) - to store index mappings\n\n#### Python Implementation:\n```python\ndef twoSum_sorted(nums, target):\n    \"\"\"\n    Sorting + Two Pointers approach\n    Note: Returns values, not indices (or needs extra work for indices)\n    \"\"\"\n    # Create list of (value, original_index) pairs\n    indexed_nums = [(num, i) for i, num in enumerate(nums)]\n    \n    # Sort by value\n    indexed_nums.sort(key=lambda x: x[0])\n    \n    # Two pointers approach\n    left = 0\n    right = len(indexed_nums) - 1\n    \n    while left < right:\n        current_sum = indexed_nums[left][0] + indexed_nums[right][0]\n        \n        if current_sum == target:\n            # Return original indices\n            return sorted([indexed_nums[left][1], indexed_nums[right][1]])\n        elif current_sum < target:\n            left += 1  # Need larger sum\n        else:\n            right -= 1  # Need smaller sum\n    \n    return []\n\n# Test\nprint(twoSum_sorted([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(twoSum_sorted([3, 2, 4], 6))       # Output: [1, 2]\n```\n\n#### JavaScript Implementation:\n```javascript\nfunction twoSum_sorted(nums, target) {\n    // Create array of [value, originalIndex] pairs\n    const indexedNums = nums.map((num, i) => [num, i]);\n    \n    // Sort by value\n    indexedNums.sort((a, b) => a[0] - b[0]);\n    \n    // Two pointers approach\n    let left = 0;\n    let right = indexedNums.length - 1;\n    \n    while (left < right) {\n        const currentSum = indexedNums[left][0] + indexedNums[right][0];\n        \n        if (currentSum === target) {\n            // Return original indices in sorted order\n            return [\n                Math.min(indexedNums[left][1], indexedNums[right][1]),\n                Math.max(indexedNums[left][1], indexedNums[right][1])\n            ];\n        } else if (currentSum < target) {\n            left++;  // Need larger sum\n        } else {\n            right--;  // Need smaller sum\n        }\n    }\n    \n    return [];\n}\n\n// Test\nconsole.log(twoSum_sorted([2, 7, 11, 15], 9));  // Output: [0, 1]\nconsole.log(twoSum_sorted([3, 2, 4], 6));       // Output: [1, 2]\n```\n\n**How Two Pointers Works:**\n```\nSorted array: [2, 7, 11, 15], target = 9\n\nStep 1: left=0 (val=2), right=3 (val=15)\n        2 + 15 = 17 > 9, move right left (too big)\n\nStep 2: left=0 (val=2), right=2 (val=11)\n        2 + 11 = 13 > 9, move right left\n\nStep 3: left=0 (val=2), right=1 (val=7)\n        2 + 7 = 9 = target âœ“ Found it!\n```\n\n**Pros:**\n- Good for finding pairs in general (without index requirement)\n- Works well when array is already sorted\n- No hash map needed\n\n**Cons:**\n- Slower than hash map (O(n log n) vs O(n))\n- Extra complexity to track original indices\n- Not the best solution for this specific problem\n\n---\n\n## ğŸ¯ Summary: When to Use Each Approach\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  Problem Variation          â†’   Best Approach           â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Return indices (original)  â†’   One-Pass Hash Map âœ…    â”‚\nâ”‚  Return values only         â†’   Two Pointers (sorted)   â”‚\nâ”‚  Array already sorted       â†’   Two Pointers            â”‚\nâ”‚  Very small array (n < 50)  â†’   Brute Force             â”‚\nâ”‚  Teaching/Learning          â†’   Any approach            â”‚\nâ”‚  Interview/Production       â†’   One-Pass Hash Map âœ…    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Pro Interview Tip:** \n1. Start by explaining Brute Force (shows problem understanding)\n2. Explain why it's not optimal (O(nÂ²))\n3. Propose One-Pass Hash Map (optimal solution)\n4. Code the optimal solution\n5. Mention Two Pointers as alternative (bonus points!)\n\n---\n\n## ğŸ“‹ Template for New Problems\n\nCopy the template below to add new LeetCode problems:\n\n```markdown\n---\n\n## [NUMBER]. [PROBLEM NAME]\n\n**Difficulty:** [Easy/Medium/Hard]  \n**Topics:** [Topic1, Topic2, Topic3]\n\n### Problem Statement\n\n[Paste the problem description here]\n\n**Constraints:**\n- [Constraint 1]\n- [Constraint 2]\n\n### Examples\n\n```\nExample 1:\nInput: [input]\nOutput: [output]\nExplanation: [explanation]\n\nExample 2:\nInput: [input]\nOutput: [output]\n```\n\n### Real-World Analogy ğŸŒ\n\n[Explain the problem using a real-world scenario that's easy to understand]\n\n### Approach: [APPROACH NAME] âœ…\n\n**Idea:** [Brief explanation of the approach]\n\n**Time Complexity:** O(?)  \n**Space Complexity:** O(?)\n\n**Step-by-Step Process:**\n1. [Step 1]\n2. [Step 2]\n3. [Step 3]\n\n### Solution in Python ğŸ\n\n```python\ndef solutionName(params):\n    \"\"\"\n    [Brief description]\n    \n    Args:\n        param1: [description]\n        param2: [description]\n    \n    Returns:\n        [description]\n    \"\"\"\n    # Your solution here\n    pass\n\n\n# Test cases\nprint(solutionName(test1))  # Output: [expected]\nprint(solutionName(test2))  # Output: [expected]\n```\n\n### Solution in JavaScript ğŸŸ¨\n\n```javascript\n/**\n * [Brief description]\n * @param {type} param1 - [description]\n * @param {type} param2 - [description]\n * @return {type} - [description]\n */\nfunction solutionName(params) {\n    // Your solution here\n}\n\n// Test cases\nconsole.log(solutionName(test1));  // Output: [expected]\nconsole.log(solutionName(test2));  // Output: [expected]\n```\n\n### Dry Run Example ğŸ“\n\n[Show step-by-step execution with a table or bullet points]\n\n### Key Insights ğŸ’¡\n\n1. **[Insight 1]:** [Explanation]\n2. **[Insight 2]:** [Explanation]\n3. **[Insight 3]:** [Explanation]\n\n### Common Mistakes to Avoid âš ï¸\n\n1. âŒ [Mistake 1]\n2. âŒ [Mistake 2]\n3. âŒ [Mistake 3]\n\n```\n\n---\n\n## ğŸš€ Quick Add Guide\n\n**To add a new problem quickly:**\n\n1. **Copy** the template above (everything between the two `---` separators)\n2. **Paste** it at the end of this file (before this guide section)\n3. **Replace** all placeholders in `[brackets]` with actual content\n4. **Fill in** the Python and JavaScript solutions\n5. **Add** a real-world analogy to make it memorable\n6. **Include** test cases and dry run examples\n\n**Pro Tips:**\n- Keep explanations simple and conversational\n- Use emojis to make sections visually distinct\n- Always include time/space complexity\n- Add edge cases to test cases\n- Number problems sequentially (1, 2, 3...)\n\n**Common Topics to Tag:**\n- Array, String, Hash Table, Two Pointers\n- Stack, Queue, Linked List, Tree, Graph\n- Binary Search, Sorting, Recursion, Backtracking\n- Dynamic Programming, Greedy, Divide and Conquer\n- Sliding Window, Heap, Trie, Union Find\n\n---\n\n"}