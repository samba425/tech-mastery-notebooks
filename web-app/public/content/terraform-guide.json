{"id":"terraform-guide","title":"ðŸ—ï¸ Terraform Zero to Hero","content":"# Terraform: Zero to Hero Course\n\n**Complete Guide with Simple Explanations and Examples**\n\n---\n\n## Table of Contents\n1. [Introduction to Terraform](#1-introduction-to-terraform)\n2. [Installation and Setup](#2-installation-and-setup)\n3. [Terraform Basics](#3-terraform-basics)\n4. [Providers](#4-providers)\n5. [Resources](#5-resources)\n6. [Variables](#6-variables)\n7. [Outputs](#7-outputs)\n8. [Data Sources](#8-data-sources)\n9. [State Management](#9-state-management)\n10. [Modules](#10-modules)\n11. [Provisioners](#11-provisioners)\n12. [Functions and Expressions](#12-functions-and-expressions)\n13. [Workspaces](#13-workspaces)\n14. [Remote State](#14-remote-state)\n15. [Best Practices](#15-best-practices)\n16. [Advanced Topics](#16-advanced-topics)\n17. [Real-World Project](#17-real-world-project)\n\n---\n\n## 1. Introduction to Terraform\n\n### What is Terraform?\nTerraform is like a blueprint maker for cloud infrastructure. Instead of clicking buttons in AWS, Azure, or Google Cloud, you write simple code that describes what you want, and Terraform builds it for you automatically. Think of it as \"infrastructure as code\" - you write recipes (code) and Terraform cooks (builds) your cloud infrastructure.\n\n### Why Use Terraform?\n- **Version Control**: Track changes to your infrastructure like you track code changes\n- **Reusability**: Write once, use many times across different environments\n- **Automation**: No more manual clicking through cloud consoles\n\n### Key Concepts (Simple Terms)\n- **Provider**: The cloud service you're using (AWS, Azure, Google Cloud, etc.)\n- **Resource**: Something you want to create (like a server, database, or network)\n- **State**: Terraform's memory of what it has created\n- **Plan**: A preview of what Terraform will do before it does it\n- **Apply**: Actually creating/changing your infrastructure\n\n---\n\n## 2. Installation and Setup\n\n### Installing Terraform\n\n**macOS:**\n```bash\nbrew tap hashicorp/tap\nbrew install hashicorp/tap/terraform\n```\n\n**Linux:**\n```bash\nwget https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip\nunzip terraform_1.6.0_linux_amd64.zip\nsudo mv terraform /usr/local/bin/\n```\n\n**Windows:**\n```powershell\nchoco install terraform\n```\n\n### Verify Installation\n```bash\nterraform version\n```\n\n### Basic Commands Overview\n```bash\nterraform init      # Initialize project (download providers)\nterraform plan      # Preview changes\nterraform apply     # Create/update infrastructure\nterraform destroy   # Delete everything\nterraform fmt       # Format your code nicely\nterraform validate  # Check if code is correct\n```\n\n---\n\n## 3. Terraform Basics\n\n### Your First Terraform File\n\n**Simple Explanation**: This creates a basic file on your computer. It's the \"Hello World\" of Terraform - the simplest thing you can create.\n\n**File: `main.tf`**\n```hcl\n# This creates a simple text file on your computer\nresource \"local_file\" \"hello\" {\n  filename = \"hello.txt\"\n  content  = \"Hello from Terraform!\"\n}\n```\n\n**Run it:**\n```bash\nterraform init    # Get ready (downloads the 'local' provider)\nterraform plan    # See what will happen\nterraform apply   # Create the file (type 'yes' when asked)\n```\n\n**What happens**: Terraform creates a file called `hello.txt` with the text \"Hello from Terraform!\" in your current directory.\n\n---\n\n## 4. Providers\n\n### What is a Provider?\nA provider is like a translator between Terraform and cloud services. AWS speaks its own language, Azure speaks differently - providers help Terraform talk to all of them.\n\n### AWS Provider Example\n\n**Simple Explanation**: This tells Terraform \"I want to use AWS, and I want to create things in the US East region.\"\n\n```hcl\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n```\n\n### Multi-Provider Example\n\n**Simple Explanation**: You can use multiple cloud providers in one project. Here we use both AWS and Azure.\n\n```hcl\n# AWS Provider\nprovider \"aws\" {\n  region = \"us-east-1\"\n  alias  = \"us_east\"\n}\n\n# Azure Provider\nprovider \"azurerm\" {\n  features {}\n}\n\n# Use specific provider\nresource \"aws_s3_bucket\" \"my_bucket\" {\n  provider = aws.us_east\n  bucket   = \"my-awesome-bucket\"\n}\n```\n\n---\n\n## 5. Resources\n\n### What is a Resource?\nA resource is anything you want to create in the cloud - a virtual machine, a database, a storage bucket, etc. It's the actual \"thing\" you're building.\n\n### EC2 Instance (Virtual Server) Example\n\n**Simple Explanation**: This creates a virtual computer in AWS. The `ami` is the operating system image, and `instance_type` is how powerful the computer is (t2.micro is the smallest/cheapest).\n\n```hcl\nresource \"aws_instance\" \"web_server\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"  # Ubuntu 20.04\n  instance_type = \"t2.micro\"                # Small, free-tier server\n  \n  tags = {\n    Name = \"MyWebServer\"\n    Environment = \"Development\"\n  }\n}\n```\n\n### S3 Bucket (Cloud Storage) Example\n\n**Simple Explanation**: This creates a storage bucket in AWS where you can store files, like Dropbox but for your applications.\n\n```hcl\nresource \"aws_s3_bucket\" \"my_bucket\" {\n  bucket = \"my-unique-bucket-name-12345\"\n  \n  tags = {\n    Name        = \"My Bucket\"\n    Environment = \"Dev\"\n  }\n}\n\n# Make the bucket private (secure)\nresource \"aws_s3_bucket_acl\" \"bucket_acl\" {\n  bucket = aws_s3_bucket.my_bucket.id\n  acl    = \"private\"\n}\n```\n\n### Resource Dependencies\n\n**Simple Explanation**: Sometimes one resource depends on another (you need a network before you can create a server in it). Terraform automatically figures this out when you reference one resource in another.\n\n```hcl\n# First create a VPC (Virtual Private Cloud - like your own network)\nresource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n}\n\n# Then create a subnet inside that VPC\nresource \"aws_subnet\" \"public\" {\n  vpc_id     = aws_vpc.main.id  # This creates automatic dependency\n  cidr_block = \"10.0.1.0/24\"\n}\n\n# Finally create a server in that subnet\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  subnet_id     = aws_subnet.public.id  # Depends on subnet\n}\n```\n\n---\n\n## 6. Variables\n\n### What are Variables?\nVariables are like blank spaces in a form that you can fill in differently each time. Instead of hardcoding values, you use variables to make your code reusable.\n\n### Basic Variable Definition\n\n**Simple Explanation**: Define variables in `variables.tf` so you can change values without editing the main code.\n\n**File: `variables.tf`**\n```hcl\n# Simple string variable\nvariable \"region\" {\n  description = \"AWS region to deploy resources\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\n# Number variable\nvariable \"instance_count\" {\n  description = \"Number of EC2 instances to create\"\n  type        = number\n  default     = 2\n}\n\n# Boolean variable (true/false)\nvariable \"enable_monitoring\" {\n  description = \"Enable CloudWatch monitoring\"\n  type        = bool\n  default     = true\n}\n\n# List variable (multiple values)\nvariable \"availability_zones\" {\n  description = \"List of availability zones\"\n  type        = list(string)\n  default     = [\"us-east-1a\", \"us-east-1b\"]\n}\n\n# Map variable (key-value pairs)\nvariable \"instance_tags\" {\n  description = \"Tags for EC2 instances\"\n  type        = map(string)\n  default = {\n    Environment = \"Dev\"\n    Team        = \"Engineering\"\n  }\n}\n```\n\n### Using Variables\n\n**File: `main.tf`**\n```hcl\nprovider \"aws\" {\n  region = var.region  # Use the variable\n}\n\nresource \"aws_instance\" \"web\" {\n  count         = var.instance_count  # Create multiple instances\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  monitoring = var.enable_monitoring\n  \n  tags = var.instance_tags\n}\n```\n\n### Providing Variable Values\n\n**Method 1: terraform.tfvars file**\n```hcl\nregion         = \"us-west-2\"\ninstance_count = 3\nenable_monitoring = false\n```\n\n**Method 2: Command line**\n```bash\nterraform apply -var=\"region=us-west-2\" -var=\"instance_count=3\"\n```\n\n**Method 3: Environment variables**\n```bash\nexport TF_VAR_region=\"us-west-2\"\nterraform apply\n```\n\n---\n\n## 7. Outputs\n\n### What are Outputs?\nOutputs are like receipts - after Terraform creates something, outputs show you important information about what was created (like IP addresses, URLs, etc.).\n\n### Basic Output Examples\n\n**Simple Explanation**: After creating resources, you often need to know details about them (like the IP address of a server). Outputs display this information.\n\n**File: `outputs.tf`**\n```hcl\n# Output the instance's public IP address\noutput \"instance_ip\" {\n  description = \"The public IP address of the web server\"\n  value       = aws_instance.web.public_ip\n}\n\n# Output the S3 bucket name\noutput \"bucket_name\" {\n  description = \"The name of the S3 bucket\"\n  value       = aws_s3_bucket.my_bucket.id\n}\n\n# Output multiple instance IPs (when count is used)\noutput \"all_instance_ips\" {\n  description = \"Public IPs of all web servers\"\n  value       = aws_instance.web[*].public_ip\n}\n\n# Sensitive output (won't show in console by default)\noutput \"database_password\" {\n  description = \"RDS database password\"\n  value       = aws_db_instance.main.password\n  sensitive   = true\n}\n```\n\n### Viewing Outputs\n```bash\nterraform output              # Show all outputs\nterraform output instance_ip  # Show specific output\nterraform output -json        # Get outputs in JSON format\n```\n\n---\n\n## 8. Data Sources\n\n### What are Data Sources?\nData sources let you fetch information about existing resources (not created by Terraform). It's like looking up information in a phone book - you're reading, not creating.\n\n### Example: Getting Latest AMI\n\n**Simple Explanation**: Instead of hardcoding an AMI ID (which changes), use a data source to automatically find the latest Ubuntu image.\n\n```hcl\n# Find the latest Ubuntu AMI\ndata \"aws_ami\" \"ubuntu\" {\n  most_recent = true\n  owners      = [\"099720109477\"]  # Canonical (Ubuntu's owner)\n  \n  filter {\n    name   = \"name\"\n    values = [\"ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*\"]\n  }\n}\n\n# Use the data source in a resource\nresource \"aws_instance\" \"web\" {\n  ami           = data.aws_ami.ubuntu.id  # Use the found AMI\n  instance_type = \"t2.micro\"\n}\n```\n\n### Example: Getting Existing VPC\n\n**Simple Explanation**: If a VPC already exists (maybe created manually), use a data source to find it and use it in your code.\n\n```hcl\n# Find existing VPC by tag\ndata \"aws_vpc\" \"existing\" {\n  tags = {\n    Name = \"my-existing-vpc\"\n  }\n}\n\n# Create subnet in the existing VPC\nresource \"aws_subnet\" \"new_subnet\" {\n  vpc_id     = data.aws_vpc.existing.id\n  cidr_block = \"10.0.1.0/24\"\n}\n```\n\n---\n\n## 9. State Management\n\n### What is State?\nState is Terraform's memory - it remembers what it created so it knows what to update or delete. The state file (`terraform.tfstate`) is like a detailed receipt of everything Terraform has built.\n\n### State Commands\n\n**Simple Explanation**: These commands help you inspect and manage what Terraform knows about your infrastructure.\n\n```bash\n# List all resources in state\nterraform state list\n\n# Show details of a specific resource\nterraform state show aws_instance.web\n\n# Remove a resource from state (doesn't delete actual resource)\nterraform state rm aws_instance.web\n\n# Move a resource to a different name in state\nterraform state mv aws_instance.web aws_instance.web_server\n\n# Pull remote state to local\nterraform state pull > terraform.tfstate.backup\n```\n\n### Local Backend (Default)\n\n**Simple Explanation**: By default, state is stored in a local file. This works for solo projects but not for teams.\n\n```hcl\nterraform {\n  backend \"local\" {\n    path = \"terraform.tfstate\"\n  }\n}\n```\n\n### Remote Backend (S3)\n\n**Simple Explanation**: Store state in S3 so your whole team can access it. The DynamoDB table prevents two people from running Terraform at the same time (state locking).\n\n```hcl\nterraform {\n  backend \"s3\" {\n    bucket         = \"my-terraform-state-bucket\"\n    key            = \"prod/terraform.tfstate\"\n    region         = \"us-east-1\"\n    dynamodb_table = \"terraform-state-lock\"\n    encrypt        = true\n  }\n}\n```\n\n---\n\n## 10. Modules\n\n### What are Modules?\nModules are like reusable templates - instead of copying and pasting code, you create a module once and reuse it many times. It's like having a recipe that you can use to cook the same meal repeatedly.\n\n### Creating a Simple Module\n\n**Simple Explanation**: Group related resources together into a module. Here's a module that creates a web server with all necessary components.\n\n**Directory Structure:**\n```\nmodules/\n  web-server/\n    main.tf\n    variables.tf\n    outputs.tf\nroot/\n  main.tf\n```\n\n**File: `modules/web-server/main.tf`**\n```hcl\nresource \"aws_instance\" \"server\" {\n  ami           = var.ami_id\n  instance_type = var.instance_type\n  \n  tags = {\n    Name = var.server_name\n  }\n}\n\nresource \"aws_security_group\" \"server_sg\" {\n  name = \"${var.server_name}-sg\"\n  \n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n```\n\n**File: `modules/web-server/variables.tf`**\n```hcl\nvariable \"ami_id\" {\n  description = \"AMI ID for the instance\"\n  type        = string\n}\n\nvariable \"instance_type\" {\n  description = \"Instance type\"\n  type        = string\n  default     = \"t2.micro\"\n}\n\nvariable \"server_name\" {\n  description = \"Name of the server\"\n  type        = string\n}\n```\n\n**File: `modules/web-server/outputs.tf`**\n```hcl\noutput \"instance_id\" {\n  value = aws_instance.server.id\n}\n\noutput \"public_ip\" {\n  value = aws_instance.server.public_ip\n}\n```\n\n### Using the Module\n\n**File: `main.tf`**\n```hcl\n# Use the module to create a dev web server\nmodule \"dev_server\" {\n  source        = \"./modules/web-server\"\n  ami_id        = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  server_name   = \"dev-web-server\"\n}\n\n# Use the same module for production\nmodule \"prod_server\" {\n  source        = \"./modules/web-server\"\n  ami_id        = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.large\"\n  server_name   = \"prod-web-server\"\n}\n\n# Access module outputs\noutput \"dev_ip\" {\n  value = module.dev_server.public_ip\n}\n```\n\n### Using Public Modules\n\n**Simple Explanation**: Instead of writing everything from scratch, use pre-built modules from the Terraform Registry (like using npm packages or pip libraries).\n\n```hcl\n# Use AWS VPC module from Terraform Registry\nmodule \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"5.0.0\"\n  \n  name = \"my-vpc\"\n  cidr = \"10.0.0.0/16\"\n  \n  azs             = [\"us-east-1a\", \"us-east-1b\"]\n  private_subnets = [\"10.0.1.0/24\", \"10.0.2.0/24\"]\n  public_subnets  = [\"10.0.101.0/24\", \"10.0.102.0/24\"]\n  \n  enable_nat_gateway = true\n  enable_vpn_gateway = false\n}\n```\n\n---\n\n## 11. Provisioners\n\n### What are Provisioners?\nProvisioners run scripts or commands on resources after they're created. Think of it as the \"post-installation setup\" - like installing software on a new computer after you buy it.\n\n### File Provisioner\n\n**Simple Explanation**: Copy files from your computer to the newly created server.\n\n```hcl\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  key_name      = \"my-key-pair\"\n  \n  # Copy a file to the server\n  provisioner \"file\" {\n    source      = \"app.conf\"\n    destination = \"/etc/app/app.conf\"\n    \n    connection {\n      type        = \"ssh\"\n      user        = \"ubuntu\"\n      private_key = file(\"~/.ssh/id_rsa\")\n      host        = self.public_ip\n    }\n  }\n}\n```\n\n### Remote-Exec Provisioner\n\n**Simple Explanation**: Run commands on the server after it's created (like installing web server software).\n\n```hcl\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  key_name      = \"my-key-pair\"\n  \n  # Run commands on the server\n  provisioner \"remote-exec\" {\n    inline = [\n      \"sudo apt-get update\",\n      \"sudo apt-get install -y nginx\",\n      \"sudo systemctl start nginx\"\n    ]\n    \n    connection {\n      type        = \"ssh\"\n      user        = \"ubuntu\"\n      private_key = file(\"~/.ssh/id_rsa\")\n      host        = self.public_ip\n    }\n  }\n}\n```\n\n### Local-Exec Provisioner\n\n**Simple Explanation**: Run commands on YOUR computer (not the server) after a resource is created.\n\n```hcl\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  # Run a command locally\n  provisioner \"local-exec\" {\n    command = \"echo ${self.public_ip} > ip_address.txt\"\n  }\n  \n  # Run when destroying\n  provisioner \"local-exec\" {\n    when    = destroy\n    command = \"echo 'Instance destroyed' >> log.txt\"\n  }\n}\n```\n\n---\n\n## 12. Functions and Expressions\n\n### Built-in Functions\n\n**Simple Explanation**: Terraform has built-in functions to manipulate data, like Excel formulas but for infrastructure code.\n\n```hcl\n# String functions\nlocals {\n  server_name = \"web-server\"\n  upper_name  = upper(local.server_name)      # \"WEB-SERVER\"\n  lower_name  = lower(local.server_name)      # \"web-server\"\n  title_name  = title(local.server_name)      # \"Web-Server\"\n  \n  # Join strings\n  full_name = join(\"-\", [\"dev\", \"web\", \"server\"])  # \"dev-web-server\"\n  \n  # Split strings\n  parts = split(\"-\", \"dev-web-server\")  # [\"dev\", \"web\", \"server\"]\n}\n\n# Numeric functions\nlocals {\n  numbers = [1, 5, 3, 8, 2]\n  max_num = max(local.numbers...)     # 8\n  min_num = min(local.numbers...)     # 1\n  \n  # Round numbers\n  rounded = ceil(4.3)    # 5\n  floored = floor(4.7)   # 4\n}\n\n# Collection functions\nlocals {\n  servers = [\"web1\", \"web2\", \"web3\"]\n  \n  # Get length\n  count = length(local.servers)  # 3\n  \n  # Get element\n  first = element(local.servers, 0)  # \"web1\"\n  \n  # Check if contains\n  has_web1 = contains(local.servers, \"web1\")  # true\n  \n  # Merge maps\n  tags1 = { Name = \"Server\", Env = \"Dev\" }\n  tags2 = { Team = \"Engineering\" }\n  all_tags = merge(local.tags1, local.tags2)\n}\n```\n\n### Conditional Expressions\n\n**Simple Explanation**: Make decisions in your code - \"if this, then that.\"\n\n```hcl\nvariable \"environment\" {\n  default = \"dev\"\n}\n\n# Ternary operator: condition ? true_value : false_value\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = var.environment == \"prod\" ? \"t2.large\" : \"t2.micro\"\n  \n  tags = {\n    Name = var.environment == \"prod\" ? \"Production Server\" : \"Dev Server\"\n  }\n}\n```\n\n### For Expressions\n\n**Simple Explanation**: Loop through lists or maps to transform data, like map/filter in JavaScript or list comprehensions in Python.\n\n```hcl\nlocals {\n  # List transformation\n  server_names = [\"web1\", \"web2\", \"web3\"]\n  upper_names  = [for s in local.server_names : upper(s)]\n  # Result: [\"WEB1\", \"WEB2\", \"WEB3\"]\n  \n  # List filtering\n  numbers = [1, 2, 3, 4, 5]\n  even_numbers = [for n in local.numbers : n if n % 2 == 0]\n  # Result: [2, 4]\n  \n  # Map transformation\n  users = {\n    john = \"admin\"\n    jane = \"user\"\n  }\n  upper_roles = { for name, role in local.users : name => upper(role) }\n  # Result: { john = \"ADMIN\", jane = \"USER\" }\n}\n```\n\n### Dynamic Blocks\n\n**Simple Explanation**: Create repeating blocks dynamically instead of copying and pasting the same code multiple times.\n\n```hcl\nvariable \"ingress_rules\" {\n  default = [\n    { port = 80, description = \"HTTP\" },\n    { port = 443, description = \"HTTPS\" },\n    { port = 22, description = \"SSH\" }\n  ]\n}\n\nresource \"aws_security_group\" \"web\" {\n  name = \"web-sg\"\n  \n  # Create multiple ingress rules dynamically\n  dynamic \"ingress\" {\n    for_each = var.ingress_rules\n    content {\n      from_port   = ingress.value.port\n      to_port     = ingress.value.port\n      protocol    = \"tcp\"\n      cidr_blocks = [\"0.0.0.0/0\"]\n      description = ingress.value.description\n    }\n  }\n}\n```\n\n---\n\n## 13. Workspaces\n\n### What are Workspaces?\nWorkspaces are like having multiple copies of your infrastructure using the same code but different state files. Think of it as having dev, staging, and production environments from one codebase.\n\n### Working with Workspaces\n\n**Simple Explanation**: Create separate environments (dev, staging, prod) without duplicating your Terraform code.\n\n```bash\n# List workspaces\nterraform workspace list\n\n# Create new workspace\nterraform workspace new dev\nterraform workspace new staging\nterraform workspace new prod\n\n# Switch workspace\nterraform workspace select dev\n\n# Show current workspace\nterraform workspace show\n\n# Delete workspace\nterraform workspace delete staging\n```\n\n### Using Workspace in Code\n\n```hcl\n# Use workspace name in resource naming\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = terraform.workspace == \"prod\" ? \"t2.large\" : \"t2.micro\"\n  \n  tags = {\n    Name        = \"web-${terraform.workspace}\"\n    Environment = terraform.workspace\n  }\n}\n\n# Different configurations per workspace\nlocals {\n  instance_counts = {\n    dev     = 1\n    staging = 2\n    prod    = 5\n  }\n  \n  current_count = local.instance_counts[terraform.workspace]\n}\n\nresource \"aws_instance\" \"app\" {\n  count         = local.current_count\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n}\n```\n\n---\n\n## 14. Remote State\n\n### What is Remote State?\nRemote state stores your state file in a shared location (like S3 or Terraform Cloud) so teams can collaborate. It also adds locking so two people can't modify infrastructure at the same time.\n\n### S3 Backend Configuration\n\n**Simple Explanation**: Store state in S3 bucket so it's backed up and shareable with your team.\n\n**Step 1: Create S3 bucket and DynamoDB table (one-time setup)**\n```hcl\n# Run this first to create backend resources\nresource \"aws_s3_bucket\" \"terraform_state\" {\n  bucket = \"my-terraform-state-bucket\"\n  \n  lifecycle {\n    prevent_destroy = true\n  }\n}\n\nresource \"aws_s3_bucket_versioning\" \"terraform_state\" {\n  bucket = aws_s3_bucket.terraform_state.id\n  \n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\nresource \"aws_dynamodb_table\" \"terraform_locks\" {\n  name         = \"terraform-state-lock\"\n  billing_mode = \"PAY_PER_REQUEST\"\n  hash_key     = \"LockID\"\n  \n  attribute {\n    name = \"LockID\"\n    type = \"S\"\n  }\n}\n```\n\n**Step 2: Configure backend in your main project**\n```hcl\nterraform {\n  backend \"s3\" {\n    bucket         = \"my-terraform-state-bucket\"\n    key            = \"project/terraform.tfstate\"\n    region         = \"us-east-1\"\n    dynamodb_table = \"terraform-state-lock\"\n    encrypt        = true\n  }\n}\n```\n\n### Terraform Cloud Backend\n\n**Simple Explanation**: Use Terraform Cloud (free for small teams) to store state and run Terraform in the cloud.\n\n```hcl\nterraform {\n  cloud {\n    organization = \"my-org\"\n    \n    workspaces {\n      name = \"my-app-prod\"\n    }\n  }\n}\n```\n\n### Remote State Data Source\n\n**Simple Explanation**: Read outputs from another Terraform project's state file. Useful when different teams manage different parts of infrastructure.\n\n```hcl\n# Read state from another project\ndata \"terraform_remote_state\" \"network\" {\n  backend = \"s3\"\n  \n  config = {\n    bucket = \"my-terraform-state-bucket\"\n    key    = \"network/terraform.tfstate\"\n    region = \"us-east-1\"\n  }\n}\n\n# Use outputs from the other project\nresource \"aws_instance\" \"app\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  subnet_id     = data.terraform_remote_state.network.outputs.subnet_id\n}\n```\n\n---\n\n## 15. Best Practices\n\n### Project Structure\n\n**Simple Explanation**: Organize your Terraform code in a clean, maintainable structure.\n\n```\nproject/\nâ”œâ”€â”€ environments/\nâ”‚   â”œâ”€â”€ dev/\nâ”‚   â”‚   â”œâ”€â”€ main.tf\nâ”‚   â”‚   â”œâ”€â”€ variables.tf\nâ”‚   â”‚   â”œâ”€â”€ terraform.tfvars\nâ”‚   â”‚   â””â”€â”€ outputs.tf\nâ”‚   â”œâ”€â”€ staging/\nâ”‚   â””â”€â”€ prod/\nâ”œâ”€â”€ modules/\nâ”‚   â”œâ”€â”€ networking/\nâ”‚   â”œâ”€â”€ compute/\nâ”‚   â””â”€â”€ database/\nâ”œâ”€â”€ global/\nâ”‚   â”œâ”€â”€ iam/\nâ”‚   â””â”€â”€ s3/\nâ””â”€â”€ README.md\n```\n\n### Naming Conventions\n\n```hcl\n# Good naming practices\nresource \"aws_instance\" \"web_server\" {         # Use underscores\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = var.instance_type\n  \n  tags = {\n    Name        = \"web-server-${var.environment}\"  # Use hyphens in tags\n    Environment = var.environment\n    ManagedBy   = \"Terraform\"\n    Project     = var.project_name\n  }\n}\n\n# Use locals for computed values\nlocals {\n  common_tags = {\n    Environment = var.environment\n    ManagedBy   = \"Terraform\"\n    Project     = var.project_name\n  }\n  \n  name_prefix = \"${var.project_name}-${var.environment}\"\n}\n\nresource \"aws_s3_bucket\" \"assets\" {\n  bucket = \"${local.name_prefix}-assets\"\n  tags   = local.common_tags\n}\n```\n\n### Variable Validation\n\n**Simple Explanation**: Add validation rules to variables to catch mistakes early.\n\n```hcl\nvariable \"environment\" {\n  description = \"Environment name\"\n  type        = string\n  \n  validation {\n    condition     = contains([\"dev\", \"staging\", \"prod\"], var.environment)\n    error_message = \"Environment must be dev, staging, or prod.\"\n  }\n}\n\nvariable \"instance_count\" {\n  description = \"Number of instances\"\n  type        = number\n  \n  validation {\n    condition     = var.instance_count > 0 && var.instance_count <= 10\n    error_message = \"Instance count must be between 1 and 10.\"\n  }\n}\n```\n\n### Use Terraform Fmt and Validate\n\n```bash\n# Format code properly\nterraform fmt -recursive\n\n# Validate configuration\nterraform validate\n\n# Check for security issues (requires tfsec)\ntfsec .\n```\n\n### Security Best Practices\n\n```hcl\n# Don't hardcode sensitive values\nresource \"aws_db_instance\" \"main\" {\n  username = var.db_username         # Good: Use variables\n  password = var.db_password         # Good: Pass via environment or vault\n  \n  # Bad examples (don't do this):\n  # username = \"admin\"\n  # password = \"password123\"\n}\n\n# Use sensitive flag for outputs\noutput \"database_password\" {\n  value     = aws_db_instance.main.password\n  sensitive = true  # Prevents showing in logs\n}\n\n# Enable encryption\nresource \"aws_s3_bucket\" \"data\" {\n  bucket = \"my-data-bucket\"\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"data\" {\n  bucket = aws_s3_bucket.data.id\n  \n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"AES256\"\n    }\n  }\n}\n```\n\n---\n\n## 16. Advanced Topics\n\n### Count vs For_Each\n\n**Simple Explanation**: Both create multiple resources, but `for_each` is better when you need to reference specific items.\n\n```hcl\n# Count (good for identical resources)\nvariable \"instance_count\" {\n  default = 3\n}\n\nresource \"aws_instance\" \"web\" {\n  count         = var.instance_count\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  tags = {\n    Name = \"web-${count.index}\"\n  }\n}\n\n# For_each (better for named resources)\nvariable \"servers\" {\n  default = {\n    web  = \"t2.micro\"\n    api  = \"t2.small\"\n    db   = \"t2.medium\"\n  }\n}\n\nresource \"aws_instance\" \"servers\" {\n  for_each = var.servers\n  \n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = each.value\n  \n  tags = {\n    Name = each.key\n  }\n}\n\n# Access specific instance\noutput \"web_server_ip\" {\n  value = aws_instance.servers[\"web\"].public_ip\n}\n```\n\n### Lifecycle Rules\n\n**Simple Explanation**: Control how Terraform creates, updates, or destroys resources.\n\n```hcl\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  \n  lifecycle {\n    # Create new resource before destroying old one\n    create_before_destroy = true\n    \n    # Prevent accidental deletion\n    prevent_destroy = false\n    \n    # Ignore changes to specific attributes\n    ignore_changes = [\n      tags[\"LastModified\"],\n      user_data\n    ]\n  }\n}\n```\n\n### Depends_On\n\n**Simple Explanation**: Explicitly declare dependencies when Terraform can't figure them out automatically.\n\n```hcl\nresource \"aws_iam_role\" \"example\" {\n  name = \"example-role\"\n  \n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Action = \"sts:AssumeRole\"\n      Effect = \"Allow\"\n      Principal = {\n        Service = \"ec2.amazonaws.com\"\n      }\n    }]\n  })\n}\n\nresource \"aws_iam_role_policy\" \"example\" {\n  name = \"example-policy\"\n  role = aws_iam_role.example.id\n  \n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Action   = [\"s3:*\"]\n      Effect   = \"Allow\"\n      Resource = \"*\"\n    }]\n  })\n}\n\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  iam_instance_profile = aws_iam_instance_profile.example.name\n  \n  # Wait for policy to be attached before creating instance\n  depends_on = [aws_iam_role_policy.example]\n}\n```\n\n### Terraform Import\n\n**Simple Explanation**: Import existing resources (created manually or by other tools) into Terraform management.\n\n```bash\n# Import existing EC2 instance\nterraform import aws_instance.web i-1234567890abcdef0\n\n# Import S3 bucket\nterraform import aws_s3_bucket.my_bucket my-existing-bucket\n\n# After import, write the configuration to match\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  # ... other attributes\n}\n```\n\n### Null Resource and Triggers\n\n**Simple Explanation**: Run provisioners or scripts without creating actual infrastructure, useful for running automation tasks.\n\n```hcl\nresource \"null_resource\" \"health_check\" {\n  # Run this whenever the instance ID changes\n  triggers = {\n    instance_id = aws_instance.web.id\n  }\n  \n  provisioner \"local-exec\" {\n    command = \"curl http://${aws_instance.web.public_ip}/health\"\n  }\n}\n```\n\n---\n\n## 17. Real-World Project\n\n### Complete 3-Tier Web Application\n\n**Simple Explanation**: Build a complete production-ready web application infrastructure with web servers, application servers, and database.\n\n**Project Structure:**\n```\nweb-app/\nâ”œâ”€â”€ main.tf\nâ”œâ”€â”€ variables.tf\nâ”œâ”€â”€ outputs.tf\nâ”œâ”€â”€ terraform.tfvars\nâ”œâ”€â”€ modules/\nâ”‚   â”œâ”€â”€ networking/\nâ”‚   â”œâ”€â”€ security/\nâ”‚   â”œâ”€â”€ compute/\nâ”‚   â””â”€â”€ database/\n```\n\n**File: `variables.tf`**\n```hcl\nvariable \"project_name\" {\n  description = \"Name of the project\"\n  type        = string\n  default     = \"myapp\"\n}\n\nvariable \"environment\" {\n  description = \"Environment (dev/staging/prod)\"\n  type        = string\n  \n  validation {\n    condition     = contains([\"dev\", \"staging\", \"prod\"], var.environment)\n    error_message = \"Environment must be dev, staging, or prod.\"\n  }\n}\n\nvariable \"region\" {\n  description = \"AWS region\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"CIDR block for VPC\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\nvariable \"db_username\" {\n  description = \"Database username\"\n  type        = string\n  sensitive   = true\n}\n\nvariable \"db_password\" {\n  description = \"Database password\"\n  type        = string\n  sensitive   = true\n}\n```\n\n**File: `main.tf`**\n```hcl\nterraform {\n  required_version = \">= 1.0\"\n  \n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n  \n  backend \"s3\" {\n    bucket         = \"my-terraform-state\"\n    key            = \"web-app/terraform.tfstate\"\n    region         = \"us-east-1\"\n    dynamodb_table = \"terraform-lock\"\n    encrypt        = true\n  }\n}\n\nprovider \"aws\" {\n  region = var.region\n  \n  default_tags {\n    tags = {\n      Project     = var.project_name\n      Environment = var.environment\n      ManagedBy   = \"Terraform\"\n    }\n  }\n}\n\n# VPC and Networking\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = var.vpc_cidr\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-vpc\"\n  }\n}\n\n# Internet Gateway\nresource \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-igw\"\n  }\n}\n\n# Public Subnets\nresource \"aws_subnet\" \"public\" {\n  count                   = 2\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index)\n  availability_zone       = data.aws_availability_zones.available.names[count.index]\n  map_public_ip_on_launch = true\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-public-${count.index + 1}\"\n  }\n}\n\n# Private Subnets\nresource \"aws_subnet\" \"private\" {\n  count             = 2\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = cidrsubnet(var.vpc_cidr, 8, count.index + 2)\n  availability_zone = data.aws_availability_zones.available.names[count.index]\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-private-${count.index + 1}\"\n  }\n}\n\n# Data source for availability zones\ndata \"aws_availability_zones\" \"available\" {\n  state = \"available\"\n}\n\n# Route Table for Public Subnets\nresource \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  \n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.main.id\n  }\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-public-rt\"\n  }\n}\n\n# Associate public subnets with route table\nresource \"aws_route_table_association\" \"public\" {\n  count          = 2\n  subnet_id      = aws_subnet.public[count.index].id\n  route_table_id = aws_route_table.public.id\n}\n\n# Security Group for Web Servers\nresource \"aws_security_group\" \"web\" {\n  name        = \"${var.project_name}-${var.environment}-web-sg\"\n  description = \"Security group for web servers\"\n  vpc_id      = aws_vpc.main.id\n  \n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n    description = \"Allow HTTP\"\n  }\n  \n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n    description = \"Allow HTTPS\"\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-web-sg\"\n  }\n}\n\n# Security Group for Database\nresource \"aws_security_group\" \"db\" {\n  name        = \"${var.project_name}-${var.environment}-db-sg\"\n  description = \"Security group for database\"\n  vpc_id      = aws_vpc.main.id\n  \n  ingress {\n    from_port       = 3306\n    to_port         = 3306\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.web.id]\n    description     = \"Allow MySQL from web servers\"\n  }\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-db-sg\"\n  }\n}\n\n# Application Load Balancer\nresource \"aws_lb\" \"main\" {\n  name               = \"${var.project_name}-${var.environment}-alb\"\n  internal           = false\n  load_balancer_type = \"application\"\n  security_groups    = [aws_security_group.web.id]\n  subnets            = aws_subnet.public[*].id\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-alb\"\n  }\n}\n\n# Target Group\nresource \"aws_lb_target_group\" \"web\" {\n  name     = \"${var.project_name}-${var.environment}-tg\"\n  port     = 80\n  protocol = \"HTTP\"\n  vpc_id   = aws_vpc.main.id\n  \n  health_check {\n    path                = \"/\"\n    healthy_threshold   = 2\n    unhealthy_threshold = 10\n  }\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-tg\"\n  }\n}\n\n# Listener\nresource \"aws_lb_listener\" \"web\" {\n  load_balancer_arn = aws_lb.main.arn\n  port              = \"80\"\n  protocol          = \"HTTP\"\n  \n  default_action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.web.arn\n  }\n}\n\n# Launch Template\nresource \"aws_launch_template\" \"web\" {\n  name_prefix   = \"${var.project_name}-${var.environment}-\"\n  image_id      = data.aws_ami.ubuntu.id\n  instance_type = var.environment == \"prod\" ? \"t3.medium\" : \"t3.micro\"\n  \n  vpc_security_group_ids = [aws_security_group.web.id]\n  \n  user_data = base64encode(<<-EOF\n              #!/bin/bash\n              apt-get update\n              apt-get install -y nginx\n              echo \"<h1>Hello from ${var.project_name}-${var.environment}</h1>\" > /var/www/html/index.html\n              systemctl start nginx\n              systemctl enable nginx\n              EOF\n  )\n  \n  tag_specifications {\n    resource_type = \"instance\"\n    tags = {\n      Name = \"${var.project_name}-${var.environment}-web\"\n    }\n  }\n}\n\n# Auto Scaling Group\nresource \"aws_autoscaling_group\" \"web\" {\n  name                = \"${var.project_name}-${var.environment}-asg\"\n  vpc_zone_identifier = aws_subnet.public[*].id\n  target_group_arns   = [aws_lb_target_group.web.arn]\n  health_check_type   = \"ELB\"\n  min_size            = var.environment == \"prod\" ? 2 : 1\n  max_size            = var.environment == \"prod\" ? 10 : 3\n  desired_capacity    = var.environment == \"prod\" ? 4 : 2\n  \n  launch_template {\n    id      = aws_launch_template.web.id\n    version = \"$Latest\"\n  }\n  \n  tag {\n    key                 = \"Name\"\n    value               = \"${var.project_name}-${var.environment}-asg-instance\"\n    propagate_at_launch = true\n  }\n}\n\n# RDS Subnet Group\nresource \"aws_db_subnet_group\" \"main\" {\n  name       = \"${var.project_name}-${var.environment}-db-subnet\"\n  subnet_ids = aws_subnet.private[*].id\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-db-subnet\"\n  }\n}\n\n# RDS Instance\nresource \"aws_db_instance\" \"main\" {\n  identifier             = \"${var.project_name}-${var.environment}-db\"\n  engine                 = \"mysql\"\n  engine_version         = \"8.0\"\n  instance_class         = var.environment == \"prod\" ? \"db.t3.medium\" : \"db.t3.micro\"\n  allocated_storage      = var.environment == \"prod\" ? 100 : 20\n  storage_encrypted      = true\n  db_name                = replace(var.project_name, \"-\", \"\")\n  username               = var.db_username\n  password               = var.db_password\n  db_subnet_group_name   = aws_db_subnet_group.main.name\n  vpc_security_group_ids = [aws_security_group.db.id]\n  skip_final_snapshot    = var.environment != \"prod\"\n  multi_az               = var.environment == \"prod\"\n  \n  backup_retention_period = var.environment == \"prod\" ? 7 : 1\n  \n  tags = {\n    Name = \"${var.project_name}-${var.environment}-db\"\n  }\n}\n\n# Get latest Ubuntu AMI\ndata \"aws_ami\" \"ubuntu\" {\n  most_recent = true\n  owners      = [\"099720109477\"]\n  \n  filter {\n    name   = \"name\"\n    values = [\"ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*\"]\n  }\n}\n```\n\n**File: `outputs.tf`**\n```hcl\noutput \"load_balancer_dns\" {\n  description = \"DNS name of the load balancer\"\n  value       = aws_lb.main.dns_name\n}\n\noutput \"database_endpoint\" {\n  description = \"RDS database endpoint\"\n  value       = aws_db_instance.main.endpoint\n  sensitive   = true\n}\n\noutput \"vpc_id\" {\n  description = \"VPC ID\"\n  value       = aws_vpc.main.id\n}\n\noutput \"web_url\" {\n  description = \"URL to access the application\"\n  value       = \"http://${aws_lb.main.dns_name}\"\n}\n```\n\n**File: `terraform.tfvars`**\n```hcl\nproject_name = \"myapp\"\nenvironment  = \"dev\"\nregion       = \"us-east-1\"\nvpc_cidr     = \"10.0.0.0/16\"\n\n# Don't put sensitive values here in production!\n# Use environment variables or secret management instead\ndb_username = \"admin\"\ndb_password = \"changeme123!\"\n```\n\n### Running the Project\n\n```bash\n# Initialize\nterraform init\n\n# Plan\nterraform plan\n\n# Apply\nterraform apply -auto-approve\n\n# Get outputs\nterraform output\n\n# Access the application\nterraform output web_url\n\n# Destroy when done\nterraform destroy -auto-approve\n```\n\n---\n\n## Quick Reference Commands\n\n```bash\n# Initialization\nterraform init                    # Initialize working directory\nterraform init -upgrade           # Upgrade providers\n\n# Planning\nterraform plan                    # Show execution plan\nterraform plan -out=plan.tfplan   # Save plan to file\n\n# Applying\nterraform apply                   # Apply changes\nterraform apply plan.tfplan       # Apply saved plan\nterraform apply -auto-approve     # Skip confirmation\n\n# Destroying\nterraform destroy                 # Destroy all resources\nterraform destroy -target=<resource>  # Destroy specific resource\n\n# State Management\nterraform state list              # List resources in state\nterraform state show <resource>   # Show resource details\nterraform state rm <resource>     # Remove resource from state\nterraform state mv <src> <dest>   # Rename resource in state\n\n# Outputs\nterraform output                  # Show all outputs\nterraform output <name>           # Show specific output\n\n# Formatting & Validation\nterraform fmt                     # Format code\nterraform fmt -recursive          # Format all files\nterraform validate                # Validate configuration\n\n# Workspaces\nterraform workspace list          # List workspaces\nterraform workspace new <name>    # Create workspace\nterraform workspace select <name> # Switch workspace\n\n# Other\nterraform show                    # Show current state\nterraform console                 # Interactive console\nterraform graph                   # Generate dependency graph\nterraform providers               # Show providers\n```\n\n---\n\n## Congratulations! ðŸŽ‰\n\nYou've completed the Terraform Zero to Hero course! You now know:\n\n1. âœ… What Terraform is and why to use it\n2. âœ… How to install and configure Terraform\n3. âœ… Basic concepts (providers, resources, state)\n4. âœ… Variables, outputs, and data sources\n5. âœ… Modules for code reusability\n6. âœ… Functions and expressions\n7. âœ… Workspaces and remote state\n8. âœ… Best practices and security\n9. âœ… Advanced features\n10. âœ… Real-world project implementation\n\n### Next Steps:\n- Practice building infrastructure in your cloud provider\n- Explore Terraform Registry for pre-built modules\n- Learn about Terraform Cloud for team collaboration\n- Contribute to open-source Terraform modules\n- Build automated CI/CD pipelines with Terraform\n\n### Resources:\n- [Terraform Documentation](https://www.terraform.io/docs)\n- [Terraform Registry](https://registry.terraform.io/)\n- [HashiCorp Learn](https://learn.hashicorp.com/terraform)\n- [Terraform Best Practices](https://www.terraform-best-practices.com/)\n\nHappy Terraforming! ðŸš€\n"}